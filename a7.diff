diff --git a/a6.diff b/a6.diff
new file mode 100644
index 0000000..7bfff42
--- /dev/null
+++ b/a6.diff
@@ -0,0 +1,10435 @@
+diff --git a/A6_written_problems.txt b/A6_written_problems.txt
+new file mode 100644
+index 0000000..4a2f8b6
+--- /dev/null
++++ b/A6_written_problems.txt
+@@ -0,0 +1,28 @@
++1. An implementation of or() is provided below:
++
++/** Returns: disjunction of this and that (this OR that). */
++public TVBool or(TVBool that) {
++	TVBool result = new TVBool();
++	result.state = Math.max(this.state, that.state);
++	return result;
++}
++
++2. normalize() is implemented correctly because it is simply a checking method whose job is to assert that there isn't any flaws in the logic of the other methods. It never actually changes the representation of the TVBool when being accessed by different classes because if the normalize method retains the sign of the field state even if the technical value of the field is changed. not() is implemented correctly because it never actually changes the value of the field state. It creates a new object, sets the state of that object, and returns that object. It never alters the state of the original object.
++
++3. The hashCode() method is incorrect because if two TVBools are equal, they need to have the same hash code. The given implementation does not have this property. A correct implementation is provided below:
++
++@Override
++public int hashCode() {
++	return Integer.signum(state);
++}
++
++An implementation of equals() is provided below:
++
++@Override
++public boolean equals(Object o) {
++	if (Integer.signum(state) == Integer.signum(o.state)) {
++		return true;
++	} else {
++		return false;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/resources/constants.txt b/constants.txt
+similarity index 100%
+rename from src/main/resources/constants.txt
+rename to constants.txt
+diff --git a/diff.txt b/diff.txt
+new file mode 100644
+index 0000000..40c893c
+--- /dev/null
++++ b/diff.txt
+@@ -0,0 +1,6681 @@
++diff --git a/.gitignore b/.gitignore
++index cba70df..9d56415 100644
++--- a/.gitignore
+++++ b/.gitignore
++@@ -12,3 +12,8 @@ content
++ *.pdf
++ *.DS_Store
++ 
+++src/main/java/interpret/ActionOutcome.java
+++src/main/java/parse/Token.java
+++src/main/java/parse/TokenCategory.java
+++src/main/java/parse/Tokenizer.java
+++src/main/java/parse/TokenType.java
++diff --git a/a5world.txt b/a5world.txt
++new file mode 100644
++index 0000000..e9fafb5
++--- /dev/null
+++++ b/a5world.txt
++@@ -0,0 +1,13 @@
+++name a5 world
+++size 7 8
+++rock 0 4
+++rock 6 6
+++rock 0 1
+++rock 9 10
+++
+++// Some food
+++food 2 5 500
+++
+++// example-critter.txt should be in the working directory
+++critter example-critter.txt 2 3 1
+++critter example-critter.txt 2 1 5
++\ No newline at end of file
++diff --git a/biggerworld.txt b/biggerworld.txt
++new file mode 100644
++index 0000000..10c3b47
++--- /dev/null
+++++ b/biggerworld.txt
++@@ -0,0 +1,42 @@
+++name Slightly bigger world
+++size 100 150
+++rock 2 2
+++rock 3 6
+++rock 9 10
+++
+++// Some food
+++food 4 4 500
+++food 1 3 1000
+++food 28 128 10000
+++food 29 129 10000
+++food 29 129 10000
+++food 29 128 10000
+++food 26 128 10000
+++food 26 129 10000
+++food 28 129 10000
+++food 26 127 10000
+++food 41 25 10000
+++food 39 26 10000
+++food 39 25 10000
+++food 39 28 10000
+++food 40 26 10000
+++food 41 28 10000
+++food 38 24 10000
+++food 39 24 10000
+++
+++// example-critter.txt should be in the working directory
+++critter example-critter.txt 2 5 3
+++critter example-critter.txt 4 3 1
+++critter example-critter.txt 4 4 2
+++critter example-critter.txt 40 25 4
+++critter example-critter.txt 88 93 0
+++critter example-critter.txt 66 128 5
+++critter example-critter.txt 71 40 5
+++critter example-critter.txt 69 100 5
+++critter example-critter.txt 42 28 5
+++critter example-critter.txt 60 58 5
+++critter example-critter.txt 32 81 5
+++critter example-critter.txt 97 60 5
+++critter example-critter.txt 14 128 5
+++critter example-critter.txt 27 128 5
+++
++diff --git a/example-critter.txt b/example-critter.txt
++new file mode 100644
++index 0000000..cc5a71d
++--- /dev/null
+++++ b/example-critter.txt
++@@ -0,0 +1,22 @@
+++species: example
+++memsize: 9
+++defense: 2
+++offense: 3
+++size: 100
+++energy: 500000
+++posture: 17
+++POSTURE != 17 --> POSTURE := 17; // we are species 17!
+++nearby[3] = 0 and ENERGY > 2500 --> bud;
+++{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
+++ahead[1] < -1 and ENERGY < 500 * SIZE --> eat;
+++// next line attacks only other species
+++(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
+++ahead[1] < -5 --> forward;
+++ahead[2] < -10 and ahead[1] = 0 --> forward;
+++ahead[3] < -15 and ahead[1] = 0 --> forward;
+++ahead[4] < -20 and ahead[1] = 0 --> forward;
+++nearby[0] > 0 and nearby[3] = 0 --> backward;
+++// karma action: donate food if we are too full or large enough
+++{ahead[1] = 0 or ahead[1] < -1} and { ENERGY > 2500 or SIZE > 7 } --> serve[ENERGY / 42];
+++random[3] = 1 --> left;
+++1 = 1 --> wait; // mostly soak up the rays
++diff --git a/examples/failure-example-critter1.txt b/examples/failure-example-critter1.txt
++new file mode 100644
++index 0000000..e69de29
++diff --git a/examples/world.txt b/examples/world.txt
++index 0fbfadf..91bdd68 100644
++--- a/examples/world.txt
+++++ b/examples/world.txt
++@@ -8,7 +8,7 @@ rock 9 10
++ food 4 4 500
++ food 1 3 1000
++ 
++-// example_critter.txt should be in the working directory
++-critter example_critter.txt 2 5 3
++-critter example_critter.txt 4 3 1
++-critter example_critter.txt 4 4 2
+++// example-critter.txt should be in the working directory
+++critter example-critter.txt 2 5 3
+++critter example-critter.txt 4 3 1
+++critter example-critter.txt 4 4 2
++diff --git a/log.txt b/log.txt
++new file mode 100644
++index 0000000..7aedfce
++--- /dev/null
+++++ b/log.txt
++@@ -0,0 +1,271 @@
+++[33mcommit fce536fec1b6d39c94b8eb25247226e99b89f023[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
+++Merge: faaae27 41fe28e
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 22:47:22 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit faaae27e8751ae57808ad7b3b0819f7624e3e782[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 22:46:48 2017 -0400
+++
+++    Final tests
+++
+++[33mcommit 41fe28e826698ca5cf3e31913bdf54842644b50c[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 22:44:40 2017 -0400
+++
+++    Testing Done
+++
+++[33mcommit 3f34641d080ef40ea4dbab4d1980324643736d26[m
+++Merge: 3631e4c 2e8bab8
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 21:38:55 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit 3631e4cef53d386e115ab7fa8364e9d22a95efe9[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 21:38:49 2017 -0400
+++
+++    Turning Tests
+++
+++[33mcommit 2e8bab888d0b606f53dda0b449210c2f3996abdc[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 21:35:36 2017 -0400
+++
+++    More Tests
+++
+++[33mcommit 90fd50cc87b830aff15673e999c4cd22044a9543[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 20:43:50 2017 -0400
+++
+++    Tests!
+++
+++[33mcommit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 20:14:08 2017 -0400
+++
+++    SpiralCritter works now
+++
+++[33mcommit 9bdbd6cc4f186af60209dce78176917924f76428[m
+++Merge: 4c6c2ee 4892088
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 16:57:49 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 16:57:41 2017 -0400
+++
+++    Minor fixes
+++
+++[33mcommit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 15:37:39 2017 -0400
+++
+++    Mating Testing Final
+++
+++[33mcommit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 15:31:26 2017 -0400
+++
+++    Mating Testing
+++
+++[33mcommit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460[m
+++Merge: d3b6060 753823a
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 14:59:59 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit d3b60607e47ccc71ddb9a8a65f249e65e127bb22[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 14:58:53 2017 -0400
+++
+++    Mate Test Change
+++
+++[33mcommit 9ca82f204cd008b0e3449775ebc042e96557f9a4[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 14:57:30 2017 -0400
+++
+++    File Parser Update
+++
+++[33mcommit ecdea17320fd143cf698fc9faa53d5b39131f071[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 14:57:00 2017 -0400
+++
+++    Mate Testing Done and Bug Fixed
+++
+++[33mcommit b669ff85cd406986cb387789b43c622d2fd53366[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 13:11:19 2017 -0400
+++
+++    Mate Testing
+++
+++[33mcommit b24dcaeecb0961141406915da0977e58847259c1[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 13:01:45 2017 -0400
+++
+++    Testing
+++
+++[33mcommit d9804214694a1287b36387ab5096161119fb7d2a[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 13:00:32 2017 -0400
+++
+++    Testing2
+++
+++[33mcommit 760b3702d46d973fc51fdfe2988e1365e553c229[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 12:59:02 2017 -0400
+++
+++    Revert "Testing"
+++    
+++    This reverts commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28.
+++
+++[33mcommit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 12:54:41 2017 -0400
+++
+++    Testing
+++
+++[33mcommit 753823a1f154f70f6e374d0b5e88df5d8239cd1e[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 12:49:12 2017 -0400
+++
+++    more fixes
+++
+++[33mcommit 086816869af82477368bfd3c77e6e9f1cff9e8fd[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 12:46:23 2017 -0400
+++
+++    Fixes
+++
+++[33mcommit a02473c4318c5f7012d276aed173e05a84fa7cfd[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 12:42:26 2017 -0400
+++
+++    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw"
+++    
+++    This reverts commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b, reversing
+++    changes made to 21179a6b02c48db2457e6bdb649d6b4b581bd6e3.
+++
+++[33mcommit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b[m
+++Merge: 21179a6 8fc49a4
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 12:41:21 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 12:40:30 2017 -0400
+++
+++    Stuff
+++
+++[33mcommit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 12:39:25 2017 -0400
+++
+++    Tokenizer Has Been Updated With Correct Solution
+++
+++[33mcommit cebe8f1a5273b0a0a02553cd42f682511f53e186[m
+++Merge: 0343510 878321e
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 09:16:26 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit 03435103759b26ede1d3b7c4215dd1f117cd927a[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Tue Oct 31 09:16:19 2017 -0400
+++
+++    Bud Test
+++
+++[33mcommit 878321e363ceaa0b2d586c8be5b0102618d50634[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 02:11:11 2017 -0400
+++
+++    Documentation
+++
+++[33mcommit dc3812325cb76cf5af623bba64f907b01ca7e243[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 01:31:22 2017 -0400
+++
+++    Misc stuff
+++
+++[33mcommit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 01:09:31 2017 -0400
+++
+++    Documentation + finishing up console
+++
+++[33mcommit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Tue Oct 31 00:01:43 2017 -0400
+++
+++    More documentation
+++
+++[33mcommit 4c6783d0533f75d5d9b97742f61e7803f5aa4390[m
+++Merge: c4f5689 adc8c91
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 23:51:40 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit c4f56899144a8923b956408256221a5e46fcc436[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 23:51:38 2017 -0400
+++
+++    Documentation
+++
+++[33mcommit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b[m
+++Merge: 88613b7 ef684b3
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Mon Oct 30 23:47:38 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Mon Oct 30 23:47:33 2017 -0400
+++
+++    Moving Test Done
+++
+++[33mcommit ef684b37c2fe6924efcc416a45c716297c9f46d6[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 23:45:01 2017 -0400
+++
+++    Fixes
+++
+++[33mcommit 067278303066953f1241de39755d7545b4cb4b1e[m
+++Merge: a6d2ead 5a4812d
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 23:43:56 2017 -0400
+++
+++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+++
+++[33mcommit a6d2eadf9badd7c0c163420549e66e2f9eaa2145[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 23:43:41 2017 -0400
+++
+++    Spiral stuff
+++
+++[33mcommit 5a4812d93de841aed1720ee36c4a6e9304f368e0[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Mon Oct 30 23:25:53 2017 -0400
+++
+++    Moving Test Initial
+++
+++[33mcommit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c[m
+++Author: Andy <az389@cornell.edu>
+++Date:   Mon Oct 30 17:53:50 2017 -0400
+++
+++    SpiralCritter stuff
+++
+++[33mcommit 200b419d4d5d2162ef30ddeb630491a180dd968d[m
+++Author: sn438 <31802007+sn438@users.noreply.github.com>
+++Date:   Mon Oct 30 17:35:38 2017 -0400
+++
+++ 
++\ No newline at end of file
++diff --git a/src/main/java/ast/Action.java b/src/main/java/ast/Action.java
++index bca9a07..fc50150 100644
++--- a/src/main/java/ast/Action.java
+++++ b/src/main/java/ast/Action.java
++@@ -2,8 +2,6 @@ package ast;
++ 
++ import java.util.Random;
++ 
++-import ast.Action.ActType;
++-
++ /** An AST representation of a critter action. */
++ public class Action extends AbstractNode implements CommandComponent
++ {
++@@ -27,6 +25,32 @@ public class Action extends AbstractNode implements CommandComponent
++ 		val.setParent(this);
++ 	}
++ 	
+++	/** Returns the type of action contained in this node. */
+++	public ActType getActType()
+++	{
+++		return act;
+++	}
+++	
+++	/** Sets the value of {@code act} to {@code at}, modifying {@code val} as necessary. */
+++	public void setActType(ActType at)
+++	{
+++		Random r = new Random();
+++		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
+++		{
+++			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+++				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
+++		}
+++		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+++			this.val = null;
+++		this.act = at;
+++	}
+++	
+++	/** Returns the expression stored at this node, if there is one. */
+++	public Expr getVal()
+++	{
+++		return val;
+++	}
+++	
++ 	@Override
++ 	public int size()
++ 	{
++@@ -124,23 +148,6 @@ public class Action extends AbstractNode implements CommandComponent
++ 		return sb;
++ 	}
++ 	
++-	/**
++-	 * setActType sets the ActType for the Action. 
++-	 * @param at is the ActType that the Action is being set to. If at is not of the same type as the original 
++-	 * ActType, then the value is modified if necessary.
++-	 */
++-	public void setActType(ActType at)
++-	{
++-		Random r = new Random();
++-		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
++-		{
++-			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
++-				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
++-		}
++-		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
++-			this.val = null;
++-		this.act = at;
++-	}
++ 	/** An enumeration of all the possible action types. */
++ 	public enum ActType
++ 	{
++diff --git a/src/main/java/ast/BinaryCondition.java b/src/main/java/ast/BinaryCondition.java
++index 99ce650..4bc10ad 100644
++--- a/src/main/java/ast/BinaryCondition.java
+++++ b/src/main/java/ast/BinaryCondition.java
++@@ -1,5 +1,7 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** A representation of a binary Boolean condition: 'and' or 'or' */
++ public class BinaryCondition extends AbstractNode implements Condition
++ {
++@@ -20,44 +22,43 @@ public class BinaryCondition extends AbstractNode implements Condition
++ 		left.setParent(this);
++ 		right.setParent(this);
++ 	}
++-	/**
++-	 * getLeft returns the left node for the BinaryCondition.
++-	 * @return left node.
++-	 */
+++	/** Returns the left child of this binary condition. */
++ 	public Condition getLeft()
++ 	{
++ 		return left;
++ 	}
++ 	
++-	/**
++-	 * setLeft sets the left node for the Binary Condition.
++-	 * @param newLeft is the new left node of the Binary Condition.
++-	 */
+++	/** Sets the value of {@code left} to {@code newleft}. */
++ 	public void setLeft(Condition newLeft)
++ 	{
++ 		left = newLeft;
++ 		left.setParent(this);
++ 	}
++ 	
++-	/**
++-	 * getRight returns the right node for the BinaryCondition.
++-	 * @return right node.
++-	 */
+++	/** Returns the right child of this binary condition. */
++ 	public Condition getRight()
++ 	{
++ 		return right;
++ 	}
++ 	
++-	/**
++-	 * setRight sets the left node for the Binary Condition.
++-	 * @param newRight is the new left node of the Binary Condition.
++-	 */
+++	/** Sets the value of {@code right} to {@code newRight}. */
++ 	public void setRight(Condition newRight)
++ 	{
++ 		right = newRight;
++ 		right.setParent(this);
++ 	}
++ 	
+++	/** Returns the operator type of this binary condition. */
+++	public Operator getOp()
+++	{
+++		return op;
+++	}
+++	
+++	/** Sets the value of {@code op} to {@code o}. */
+++	public void setOp(Operator o)
+++	{
+++		this.op = o;
+++	}
++ 	@Override
++ 	public int size()
++ 	{
++@@ -130,9 +131,9 @@ public class BinaryCondition extends AbstractNode implements Condition
++ 	}
++ 
++ 	@Override
++-	public boolean evaluate()
+++	public boolean acceptEvaluation(Interpreter i)
++ 	{
++-		throw new UnsupportedOperationException();
+++		return i.eval(this);
++ 	}
++ 
++ 	/** An enumeration of all possible binary condition operators. */
++@@ -146,11 +147,4 @@ public class BinaryCondition extends AbstractNode implements Condition
++ 	{
++ 		return NodeType.BINARYCONDITION;
++ 	}
++-	/**
++-	 * setOperator sets the operator to op.
++-	 * @param op is the parameter that operator is being set to. 
++-	 */
++-	public void setOperator(Operator op) {
++-		this.op = op;
++-	}
++ }
++\ No newline at end of file
++diff --git a/src/main/java/ast/BinaryExpr.java b/src/main/java/ast/BinaryExpr.java
++index 1765f87..dac5008 100644
++--- a/src/main/java/ast/BinaryExpr.java
+++++ b/src/main/java/ast/BinaryExpr.java
++@@ -1,5 +1,7 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** A representation of a binary numerical expression that evaluates to an integer. */
++ public class BinaryExpr extends AbstractNode implements Expr
++ {
++@@ -20,25 +22,34 @@ public class BinaryExpr extends AbstractNode implements Expr
++ 		left.setParent(this);
++ 		right.setParent(this);
++ 	}
++-	
+++	/** Returns the left child of this binary expression. */
++ 	public Expr getLeft()
++ 	{
++ 		return left;
++ 	}
+++	/** Sets the value of {@code left} to {@code newLeft}. */
++ 	public void setLeft(Expr newLeft)
++ 	{
++ 		left = newLeft;
++ 		left.setParent(this);
++ 	}
+++	/** Returns the right child of this binary expression. */
++ 	public Expr getRight()
++ 	{
++ 		return right;
++ 	}
+++	/** Sets the value of {@code right} to {@code newRight}. */
++ 	public void setRight(Expr newRight)
++ 	{
++ 		right = newRight;
++ 		right.setParent(this);
++ 	}
+++	/** Returns the operator type of this binary expression. */
+++	public MathOp getOperator()
+++	{
+++		return operator;
+++	}
+++	/** Sets the value of {@code operator} to {@code op}. */
++ 	public void setOperator(MathOp op)
++ 	{
++ 		this.operator = op;
++@@ -131,9 +142,9 @@ public class BinaryExpr extends AbstractNode implements Expr
++ 		return sb;
++ 	}
++ 	@Override
++-	public int evaluate()
+++	public int acceptEvaluation(Interpreter i)
++ 	{
++-		throw new UnsupportedOperationException();
+++		return i.eval(this);
++ 	}
++ 
++ 	/** Enumerates all the accepted binary mathematical operations. */
++diff --git a/src/main/java/ast/Command.java b/src/main/java/ast/Command.java
++index 79d7011..c46d579 100644
++--- a/src/main/java/ast/Command.java
+++++ b/src/main/java/ast/Command.java
++@@ -21,10 +21,19 @@ public class Command extends AbstractNode
++ 			u.setParent(this);
++ 		last.setParent(this);
++ 	}
+++	
+++	/** Returns the list of updates in this command. */
++ 	public LinkedList<Update> getUpdateList()
++ 	{
++ 		return UpdateList;
++ 	}
+++	
+++	/** Returns the last component of this command. */
+++	public CommandComponent getLast()
+++	{
+++		return last;
+++	}
+++	
++ 	@Override
++ 	public int size()
++ 	{
++@@ -111,7 +120,7 @@ public class Command extends AbstractNode
++ 	public StringBuilder prettyPrint(StringBuilder sb)
++ 	{
++ 		for(Update u : getUpdateList())
++-			sb.append(u.toString() + "\n");
+++			sb.append(u.toString() + " ");
++ 		sb.append(last.toString());
++ 		return sb;
++ 	}
++diff --git a/src/main/java/ast/Condition.java b/src/main/java/ast/Condition.java
++index 3cf5e2b..92853be 100644
++--- a/src/main/java/ast/Condition.java
+++++ b/src/main/java/ast/Condition.java
++@@ -1,10 +1,12 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** An interface representing a Boolean condition in a critter program. */
++ public interface Condition extends Node
++ {
++-	/** Returns the boolean value of this condition. */
++-	public boolean evaluate(); // to be done in A5
+++	/** Accepts an evaluation from an Interpreter. */
+++	public boolean acceptEvaluation(Interpreter i);
++ 	
++ 	/** Returns a deep copy of this condition. */
++ 	public Condition clone();
++diff --git a/src/main/java/ast/Expr.java b/src/main/java/ast/Expr.java
++index f6de6df..a535510 100644
++--- a/src/main/java/ast/Expr.java
+++++ b/src/main/java/ast/Expr.java
++@@ -1,10 +1,12 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** A critter program expression that has an integer value. */
++ public interface Expr extends Node
++ {
++-	/** Returns the integer value of this expression. */
++-	public int evaluate(); // to be done in A5
+++	/** Accepts an evaluation from Interpreter i. */
+++	public int acceptEvaluation(Interpreter i);
++ 	
++ 	/** Returns a deep copy of this expression. */
++ 	public Expr clone();
++diff --git a/src/main/java/ast/MutationTransform.java b/src/main/java/ast/MutationTransform.java
++index 72282ee..ea98f5f 100644
++--- a/src/main/java/ast/MutationTransform.java
+++++ b/src/main/java/ast/MutationTransform.java
++@@ -34,7 +34,7 @@ public class MutationTransform extends AbstractMutation
++ 			op = BinaryCondition.Operator.OR;
++ 			break;
++ 		}
++-		c.setOperator(op);
+++		c.setOp(op);
++ 		if(printMutationDetail)
++ 			System.out.println("Transformed the Condition node\n" + c + "\n");
++ 		return true;
++diff --git a/src/main/java/ast/Program.java b/src/main/java/ast/Program.java
++index 31eba98..8a93f6f 100644
++--- a/src/main/java/ast/Program.java
+++++ b/src/main/java/ast/Program.java
++@@ -1,8 +1,13 @@
++ package ast;
++ 
+++import java.util.LinkedList;
+++
++ /** An abstraction of a critter program. */
++ public interface Program extends Node
++ {
+++	/** Returns the list of rules contained in this program node. */
+++	public LinkedList<Rule> getRulesList();
+++	
++ 	/**
++ 	 * Mutates this program with a single mutation
++ 	 * @return The root of the mutated AST
++diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
++index aa17e31..73c14b8 100644
++--- a/src/main/java/ast/ProgramImpl.java
+++++ b/src/main/java/ast/ProgramImpl.java
++@@ -16,6 +16,7 @@ public class ProgramImpl extends AbstractNode implements Program
++ 			r.setParent(this);
++ 	}
++ 	
+++	@Override
++ 	public LinkedList<Rule> getRulesList()
++ 	{
++ 		return RulesList;
++@@ -100,22 +101,22 @@ public class ProgramImpl extends AbstractNode implements Program
++ 			switch(rand)
++ 			{
++ 				case 0:
++-					m = MutationFactory.getRemove(true);
+++					m = MutationFactory.getRemove(false);
++ 					break;
++ 				case 1:
++-					m = MutationFactory.getSwap(true);
+++					m = MutationFactory.getSwap(false);
++ 					break;
++ 				case 2:
++-					m = MutationFactory.getReplace(true);
+++					m = MutationFactory.getReplace(false);
++ 					break;
++ 				case 3:
++-					m = MutationFactory.getTransform(true);
+++					m = MutationFactory.getTransform(false);
++ 					break;
++ 				case 4:
++-					m = MutationFactory.getInsert(true);
+++					m = MutationFactory.getInsert(false);
++ 					break;
++ 				case 5:
++-					m = MutationFactory.getDuplicate(true);
+++					m = MutationFactory.getDuplicate(false);
++ 					break;
++ 			}
++ 			valid = mutate(randIndex, m);
++diff --git a/src/main/java/ast/Relation.java b/src/main/java/ast/Relation.java
++index 150361b..e1f3fe4 100644
++--- a/src/main/java/ast/Relation.java
+++++ b/src/main/java/ast/Relation.java
++@@ -1,5 +1,7 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** A representation of a relational comparison between two numerical expressions. */
++ public class Relation extends AbstractNode implements Condition
++ {
++@@ -9,10 +11,10 @@ public class Relation extends AbstractNode implements Condition
++ 	private RelOp op;
++ 	/** The right child of this node. */
++ 	private Expr right;
++-	
+++	/** The condition contained in this relation, if there is one. */
++ 	private Condition cond;
++ 	
++-	/** Creates a relational comparison between two numerical expressions, representing l o r.*/
+++	/** Creates a relational comparison between two numerical expressions, representing l op r.*/
++ 	public Relation(Expr l, RelOp o, Expr r)
++ 	{
++ 		this.left = l;
++@@ -35,32 +37,62 @@ public class Relation extends AbstractNode implements Condition
++ 		cond.setParent(this);
++ 	}
++ 
+++	/** 
+++	 * Returns the left child of this relation. 
+++	 * Precondition: {@code this.op != ISCOND}
+++	 */
++ 	public Expr getLeft()
++ 	{
++ 		return left;
++ 	}
+++	
+++	/** Sets the value of {@code left} to {@code newLeft}. */
++ 	public void setLeft(Expr newLeft)
++ 	{
++ 		left = newLeft;
++ 		left.setParent(this);
++ 	}
+++	
+++	/** 
+++	 * Returns the right child of this relation. 
+++	 * Precondition: {@code this.op != ISCOND}
+++	 */
++ 	public Expr getRight()
++ 	{
++ 		return right;
++ 	}
+++	
+++	/** Sets the value of {@code right} to {@code newRight}. */
++ 	public void setRight(Expr newRight)
++ 	{
++ 		right = newRight;
++ 		right.setParent(this);
++ 	}
+++	
+++	/** Returns a boolean based on whether or not this relation node contains a condition. */
++ 	public boolean isCond()
++ 	{
++ 		return op == RelOp.ISCOND;
++ 	}
++ 	
+++	/**
+++	 * Returns the condition this relation contains.
+++	 * Precondition: {@code this.op == ISCOND}
+++	 */
+++	public Condition getCond()
+++	{
+++		return cond;
+++	}
+++	
+++	/** Returns the type of this Relation. */
+++	public RelOp getRelOp()
+++	{
+++		return op;
+++	}
+++	/** Sets the value of {@code op} to {@code ro}, if {@code op} is not equal to ISCOND. */
++ 	public void setRelOp(RelOp ro)
++ 	{
++-		if (this.op.equals(RelOp.ISCOND))
+++		if (isCond())
++ 			return;
++ 		if (ro.equals(RelOp.ISCOND))
++ 		{
++@@ -80,7 +112,7 @@ public class Relation extends AbstractNode implements Condition
++ 	@Override
++ 	public int size()
++ 	{
++-		if(op == RelOp.ISCOND)
+++		if(isCond())
++ 			return 1 + cond.size();
++ 		return 1 + left.size() + right.size();
++ 	}
++@@ -92,7 +124,7 @@ public class Relation extends AbstractNode implements Condition
++ 			return this;
++ 		if(index > size() - 1 || index < 0)
++ 			throw new IndexOutOfBoundsException();
++-		if(op == RelOp.ISCOND)
+++		if(isCond())
++ 			return cond.nodeAt(index - 1);
++ 		else
++ 		{
++@@ -106,7 +138,7 @@ public class Relation extends AbstractNode implements Condition
++ 	@Override
++ 	public Relation clone()
++ 	{
++-		if(op == RelOp.ISCOND)
+++		if(isCond())
++ 			return new Relation(cond.clone());
++ 		Expr tempLeft = left.clone();
++ 		Expr tempRight = right.clone();
++@@ -122,7 +154,7 @@ public class Relation extends AbstractNode implements Condition
++ 	@Override
++ 	public boolean replaceChild(Node child, Node replacement)
++ 	{
++-		if(op == RelOp.ISCOND)
+++		if(isCond())
++ 		{
++ 			if(child == this.cond)
++ 			{
++@@ -183,9 +215,9 @@ public class Relation extends AbstractNode implements Condition
++ 		return sb;
++ 	}
++ 	@Override
++-	public boolean evaluate()
+++	public boolean acceptEvaluation(Interpreter i)
++ 	{
++-		throw new UnsupportedOperationException();
+++		return i.eval(this);
++ 	}
++ 	/** An enumeration of all the accepted mathematical relational operators. */
++ 	public enum RelOp
++diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
++index e8c6fb9..3275487 100644
++--- a/src/main/java/ast/Rule.java
+++++ b/src/main/java/ast/Rule.java
++@@ -17,6 +17,18 @@ public class Rule extends AbstractNode
++ 		comm.setParent(this);
++ 	}
++ 	
+++	/** Returns the condition of this rule. */
+++	public Condition getCond()
+++	{
+++		return cond;
+++	}
+++	
+++	/** Returns the command of this rule. */
+++	public Command getComm()
+++	{
+++		return comm;
+++	}
+++	
++ 	@Override
++ 	public int size()
++ 	{
++diff --git a/src/main/java/ast/Sensor.java b/src/main/java/ast/Sensor.java
++index f56656b..0769b29 100644
++--- a/src/main/java/ast/Sensor.java
+++++ b/src/main/java/ast/Sensor.java
++@@ -1,12 +1,14 @@
++ package ast;
++ 
++ import java.util.Random;
+++import interpret.Interpreter;
++ 
++ /** An AST representation of a Sensor node. */
++ public class Sensor extends AbstractNode implements Expr
++ {
++ 	/** The type of this Sensor node. */
++ 	private SensorType type;
+++	/** The sensor index of this node. Not compatible with SensorType SMELL. */
++ 	private Expr sensorIndex;
++ 	
++ 	/** Creates a new Sensor node with the specified type and index. Not compatible with SensorType SMELL. */
++@@ -24,6 +26,21 @@ public class Sensor extends AbstractNode implements Expr
++ 		sensorIndex = null;
++ 	}
++ 	
+++	/** Returns the type of this sensor. */
+++	public SensorType getSensorType()
+++	{
+++		return type;
+++	}
+++	
+++	/** 
+++	 * Returns the sensor index of this sensor, if there is one.
+++	 * Precondition: this sensor is not of type SMELL.
+++	 */
+++	public Expr getSensorIndex()
+++	{
+++		return sensorIndex;
+++	}
+++	
++ 	/** Sets the SensorType of this sensor node. */
++ 	public void setSensorType(SensorType st)
++ 	{
++@@ -111,9 +128,9 @@ public class Sensor extends AbstractNode implements Expr
++ 	}
++ 	
++ 	@Override
++-	public int evaluate()
+++	public int acceptEvaluation(Interpreter i)
++ 	{
++-		throw new UnsupportedOperationException();
+++		return i.eval(this);
++ 	}
++ 	
++ 	/** An enumeration of all the possible Sensor types. */
++diff --git a/src/main/java/ast/Test.java b/src/main/java/ast/Test.java
++deleted file mode 100644
++index b77889d..0000000
++--- a/src/main/java/ast/Test.java
+++++ /dev/null
++@@ -1,80 +0,0 @@
++-package ast;
++-
++-import java.io.BufferedReader;
++-import java.io.InputStream;
++-import java.io.InputStreamReader;
++-import java.io.Reader;
++-import java.util.LinkedList;
++-
++-import ast.BinaryExpr;
++-import ast.BinaryCondition.Operator;
++-import ast.BinaryExpr.MathOp;
++-import ast.Relation.RelOp;
++-import ast.UnaryExpr.ExprType;
++-import parse.Parser;
++-import parse.ParserFactory;
++-import parse.Tokenizer;
++-import parsertests.ParserTest;
++-
++-public class Test
++-{
++-	public static void main(String[] args)
++-	{
++-		/*UnaryExpr e1 = new UnaryExpr(2);
++-		UnaryExpr e2 = new UnaryExpr(12);
++-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
++-		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION);
++-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++-		Relation r = new Relation(e4, RelOp.EQUAL, e5);
++-		
++-		System.out.println(r.toString());
++-		System.out.println(r.size());*/
++-		
++-		/*UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
++-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++-		UnaryExpr e1 = new UnaryExpr(2);
++-		UnaryExpr e2 = new UnaryExpr(12);
++-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
++-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
++-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
++-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
++-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		ll.add(u2);
++-		ll.add(u3);
++-		ll.add(u4);
++-		Command c = new Command(ll, u);
++-		Rule rule = new Rule(con, c);
++-		
++-		System.out.println(rule.toString() + "\n" + rule.size() + "\n" + rule.nodeAt(13));
++-		System.out.println("" + rule.size() + "\n" + con.size() + "\n" + c.size());*/
++-		
++-		/*Sensor s = new Sensor();
++-		System.out.println(s.nodeAt(0).toString());*/
++-		
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++-        Reader r = new BufferedReader(new InputStreamReader(in));
++-        Tokenizer t = new Tokenizer(r);
++-        Parser p = ParserFactory.getParser();
++-        Program prog = p.parse(r);
++-        System.out.println(prog.toString());
++-        
++-        Program pclone = (Program) prog.clone();
++-        System.out.println(pclone.toString());
++-        pclone = null;
++-        System.out.println(prog.toString());
++-        
++-		
++-		/*Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		System.out.println(u.size() + "\n" + u.nodeAt(0) + "\nmem[" + u.nodeAt(1) + "] := " + u.nodeAt(2));
++-		UnaryExpr e1 = new UnaryExpr(new UnaryExpr(5), ExprType.NEGATION);
++-		System.out.println(e1.size() + "\n" + e1.nodeAt(1));
++-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++-		System.out.println(e5.size() + "\n" + e5.nodeAt(0));*/
++-		
++-		
++-	}
++-}
++diff --git a/src/main/java/ast/TestMutations.java b/src/main/java/ast/TestMutations.java
++deleted file mode 100644
++index 74fdb33..0000000
++--- a/src/main/java/ast/TestMutations.java
+++++ /dev/null
++@@ -1,103 +0,0 @@
++-package ast;
++-
++-import java.io.BufferedReader;
++-import java.io.InputStream;
++-import java.io.InputStreamReader;
++-import java.io.Reader;
++-import java.util.LinkedList;
++-
++-import ast.BinaryCondition.Operator;
++-import ast.BinaryExpr.MathOp;
++-import ast.Relation.RelOp;
++-import ast.UnaryExpr.ExprType;
++-import parse.Parser;
++-import parse.ParserFactory;
++-import parse.Tokenizer;
++-import parsertests.ParserTest;
++-
++-public class TestMutations
++-{
++-	public static void main(String[] args)
++-	{
++-		/*
++-		UnaryExpr e = new UnaryExpr(5);
++-		
++-		BinaryExpr be = new BinaryExpr(e, MathOp.DIVIDE, new UnaryExpr(7));
++-		System.out.println(be.toString());
++-		be.acceptMutation(new MutationSwap());
++-		System.out.println(be.toString());
++-		System.out.println(be.toString());
++-		be.acceptMutation(new MutationSwap());
++-		System.out.println(be.toString());
++-		
++-		Update u = new Update(new UnaryExpr(2), new UnaryExpr(9));
++-		System.out.println(u.toString());
++-		u.acceptMutation(new MutationSwap());
++-		System.out.println(u.toString());
++-		
++-		System.out.println(u.getClass().getSimpleName());
++-		System.out.println(be.getClass().getSimpleName());*/
++-		
++-		
++-		
++-		//System.out.println(e.getParent().toString());
++-		
++-		/*Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
++-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
++-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
++-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
++-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
++-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++-		UnaryExpr e1 = new UnaryExpr(2);
++-		UnaryExpr e2 = new UnaryExpr(12);
++-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
++-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
++-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
++-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
++-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
++-		Command c = new Command(ll, u6);
++-		Rule r = new Rule(con, c);
++-		System.out.println(c.toString() + "\n");
++-		c.acceptMutation(new MutationSwap());
++-		System.out.println(c.toString() + "\n");
++-		
++-		//u6.acceptMutation(new MutationRemove());
++-		//System.out.println(c.toString());
++-		
++-		c.acceptMutation(new MutationDuplicate());
++-		System.out.println(c.toString());*/
++-		
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++-        Reader r = new BufferedReader(new InputStreamReader(in));
++-        Tokenizer t = new Tokenizer(r);
++-        Parser p = ParserFactory.getParser();
++-        Program prog = p.parse(r);
++-        
++-        System.out.println(prog.mutate());
++-        
++-        //for(int i = 0; i < prog.size(); i++)
++-			//try
++-			{
++-			//	System.out.println("Index #" + i + ": " + prog.nodeAt(i));
++-			}
++-			//catch (IndexOutOfBoundsException e)
++-			{
++-				//System.out.println("NODEAT FAILED");
++-			}
++-        
++-        //int n = (int) (Math.random() * (prog.size() - 1));
++-        //for(int i = 0; i < prog.size(); i++)
++-			//try
++-			//{
++-				//System.out.println(prog.mutate(n, new MutationInsert()).toString());
++-			//}
++-			//catch (NullPointerException e)
++-			//{
++-				//System.out.println("Incompatible node type");
++-			//}
++-		
++-	}
++-}
++\ No newline at end of file
++diff --git a/src/main/java/ast/UnaryExpr.java b/src/main/java/ast/UnaryExpr.java
++index a749244..8493bca 100644
++--- a/src/main/java/ast/UnaryExpr.java
+++++ b/src/main/java/ast/UnaryExpr.java
++@@ -1,5 +1,7 @@
++ package ast;
++ 
+++import interpret.Interpreter;
+++
++ /** A representation of a unary numerical expression that evaluates to an integer. */
++ public class UnaryExpr extends AbstractNode implements Expr
++ {
++@@ -7,6 +9,7 @@ public class UnaryExpr extends AbstractNode implements Expr
++ 	private ExprType type;
++ 	/** The subexpression that this unary expression is based off of. May be null. */
++ 	private Expr exp;
+++	/** The integer value contained in this unary expression, if it has one. Only applies to expressions of type CONSTANT. */
++ 	private int value;
++ 	
++ 	/** 
++@@ -32,6 +35,32 @@ public class UnaryExpr extends AbstractNode implements Expr
++ 		this.type = ExprType.CONSTANT;
++ 	}
++ 	
+++	/** Returns the type of this unary expression. */
+++	public ExprType getExprType()
+++	{
+++		return type;
+++	}
+++	
+++	/**
+++	 * Returns the integer value contained in this unary expression.
+++	 * Precondition: the type of this expression must be CONSTANT.
+++	 */
+++	public int getValue()
+++	{
+++		return value;
+++	}
+++	/** Sets the value of {@code value} to {@code val}. */
+++	public void setValue(int val)
+++	{
+++		this.exp = null;
+++		this.value = val;
+++		this.type = ExprType.CONSTANT;
+++	}
+++	
+++	public Expr getExp()
+++	{
+++		return exp;
+++	}
++ 	@Override
++ 	public int size()
++ 	{
++@@ -101,24 +130,20 @@ public class UnaryExpr extends AbstractNode implements Expr
++ 			case NEGATION:
++ 				sb.append("-" + exp.toString());
++ 				break;
++-			case SENSORVAL:
++-				//if this UnaryExpr has the type of SENSORVAL, then the class type of exp should be Sensor
++-				sb.append(exp.toString());
++-				break;
++ 		}
++ 		return sb;
++ 	}
++ 	
++ 	@Override
++-	public int evaluate()
+++	public int acceptEvaluation(Interpreter i)
++ 	{
++-		throw new UnsupportedOperationException();
+++		return i.eval(this);
++ 	}
++ 	
++ 	/** An enumeration of all the possible unary expression types. */
++ 	public enum ExprType
++ 	{
++-		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION, SENSORVAL;
+++		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION;
++ 	}
++ 
++ 	@Override
++@@ -126,10 +151,4 @@ public class UnaryExpr extends AbstractNode implements Expr
++ 	{
++ 		return NodeType.UNARYEXPR;
++ 	}
++-	
++-	public void setValue(int value) {
++-		this.exp = null;
++-		this.value = value;
++-		this.type = ExprType.CONSTANT;
++-	}
++ }
++\ No newline at end of file
++diff --git a/src/main/java/ast/Update.java b/src/main/java/ast/Update.java
++index a47ebfa..141a459 100644
++--- a/src/main/java/ast/Update.java
+++++ b/src/main/java/ast/Update.java
++@@ -22,18 +22,25 @@ public class Update extends AbstractNode implements CommandComponent
++ 		value.setParent(this);
++ 	}
++ 	
+++	/** Returns the memory index of this update. */
++ 	public Expr getMemIndex()
++ 	{
++ 		return memIndex;
++ 	}
+++	
+++	/** Sets the value of {@code memIndex} to {@code newIndex}. */
++ 	public void setMemIndex(Expr newIndex)
++ 	{
++ 		this.memIndex = newIndex;
++ 	}
+++	
+++	/** Returns the new value to be set for this update. */
++ 	public Expr getValue()
++ 	{
++ 		return value;
++ 	}
+++	
+++	/** Sets the value of {@code value} to {@code newVal}. */
++ 	public void setValue(Expr newVal)
++ 	{
++ 		this.value = newVal;
++diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
++index 89f4bec..ca92071 100644
++--- a/src/main/java/console/Console.java
+++++ b/src/main/java/console/Console.java
++@@ -1,222 +1,311 @@
++ package console;
++ 
++-import java.io.InputStream;
++-import java.io.PrintStream;
+++import java.io.*;
++ import java.util.Scanner;
++ 
++-/**
++- * The console user interface for Assignment 5.
++- */
++-public class Console {
++-    private Scanner scan;
++-    public boolean done;
++-    public PrintStream out;
++-
++-    /* =========================== */
++-    /* DO NOT EDIT ABOVE THIS LINE */
++-    /* (except imports...)         */
++-    /* =========================== */
++-
++-    //TODO world representation...
++-
++-    /**
++-     * Starts new random world simulation.
++-     */
++-    public void newWorld() {
++-        //TODO implement
++-    }
++-
++-    /**
++-     * Starts new simulation with world specified in filename.
++-     *
++-     * @param filename
++-     */
++-    public void loadWorld(String filename) {
++-        //TODO implement
++-    }
++-
++-    /**
++-     * Loads critter definition from filename and randomly places
++-     * n critters with that definition into the world.
++-     *
++-     * @param filename
++-     * @param n
++-     */
++-    public void loadCritters(String filename, int n) {
++-        //TODO implement
++-    }
++-
++-    /**
++-     * Advances the world by n time steps.
++-     *
++-     * @param n
++-     */
++-    public void advanceTime(int n) {
++-        //TODO implement
++-    }
++-
++-    /**
++-     * Prints current time step, number of critters, and world
++-     * map of the simulation.
++-     */
++-    public void worldInfo() {
++-        //TODO implement
++-        worldInfo(0, 0);
++-    }
++-
++-    /**
++-     * Prints description of the contents of hex (c,r).
++-     *
++-     * @param c column of hex
++-     * @param r row of hex
++-     */
++-    public void hexInfo(int c, int r) {
++-        //TODO implement and call appropriate method
++-
++-        critterInfo(null, null, null, null);
++-        // OR
++-//        terrainInfo(0);
++-    }
++-
++-    /* =========================== */
++-    /* DO NOT EDIT BELOW THIS LINE */
++-    /* =========================== */
++-
++-    /**
++-     * Be sure to call this function, we will override it to grade.
++-     *
++-     * @param numSteps      The number of steps that have passed in the world.
++-     * @param crittersAlive The number of critters currently alive.
++-     */
++-    protected void worldInfo(int numSteps, int crittersAlive) {
++-        out.println("steps: " + numSteps);
++-        out.println("critters: " + crittersAlive);
++-    }
++-
++-    /**
++-     * Be sure to call this function, we will override it to grade.
++-     *
++-     * @param species  The species of the critter.
++-     * @param mem      The memory of the critter.
++-     * @param program  The program of the critter pretty printed as a String. This should be able to be parsed back to
++-     *                 the same AST.
++-     * @param lastrule The last rule executed by the critter pretty printed as a String. This should be able to be
++-     *                 parsed back to the same AST. If no rule has been executed, this parameter should be null.
++-     */
++-    protected void critterInfo(String species, int[] mem, String program, String lastrule) {
++-        out.println("Species: " + species);
++-        StringBuilder sbmem = new StringBuilder();
++-        for (int i : mem) {
++-            sbmem.append(" ").append(i);
++-        }
++-        out.println("Memory:" + sbmem.toString());
++-        out.println("Program: " + program);
++-        out.println("Last rule: " + lastrule);
++-    }
++-
++-    /**
++-     * Be sure to call this function, we will override it to grade.
++-     *
++-     * @param terrain 0 is empty, -1 is rock, -X is (X-1) food
++-     */
++-    protected void terrainInfo(int terrain) {
++-        if (terrain == 0) {
++-            out.println("Empty");
++-        } else if (terrain == -1) {
++-            out.println("Rock");
++-        } else {
++-            out.println("Food: " + (-terrain - 1));
++-        }
++-    }
++-
++-    /**
++-     * Prints a list of possible commands to the standard output.
++-     */
++-    public void printHelp() {
++-        out.println("new: start a new simulation with a random world");
++-        out.println("load <world_file>: start a new simulation with "
++-                + "the world loaded from world_file");
++-        out.println("critters <critter_file> <n>: add n critters "
++-                + "defined by critter_file randomly into the world");
++-        out.println("step <n>: advance the world by n timesteps");
++-        out.println("info: print current timestep, number of critters "
++-                + "living, and map of world");
++-        out.println("hex <c> <r>: print contents of hex "
++-                + "at column c, row r");
++-        out.println("exit: exit the program");
++-    }
++-
++-    /**
++-     * Constructs a new Console capable of reading a given input.
++-     */
++-    public Console(InputStream in, PrintStream out) {
++-        this.out = out;
++-        scan = new Scanner(in);
++-        done = false;
++-    }
++-
++-    /**
++-     * Constructs a new Console capable of reading the standard input.
++-     */
++-    public Console() {
++-        this(System.in, System.out);
++-    }
++-
++-    /**
++-     * Processes a single console command provided by the user.
++-     */
++-    public void handleCommand() {
++-        out.print("Enter a command or \"help\" for a list of commands.\n> ");
++-        String command = scan.next();
++-        switch (command) {
++-            case "new": {
++-                newWorld();
++-                break;
++-            }
++-            case "load": {
++-                String filename = scan.next();
++-                loadWorld(filename);
++-                break;
++-            }
++-            case "critters": {
++-                String filename = scan.next();
++-                int n = scan.nextInt();
++-                loadCritters(filename, n);
++-                break;
++-            }
++-            case "step": {
++-                int n = scan.nextInt();
++-                advanceTime(n);
++-                break;
++-            }
++-            case "info": {
++-                worldInfo();
++-                break;
++-            }
++-            case "hex": {
++-                int c = scan.nextInt();
++-                int r = scan.nextInt();
++-                hexInfo(c, r);
++-                break;
++-            }
++-            case "help": {
++-                printHelp();
++-                break;
++-            }
++-            case "exit": {
++-                done = true;
++-                break;
++-            }
++-            default:
++-                out.println(command + " is not a valid command.");
++-        }
++-    }
++-
++-    public static void main(String[] args) {
++-        Console console = new Console();
++-        while (!console.done) {
++-            console.handleCommand();
++-        }
++-    }
+++import simulation.SimpleCritter;
+++import simulation.SimpleWorld;
+++import simulation.World;
+++
+++/** The console user interface for Assignment 5. */
+++public class Console
+++{
+++	private Scanner scan;
+++	public boolean done;
+++	public PrintStream out;
+++
+++	/* =========================== */
+++	/* DO NOT EDIT ABOVE THIS LINE */
+++	/* (except imports...) */
+++	/* =========================== */
+++
+++	// TODO world representation...
+++	private SimpleWorld world;
+++
+++	/** Starts new random world simulation. */
+++	public void newWorld()
+++	{
+++		try
+++		{
+++			world = new World();
+++		}
+++		catch (IllegalArgumentException i)
+++		{
+++			System.err.println("The constants.txt file could not be read. Please check if it exists or is formatted properly.");
+++		}
+++	}
+++
+++	/**
+++	 * Starts new simulation with world specified in filename.
+++	 * @param filename
+++	 */
+++	public void loadWorld(String filename)
+++	{
+++		try
+++		{
+++			world = new World(filename);
+++		}
+++		catch (FileNotFoundException f)
+++		{
+++			System.err.println("World file not found. Loading defaultly generated world...");
+++			world = new World();
+++		}
+++		catch (IllegalArgumentException i)
+++		{
+++			System.err.println("The constants.txt file could not be read. Please check if it is formatted properly.");
+++			System.exit(0);
+++		}
+++	}
+++
+++	/**
+++	 * Loads critter definition from {@code filename} and randomly places n critters with that definition into the world.
+++	 * If the file cannot be found, this method prints an error message and loads 0 critters. If the file contains invalid
+++	 * attributes, critters are supplied with default memory values. A full list of default critter memory values can be
+++	 * found in our overview document.
+++	 *
+++	 * @param filename
+++	 * @param n
+++	 */
+++	public void loadCritters(String filename, int n)
+++	{
+++		//This method can't do anything if no world has been created yet.
+++		if(world == null)
+++		{
+++			System.err.println("You must first create a world before you load critters into it.");
+++			printHelp();
+++			return;
+++		}
+++		
+++		world.loadCritters(filename, n, -1);
+++	}
+++
+++	/**
+++	 * Advances the world by n time steps.
+++	 * @param n
+++	 */
+++	public void advanceTime(int n)
+++	{
+++		//This method can't do anything if no world has been created yet.
+++		if(world == null)
+++		{
+++			System.err.println("You must first create a world before you advance time in it.");
+++			printHelp();
+++			return;
+++		}
+++		for(int i = 0; i < n; i++)
+++			world.advanceOneTimeStep();
+++	}
+++
+++	/** Prints current time step, number of critters, and world map of the simulation. */
+++	public void worldInfo()
+++	{
+++		//This method can't do anything if no world has been created yet.
+++		if(world == null)
+++		{
+++			System.err.println("You must first create a world before you can view its information.");
+++			printHelp();
+++			return;
+++		}
+++		
+++		out.println(world.printGrid().toString());
+++		worldInfo(world.getTimePassed(), crittersAlive());
+++	}
+++
+++	/** Returns the number of critters still alive. Useful for testing purposes. */
+++	public int crittersAlive()
+++	{
+++		if(world == null)
+++			return Integer.MIN_VALUE;
+++		return world.numRemainingCritters();
+++	}
+++	
+++	/**
+++	 * Prints description of the contents of hex (c,r).
+++	 *
+++	 * @param c column of hex
+++	 * @param r row of hex
+++	 */
+++	public void hexInfo(int c, int r)
+++	{
+++		//This method can't do anything if no world has been created yet.
+++		if(world == null)
+++		{
+++			System.err.println("You must first create a world before you can view its information.");
+++			printHelp();
+++			return;
+++		}
+++		
+++		if(!world.isValidHex(c, r))
+++		{
+++			System.err.println("Invalid world coordinates.");
+++			return;
+++		}
+++		
+++		SimpleCritter sc;
+++		int hexAnalysis = world.analyzeHex(c, r);
+++		if(hexAnalysis <= 0)
+++			terrainInfo(hexAnalysis);
+++		
+++		sc = world.analyzeCritter(c, r);
+++		if(sc == null)
+++			return;
+++		
+++		critterInfo(sc.getName(), sc.getMemoryCopy(), sc.getProgram().toString(), sc.getLastRule());
+++	}
+++
+++	/* =========================== */
+++	/* DO NOT EDIT BELOW THIS LINE */
+++	/* =========================== */
+++
+++	/**
+++	 * Be sure to call this function, we will override it to grade.
+++	 *
+++	 * @param numSteps
+++	 *            The number of steps that have passed in the world.
+++	 * @param crittersAlive
+++	 *            The number of critters currently alive.
+++	 */
+++	protected void worldInfo(int numSteps, int crittersAlive)
+++	{
+++		out.println("steps: " + numSteps);
+++		out.println("critters: " + crittersAlive);
+++	}
+++
+++	/**
+++	 * Be sure to call this function, we will override it to grade.
+++	 *
+++	 * @param species
+++	 *            The species of the critter.
+++	 * @param mem
+++	 *            The memory of the critter.
+++	 * @param program
+++	 *            The program of the critter pretty printed as a String. This should
+++	 *            be able to be parsed back to the same AST.
+++	 * @param lastrule
+++	 *            The last rule executed by the critter pretty printed as a String.
+++	 *            This should be able to be parsed back to the same AST. If no rule
+++	 *            has been executed, this parameter should be null.
+++	 */
+++	protected void critterInfo(String species, int[] mem, String program, String lastrule)
+++	{
+++		out.println("Species: " + species);
+++		StringBuilder sbmem = new StringBuilder();
+++		for (int i : mem)
+++		{
+++			sbmem.append(" ").append(i);
+++		}
+++		out.println("Memory:" + sbmem.toString());
+++		out.println("Program: " + program);
+++		out.println("Last rule: " + lastrule);
+++	}
+++
+++	/**
+++	 * Be sure to call this function, we will override it to grade.
+++	 *
+++	 * @param terrain
+++	 *            0 is empty, -1 is rock, -X is (X-1) food
+++	 */
+++	protected void terrainInfo(int terrain)
+++	{
+++		if (terrain == 0)
+++			out.println("Empty");
+++		else if (terrain == -1)
+++			out.println("Rock");
+++		else
+++			out.println("Food: " + (-terrain - 1));
+++	}
+++
+++	/** Prints a list of possible commands to the standard output. */
+++	public void printHelp()
+++	{
+++		out.println("new: start a new simulation with a random world");
+++		out.println("load <world_file>: start a new simulation with " + "the world loaded from world_file");
+++		out.println("critters <critter_file> <n>: add n critters " + "defined by critter_file randomly into the world");
+++		out.println("step <n>: advance the world by n timesteps");
+++		out.println("info: print current timestep, number of critters " + "living, and map of world");
+++		out.println("hex <c> <r>: print contents of hex " + "at column c, row r");
+++		out.println("exit: exit the program");
+++	}
+++
+++	/** Constructs a new Console capable of reading a given input. */
+++	public Console(InputStream in, PrintStream out)
+++	{
+++		this.out = out;
+++		scan = new Scanner(in);
+++		done = false;
+++	}
+++
+++	/** Constructs a new Console capable of reading the standard input. */
+++	public Console()
+++	{
+++		this(System.in, System.out);
+++	}
+++
+++	/** Processes a single console command provided by the user. */
+++	public void handleCommand()
+++	{
+++		out.print("Enter a command or \"help\" for a list of commands.\n> ");
+++		String command = scan.next();
+++		switch (command)
+++		{
+++			case "new":
+++			{
+++				newWorld();
+++				break;
+++			}
+++			case "load":
+++			{
+++				String filename = scan.next();
+++				loadWorld(filename);
+++				break;
+++			}
+++			case "critters":
+++			{
+++				String filename = scan.next();
+++				int n = scan.nextInt();
+++				loadCritters(filename, n);
+++				break;
+++			}
+++			case "step":
+++			{
+++				int n = scan.nextInt();
+++				advanceTime(n);
+++				break;
+++			}
+++			case "info":
+++			{
+++				worldInfo();
+++				break;
+++			}
+++			case "hex":
+++			{
+++				int c = scan.nextInt();
+++				int r = scan.nextInt();
+++				hexInfo(c, r);
+++				break;
+++			}
+++			case "help":
+++			{
+++				printHelp();
+++				break;
+++			}
+++			case "exit":
+++			{
+++				done = true;
+++				break;
+++			}
+++			default:
+++				out.println(command + " is not a valid command.");
+++		}
+++	}
+++
+++	public static void main(String[] args)
+++	{
+++		Console console = new Console();
+++		while (!console.done)
+++		{
+++			console.handleCommand();
+++		}
+++	}
++ 
++ }
++diff --git a/src/main/java/interpret/Interpreter.java b/src/main/java/interpret/Interpreter.java
++index e205039..1a57929 100644
++--- a/src/main/java/interpret/Interpreter.java
+++++ b/src/main/java/interpret/Interpreter.java
++@@ -1,36 +1,52 @@
++ package interpret;
++ 
++-import ast.Condition;
++-import ast.Expr;
++-import ast.Program;
+++import ast.BinaryCondition;
+++import ast.Relation;
+++import ast.BinaryExpr;
+++import ast.UnaryExpr;
+++import ast.Sensor;
++ 
++ /**
++  * An example interface for interpreting a critter program. This is just a starting
++  * point and may be changed as much as you like.
++  */
++-public interface Interpreter {
+++public interface Interpreter
+++{
+++	/** Executes the results of one critter turn. */
+++	public void simulateCritterTurn();
+++
++     /**
++-     * Execute program {@code p} until either the maximum number of rules per
++-     * turn is reached or some rule whose command contains an action is
++-     * executed.
++-     * @param p
++-     * @return a result containing the action to be performed;
++-     * the action may be null if the maximum number of rules
++-     * per turn was exceeded.
+++     * Evaluates the given binary condition.
+++     * @param c
+++     * @return a boolean that results from evaluating c.
++      */
++-    Outcome interpret(Program p);
++-
+++    boolean eval(BinaryCondition c);
+++    
++     /**
++-     * Evaluate the given condition.
+++     * Evaluates the given relation.
++      * @param c
++      * @return a boolean that results from evaluating c.
++      */
++-    boolean eval(Condition c);
+++    boolean eval(Relation c);
++ 
++     /**
++-     * Evaluate the given expression.
+++     * Evaluates the given binary expression.
+++     * @param e
+++     * @return an integer that results from evaluating e.
+++     */
+++    int eval(BinaryExpr e);
+++    
+++    /**
+++     * Evaluates the given unary expression.
+++     * @param e
+++     * @return an integer that results from evaluating e.
+++     */
+++    int eval(UnaryExpr e);
+++    
+++    /**
+++     * Evaluates the given sensor.
++      * @param e
++      * @return an integer that results from evaluating e.
++      */
++-    int eval(Expr e);
+++    int eval(Sensor s);
++ }
++diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
++new file mode 100644
++index 0000000..18973a1
++--- /dev/null
+++++ b/src/main/java/interpret/InterpreterImpl.java
++@@ -0,0 +1,265 @@
+++package interpret;
+++
+++import ast.*;
+++import ast.Action.ActType;
+++import ast.Node.NodeType;
+++import simulation.AbstractWorld;
+++import simulation.SimpleCritter;
+++
+++import java.util.LinkedList;
+++
+++/** Interprets and executes the AST of a critter. */
+++public class InterpreterImpl implements Interpreter
+++{
+++	/** The critter whose AST this Interpreter interprets. */
+++	private SimpleCritter c;
+++	/** The world in which the critter inhabits. */
+++	private AbstractWorld world;
+++	
+++	/** Creates a new InterpreterImpl. */
+++	public InterpreterImpl(SimpleCritter cr, AbstractWorld aw)
+++	{
+++		c = cr;
+++		world = aw;
+++	}
+++	
+++	/** Executes the results of one critter turn. */
+++	public void simulateCritterTurn()
+++	{
+++		Action a = interpret(c.getProgram());
+++		executeAction(a);
+++	}
+++	
+++	/**
+++     * Execute program {@code p} until either the maximum number of rules per turn is reached or some rule
+++     * whose command contains an action is executed.
+++     * @param p
+++     * @return the action to be performed
+++     */
+++	private Action interpret(Program p)
+++	{
+++		LinkedList<Rule> rl = p.getRulesList();
+++		Action a = null;
+++		boolean actionInterpreted = false;
+++		while (!actionInterpreted && c.readMemory(5) < world.getMaxRules())
+++		{
+++			for (Rule r : rl)
+++			{
+++				boolean ruleCondition = r.getCond().acceptEvaluation(this);
+++				if(ruleCondition)
+++				{
+++					Command ruleCommand = r.getComm();
+++					for(Update u : ruleCommand.getUpdateList())
+++						applyUpdate(u);
+++					if(ruleCommand.getLast().getType() == NodeType.ACTION)
+++					{
+++						a = (Action) ruleCommand.getLast();
+++						actionInterpreted = true;
+++					}
+++					else
+++						applyUpdate((Update) ruleCommand.getLast());
+++					c.setLastRule(r.toString());
+++					break;
+++				}
+++			}
+++			c.incrementPass();
+++		}
+++		c.setMemory(0, 5);
+++		
+++		if(a == null)
+++			a = new Action(ActType.WAIT);
+++		return a;
+++	}
+++	
+++	/** Executes an action returned by the {@code interpret} method. */
+++	private void executeAction(Action a)
+++	{
+++		int val = 0;
+++		if(a.getVal() != null)
+++			val = a.getVal().acceptEvaluation(this);
+++		
+++		switch(a.getActType())
+++		{
+++			case FORWARD:
+++				world.moveCritter(c, true);
+++				break;
+++			case BACKWARD:
+++				world.moveCritter(c, false);
+++				break;
+++			case LEFT:
+++				world.turnCritter(c, false);
+++				break;
+++			case RIGHT:
+++				world.turnCritter(c, true);
+++				break;
+++			case EAT:
+++				world.critterEat(c);
+++				break;
+++			case ATTACK:
+++				world.critterBattle(c);
+++				break;
+++			case GROW:
+++				world.growCritter(c);
+++				break;
+++			case BUD:
+++				world.critterBud(c);
+++				break;
+++			case MATE:
+++				world.critterMate(c);
+++				break;
+++			case TAG:
+++				world.critterTag(c, val);
+++				break;
+++			case SERVE:
+++				world.critterServe(c, val);
+++				break;
+++			case WAIT:
+++				world.critterSoakEnergy(c);
+++				break;
+++		}
+++	}
+++	/** Applies the effects of a single update to a critter. */
+++	private void applyUpdate(Update u)
+++	{
+++		int index = u.getMemIndex().acceptEvaluation(this);
+++		int val = u.getValue().acceptEvaluation(this);
+++		c.setMemory(val, index);
+++	}
+++
+++	@Override
+++	public boolean eval(BinaryCondition c)
+++	{
+++		boolean result = false;
+++		boolean left = c.getLeft().acceptEvaluation(this);
+++		boolean right = c.getRight().acceptEvaluation(this);
+++		switch(c.getOp())
+++		{
+++			case AND:
+++				result = left && right;
+++				break;
+++			case OR:
+++				result = left || right;
+++				break;
+++		}
+++		return result;
+++	}
+++	
+++	@Override
+++	public boolean eval(Relation r)
+++	{
+++		boolean result = false;
+++		if(r.getCond() != null)
+++		{
+++			result = r.getCond().acceptEvaluation(this);
+++			return result;
+++		}
+++		int left = r.getLeft().acceptEvaluation(this);
+++		int right = r.getRight().acceptEvaluation(this);
+++		switch(r.getRelOp())
+++		{
+++			case LESS:
+++				result = left < right;
+++				break;
+++			case LESSOREQ:
+++				result = left <= right;
+++				break;
+++			case GREATER:
+++				result = left > right;
+++				break;
+++			case GREATEROREQ:
+++				result = left >= right;
+++				break;
+++			case EQUAL:
+++				result = left == right;
+++				break;
+++			case NOTEQUAL:
+++				result = left != right;
+++				break;
+++			case ISCOND:
+++				result = r.getCond().acceptEvaluation(this);
+++				break;
+++		}
+++		return result;
+++	}
+++	
+++	@Override
+++	public int eval(BinaryExpr e)
+++	{
+++		int result = 0;
+++		int left = e.getLeft().acceptEvaluation(this);
+++		int right = e.getRight().acceptEvaluation(this);
+++		switch(e.getOperator())
+++		{
+++			case ADD:
+++				result = left + right;
+++				break;
+++			case SUBTRACT:
+++				result = left - right;
+++				break;
+++			case MULTIPLY:
+++				result = left * right;
+++				break;
+++			case DIVIDE:
+++				if(right != 0)
+++					result = left / right;
+++				break;
+++			case MOD:
+++				if(right != 0)
+++					result = left % right;
+++				break;
+++		}
+++		return result;
+++	}
+++	
+++	@Override
+++	public int eval(UnaryExpr e)
+++	{
+++		int result = 0;
+++		switch(e.getExprType())
+++		{
+++			case CONSTANT:
+++				result = e.getValue();
+++				break;
+++			case MEMORYVAL:
+++				int index = e.getExp().acceptEvaluation(this);
+++				result = c.readMemory(index);
+++				if(result == Integer.MIN_VALUE)
+++					result = 0;
+++				break;
+++			case EXPRESSION:
+++				result = e.getExp().acceptEvaluation(this);
+++				break;
+++			case NEGATION:
+++				result = -1 * e.getExp().acceptEvaluation(this);
+++				break;
+++		}
+++		return result;
+++	}
+++	
+++	@Override
+++	public int eval(Sensor s)
+++	{
+++		int result = 0;
+++		int index;
+++		switch(s.getSensorType())
+++		{
+++			case NEARBY:
+++				index = s.getSensorIndex().acceptEvaluation(this);
+++				result = world.searchNearby(c, index);
+++				break;
+++			case AHEAD:
+++				index = s.getSensorIndex().acceptEvaluation(this);
+++				result = world.searchAhead(c, index);
+++				break;
+++			case RANDOM:
+++				index = s.getSensorIndex().acceptEvaluation(this);
+++				if(index < 2)
+++					result = 0;
+++				else
+++					result = (int) (Math.random() * index);
+++			case SMELL:
+++				result = 0;
+++		}
+++		return result;
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/interpret/Outcome.java b/src/main/java/interpret/Outcome.java
++deleted file mode 100644
++index 6f6ea20..0000000
++--- a/src/main/java/interpret/Outcome.java
+++++ /dev/null
++@@ -1,9 +0,0 @@
++-package interpret;
++-
++-/**
++- * An example interface for representing an outcome of interpreting
++- * a critter program.
++- */
++-public interface Outcome {
++-    // TODO define appropriate operations
++-}
++diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
++index a702d28..0d04293 100644
++--- a/src/main/java/parse/ParserImpl.java
+++++ b/src/main/java/parse/ParserImpl.java
++@@ -18,10 +18,10 @@ class ParserImpl implements Parser {
++ 	public Program parse(Reader r) {
++ 		this.tokens = new Tokenizer(r);
++ 		try {
++-			this.programAST = parseProgram(tokens);
++-		} catch (SyntaxError e) {
++-			System.out.println("The program inputted does not have the proper syntax.");
++-			System.exit(0);
+++			programAST = parseProgram(tokens);
+++		}
+++		catch (SyntaxError e) {
+++			programAST = null;
++ 		}
++ 
++ 		return this.programAST;
++@@ -39,7 +39,9 @@ class ParserImpl implements Parser {
++ 	public static ProgramImpl parseProgram(Tokenizer t) throws SyntaxError {
++ 		LinkedList<Rule> RuleList = new LinkedList<Rule>();
++ 		while (t.hasNext()) {
++-			RuleList.add(parseRule(t));
+++			Rule r = parseRule(t);
+++			RuleList.add(r);
+++			
++ 		}
++ 		return new ProgramImpl(RuleList);
++ 	}
++@@ -49,7 +51,6 @@ class ParserImpl implements Parser {
++ 		consume(t, TokenType.ARR);
++ 		Command command = parseCommand(t);
++ 		consume(t, TokenType.SEMICOLON);
++-		//System.out.println((new Rule(condition, command)).toString()); //TODO remove when done tesing
++ 		return new Rule(condition, command);
++ 	}
++ 	
++@@ -174,7 +175,6 @@ class ParserImpl implements Parser {
++ 		Condition conj = parseConjunction(t);
++ 		while (t.peek().getType() == TokenType.OR) {
++ 			consume(t, TokenType.OR);
++-			//System.out.println((new BinaryCondition(conj, Operator.OR, parseConjunction(t)).toString())); //TODO remove when done
++ 			return new BinaryCondition(conj, Operator.OR, parseConjunction(t));
++ 		}
++ 		return conj;
++@@ -186,7 +186,6 @@ class ParserImpl implements Parser {
++ 			consume(t, TokenType.AND);
++ 			return new BinaryCondition(rel, Operator.AND, parseRelation(t));
++ 		}
++-		//System.out.println(condition.toString());
++ 		return rel;
++ 	}
++ 	public static Relation parseRelation(Tokenizer t) throws SyntaxError {
++@@ -200,8 +199,6 @@ class ParserImpl implements Parser {
++ 		}
++ 		
++ 		Expr expression = parseExpression(t);
++-		//System.out.println(expression.toString());
++-		//Condition condition;
++ 		if (t.peek().getType().category() == TokenCategory.RELOP) {
++ 			String relationOperator = t.peek().toString();
++ 			consume(t, t.peek().getType());
++diff --git a/src/main/java/parse/Token.java b/src/main/java/parse/Token.java
++index a1f023e..2ba46cf 100644
++--- a/src/main/java/parse/Token.java
+++++ b/src/main/java/parse/Token.java
++@@ -186,8 +186,8 @@ class Token {
++ 		 * Constructs a new error token containing the value {@code v}.
++ 		 * @param v - String value for this error token.
++ 		 */
++-		ErrorToken(String v) {
++-			super(TokenType.ERROR, -1);
+++		ErrorToken(String v, int lineNo) {
+++			super(TokenType.ERROR, lineNo);
++ 			value = v;
++ 		}
++ 
++diff --git a/src/main/java/parse/Tokenizer.java b/src/main/java/parse/Tokenizer.java
++index 384ab04..8547ada 100644
++--- a/src/main/java/parse/Tokenizer.java
+++++ b/src/main/java/parse/Tokenizer.java
++@@ -1,510 +1,460 @@
++ package parse;
++ 
+++import static parse.TokenType.ARR;
+++import static parse.TokenType.ASSIGN;
+++import static parse.TokenType.DIV;
+++import static parse.TokenType.EQ;
+++import static parse.TokenType.GE;
+++import static parse.TokenType.GT;
+++import static parse.TokenType.LBRACE;
+++import static parse.TokenType.LBRACKET;
+++import static parse.TokenType.LE;
+++import static parse.TokenType.LPAREN;
+++import static parse.TokenType.LT;
+++import static parse.TokenType.MINUS;
+++import static parse.TokenType.MUL;
+++import static parse.TokenType.NE;
+++import static parse.TokenType.PLUS;
+++import static parse.TokenType.RBRACE;
+++import static parse.TokenType.RBRACKET;
+++import static parse.TokenType.RPAREN;
+++import static parse.TokenType.SEMICOLON;
+++
++ import java.io.BufferedReader;
++ import java.io.IOException;
++ import java.io.Reader;
++ import java.util.Iterator;
++ 
+++import parse.Token.EOFToken;
+++import parse.Token.ErrorToken;
+++import parse.Token.NumToken;
+++
++ /**
++  * A Tokenizer turns a Reader into a stream of tokens that can be iterated over
++  * using a {@code for} loop.
++  */
++ public class Tokenizer implements Iterator<Token> {
++ 
++-	/**
++-	 * BufferedReader to read from the {@code Reader} provided in the constructor,
++-	 * not {@code null}.
++-	 */
++-	private final BufferedReader br;
++-
++-	/** Builder to store read characters. */
++-	private final StringBuilder sb;
++-
++-	/**
++-	 * The number of the line being parsed from the reader. Starts at 1 and always
++-	 * equals 1 + the number of new line characters encountered.
++-	 */
++-	private int lineNo;
++-
++-	/**
++-	 * {@code tokenReady} is {@code false} if a token is not immediately available
++-	 * to be returned from {@code next()}, and {@code true} if a token is
++-	 * immediately ready to be returned from {@code next()}.
++-	 */
++-	private boolean tokenReady;
++-
++-	/**
++-	 * The most recent token processed by this Tokenizer, or an error token. Not
++-	 * {@code null}.
++-	 */
++-	private Token curTok;
++-
++-	/**
++-	 * {@code false} if the EOF has not been encountered, {@code true} if it has
++-	 * been encountered
++-	 */
++-	private boolean atEOF;
++-
++-	/**
++-	 * Create a Tokenizer that reads from the specified reader
++-	 * 
++-	 * @param r
++-	 *            - The source from which the Tokenizer lexes input into Tokens
++-	 */
++-	public Tokenizer(Reader r) {
++-		br = new BufferedReader(r);
++-		sb = new StringBuilder();
++-		lineNo = 1;
++-		tokenReady = false;
++-		curTok = new Token.ErrorToken("Tokenizer has not yet begun reading");
++-		atEOF = false;
++-	}
++-
++-	/**
++-	 * Returns {@code true} if the iteration has more meaningful elements. (In other
++-	 * words, returns {@code true} if {@link #next} would return a non-EOF element
++-	 * rather than throwing an exception or returning EOF.)
++-	 *
++-	 * @return {@code true} if the iteration has more meaningful elements
++-	 */
++-	@Override
++-	public boolean hasNext() {
++-		if (!tokenReady) {
++-			try {
++-				lexOneToken();
++-			} catch (IOException e) {
++-				throw new TokenizerIOException(e);
++-			} catch (EOFException e) {
++-				return false;
++-			}
++-		}
++-		return true;
++-	}
++-
++-	@Override
++-	public Token next() throws TokenizerIOException {
++-		Token tok = peek();
++-		tokenReady = false;
++-		return tok;
++-	}
++-
++-	/**
++-	 * Return the next token in the program without consuming the token.
++-	 *
++-	 * @return the next token, without consuming it
++-	 * @throws IOException
++-	 *             if an IOException was thrown while trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF was encountered while trying to lex the next token
++-	 */
++-	public Token peek() throws TokenizerIOException {
++-		if (!tokenReady && !atEOF) {
++-			try {
++-				lexOneToken();
++-			} catch (IOException e) {
++-				throw new TokenizerIOException(e);
++-			} catch (EOFException e) {
++-				// EOFException is thrown by encounteredEOF(), which should set
++-				// curTok to an EOFToken, so this catch block should be empty.
++-			}
++-		}
++-		return curTok;
++-	}
++-
++-	@Override
++-	public void remove() {
++-		tokenReady = false;
++-	}
++-
++-	/** Close the reader opened by this tokenizer. */
++-	void close() {
++-		try {
++-			br.close();
++-		} catch (IOException e) {
++-			System.out.println("IOException:");
++-			System.out.println(e.getMessage());
++-			e.printStackTrace();
++-		}
++-	}
++-
++-	/**
++-	 * Read one token from the reader. One token is always produced if the end of
++-	 * file is not encountered, but that token may be an error token.
++-	 *
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexOneToken() throws IOException, EOFException {
++-		setBuilderToFirstMeaningfulChar();
++-		char c = sb.charAt(0);
++-
++-		switch (c) {
++-		case '[':
++-			setNextTokenAndReset(TokenType.LBRACKET);
++-			break;
++-		case ']':
++-			setNextTokenAndReset(TokenType.RBRACKET);
++-			break;
++-		case '(':
++-			setNextTokenAndReset(TokenType.LPAREN);
++-			break;
++-		case ')':
++-			setNextTokenAndReset(TokenType.RPAREN);
++-			break;
++-		case '{':
++-			setNextTokenAndReset(TokenType.LBRACE);
++-			break;
++-		case '}':
++-			setNextTokenAndReset(TokenType.RBRACE);
++-			break;
++-		case ';':
++-			setNextTokenAndReset(TokenType.SEMICOLON);
++-			break;
++-		case '=':
++-			setNextTokenAndReset(TokenType.EQ);
++-			break;
++-		case '+':
++-			setNextTokenAndReset(TokenType.PLUS);
++-			break;
++-		case '*':
++-			setNextTokenAndReset(TokenType.MUL);
++-			break;
++-		case '/':
++-			if (consume('/')) {
++-				br.readLine();
++-				resetStringBuilder();
++-				setBuilderToFirstMeaningfulChar();
++-			} else {
++-				setNextTokenAndReset(TokenType.DIV);
++-			}
++-			break;
++-		case '<':
++-			lexLAngle();
++-			break;
++-		case '>':
++-			lexRAngle();
++-			break;
++-		case '-':
++-			lexDash();
++-			break;
++-		case ':':
++-			if (consume('='))
++-				setNextTokenAndReset(TokenType.ASSIGN);
++-			break;
++-		case '!':
++-			if (consume('='))
++-				setNextTokenAndReset(TokenType.NE);
++-			break;
++-		default:
++-			if (Character.isLetter(c))
++-				lexIdentifier();
++-			else if (Character.isDigit(c))
++-				lexNum();
++-			else
++-				unexpected();
++-		}
++-	}
++-
++-	/**
++-	 * Consumes whitespace up until the first non-whitespace character, and sets the
++-	 * builder to that character
++-	 *
++-	 * @throws IOException
++-	 *             if an IOException is encountered while reading from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void setBuilderToFirstMeaningfulChar() throws IOException, EOFException {
++-		// Make sure there isn't any leftover from a previous lexing operation
++-		assert sb.length() <= 1;
++-		char c = sb.length() == 1 ? c = sb.charAt(0) : getNextCharAndAppend();
++-
++-		// consume whitespace
++-		while (Character.isWhitespace(c)) {
++-			if (c == '\n')
++-				++lineNo;
++-			c = getNextCharAndAppend();
++-		}
++-
++-		resetBuilderWith(c);
++-	}
++-
++-	/**
++-	 * Lexes a left angle bracket. May be called only when the previously read
++-	 * character is '<'.
++-	 * 
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexLAngle() throws IOException, EOFException {
++-		int c = nextChar(false);
++-		if (c == -1) {
++-			setNextTokenAndReset(TokenType.LT);
++-		} else {
++-			char cc = (char) c;
++-			sb.append(cc);
++-			if (cc == '=')
++-				setNextTokenAndReset(TokenType.LE);
++-			else
++-				setNextTokenAndResetWith(TokenType.LT, cc);
++-		}
++-	}
++-
++-	/**
++-	 * Lexes a right angle bracket. May be called only when the previously read
++-	 * character '>'.
++-	 * 
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexRAngle() throws IOException, EOFException {
++-		int c = nextChar(false);
++-		if (c == -1) {
++-			setNextTokenAndReset(TokenType.GT);
++-		} else {
++-			char cc = (char) c;
++-			sb.append(cc);
++-			if (cc == '=')
++-				setNextTokenAndReset(TokenType.GE);
++-			else
++-				setNextTokenAndResetWith(TokenType.GT, cc);
++-		}
++-	}
++-
++-	/**
++-	 * Lexes a dash character. If a dash is followed by another dash, then it is
++-	 * part of an arrow. Otherwise it must represent a minus sign.
++-	 * 
++-	 * May only be called when the previously read char is a dash '-'.
++-	 * 
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexDash() throws IOException, EOFException {
++-		int c = nextChar(false);
++-		if (c == -1) {
++-			setNextTokenAndReset(TokenType.MINUS);
++-		} else {
++-			char cc = (char) c;
++-			sb.append(cc);
++-			if (cc == '-') {
++-				if (consume('>'))
++-					setNextTokenAndReset(TokenType.ARR);
++-			} else
++-				setNextTokenAndResetWith(TokenType.MINUS, cc);
++-		}
++-	}
++-
++-	/**
++-	 * Lexes an identifier. May be called only when the previously read character is
++-	 * a letter.
++-	 * 
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexIdentifier() throws IOException, EOFException {
++-		int c;
++-		for (c = nextChar(false); c != -1 && Character.isLetter(c); c = nextChar(false))
++-			sb.append((char) c);
++-
++-		String id = sb.toString();
++-		TokenType tt = TokenType.getTypeFromString(id);
++-		if (tt != null)
++-			setNextTokenAndReset(tt);
++-		else
++-			unexpected();
++-
++-		if (c != -1)
++-			sb.append((char) c);
++-	}
++-
++-	/**
++-	 * Lexes a number. May be called only when the previously read character is a
++-	 * digit.
++-	 * 
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and a token cannot be produced.
++-	 */
++-	private void lexNum() throws IOException, EOFException {
++-		int c;
++-		for (c = nextChar(false); c != -1 && Character.isDigit(c); c = nextChar(false))
++-			sb.append((char) c);
++-
++-		try {
++-			String num = sb.toString();
++-			int val = Integer.parseInt(num);
++-			curTok = new Token.NumToken(val, lineNo);
++-			tokenReady = true;
++-			resetStringBuilder();
++-			if (c != -1)
++-				sb.append((char) c);
++-		} catch (NumberFormatException e) {
++-			unexpected();
++-		}
++-	}
++-
++-	/**
++-	 * Read the next character from the reader, treating EOF as an error. If
++-	 * successful, append the character to the buffer.
++-	 *
++-	 * @return The next character
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read the next char
++-	 * @throws EOFException
++-	 *             if EOF is encountered
++-	 */
++-	private char getNextCharAndAppend() throws IOException, EOFException {
++-		char c = (char) nextChar(true);
++-		sb.append(c);
++-		return c;
++-	}
++-
++-	/**
++-	 * Read the next character from the reader. If {@code exceptionOnEOF}, treat EOF
++-	 * as an error. If successful, append the character to the buffer.
++-	 *
++-	 * @param exceptionOnEOF
++-	 *            {@code true} if EOF should be treated as an error
++-	 * @return The integer representation of the next character
++-	 * @throws IOException
++-	 *             if an {@code IOException} is thrown when trying to read from the
++-	 *             source Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered and isEOFerror is true
++-	 */
++-	private int nextChar(boolean exceptionOnEOF) throws IOException, EOFException {
++-		int c = br.read(); // returns -1 if the stream's end has been reached
++-		if (exceptionOnEOF && c == -1)
++-			encounteredEOF();
++-		return c;
++-	}
++-
++-	/**
++-	 * Sets the next token to be a token of {@code tokenType} and clears the
++-	 * {@code StringBuilder}.
++-	 * 
++-	 * @param tokenType
++-	 *            - the type of the token to set, not {@code null}
++-	 */
++-	private void setNextTokenAndReset(TokenType tokenType) {
++-		curTok = new Token(tokenType, lineNo);
++-		tokenReady = true;
++-		resetStringBuilder();
++-	}
++-
++-	/**
++-	 * Sets the next token to be a token of {@code tokenType}, clears the
++-	 * {@code StringBuilder}, and inserts {@code c} to begin the next string.
++-	 * 
++-	 * @param tokenType
++-	 *            - the type of the token to set, not {@code null}
++-	 * @param c
++-	 *            - the character to use at the start of the string builder
++-	 */
++-	private void setNextTokenAndResetWith(TokenType tokenType, char c) {
++-		setNextTokenAndReset(tokenType);
++-		sb.append(c);
++-	}
++-
++-	/**
++-	 * Resets the StringBuilder and starts a new string with {@code c}.
++-	 * 
++-	 * @param c
++-	 *            - the character with which to start a new string
++-	 */
++-	private void resetBuilderWith(char c) {
++-		resetStringBuilder();
++-		sb.append(c);
++-	}
++-
++-	/** Resets the StringBuilder {@code sb} to clear its string. */
++-	private void resetStringBuilder() {
++-		sb.setLength(0);
++-	}
++-
++-	/**
++-	 * Read the next character and determine whether it is the expected character.
++-	 * If not, the current buffer is an error
++-	 *
++-	 * @param expected
++-	 *            - The expected next character
++-	 * @return true if the next character is as expected
++-	 * @throws IOException
++-	 *             if an IOException was thrown when trying to read from the source
++-	 *             Reader
++-	 * @throws EOFException
++-	 *             if EOF is encountered
++-	 */
++-	private boolean consume(char expected) throws IOException, EOFException {
++-		int c = getNextCharAndAppend();
++-		if (c == expected)
++-			return true;
++-		unexpected();
++-		return false;
++-	}
++-
++-	/**
++-	 * Makes the current token an error token with the current contents of the
++-	 * buffer.
++-	 */
++-	private void unexpected() {
++-		curTok = new Token.ErrorToken(sb.toString());
++-		tokenReady = true;
++-		resetStringBuilder();
++-	}
++-
++-	/**
++-	 * Make the contents of the current buffer into an EOFToken, clearing the buffer
++-	 * in the process, set atEOF to true, and set the current token to the newly
++-	 * generated EOFToken, setting tokenReady in the process
++-	 */
++-	private void encounteredEOF() throws EOFException {
++-		curTok = new Token.EOFToken(sb.toString(), lineNo);
++-		resetStringBuilder();
++-		atEOF = true;
++-		tokenReady = true;
++-		throw new EOFException();
++-	}
++-
++-	/** "Helper" exception to indicate that EOF was reached */
++-	static class EOFException extends Exception {
++-		/** Unique serial version ID. @see Serializable#serialVersionUID */
++-		private static final long serialVersionUID = -7333947165525391472L;
++-	}
++-
++-	/** "Helper" exception to indicate an IO exception while tokenizing. */
++-	static class TokenizerIOException extends RuntimeException {
++-		/** Unique serial version ID. @see Serializable#serialVersionUID */
++-		private static final long serialVersionUID = 8014027094822746940L;
++-
++-		/**
++-		 * Constructs a new {@code TokenizerIOException} caused by {@code cause}.
++-		 * 
++-		 * @param cause
++-		 *            - the cause of the IOException
++-		 */
++-		TokenizerIOException(Throwable cause) {
++-			super(cause);
++-		}
++-	}
++-}
+++    private final BufferedReader br;
+++    private final StringBuilder buf;
+++    private int lineNo;
+++    /**
+++     * {@code tokenReady} is {@code false} if a token is not immediately
+++     * available to be returned from {@code next()}, and {@code true} if a token
+++     * is immediately ready to be returned from {@code next()}.
+++     */
+++    private boolean tokenReady = false;
+++    private Token curTok =
+++            new ErrorToken("Tokenizer has not yet begun reading", -1);
+++    private boolean atEOF = false;
+++
+++    /**
+++     * Create a Tokenizer that reads from the specified reader
+++     * 
+++     * @param r
+++     *            The source from which the Tokenizer lexes input into Tokens
+++     */
+++    Tokenizer(Reader r) {
+++        br = new BufferedReader(r);
+++        buf = new StringBuilder();
+++        lineNo = 1;
+++    }
+++
+++    /**
+++     * Returns {@code true} if the iteration has more meaningful elements. (In
+++     * other words, returns {@code true} if {@link #next} would return a non-EOF
+++     * element rather than throwing an exception or returning EOF.)
+++     *
+++     * @return {@code true} if the iteration has more meaningful elements
+++     */
+++    @Override
+++    public boolean hasNext() {
+++        if (!tokenReady) {
+++            try {
+++                lexOneToken();
+++            }
+++            catch (IOException e) {
+++                throw new TokenizerIOException(e);
+++            }
+++            catch (EOFException e) {
+++                return false;
+++            }
+++        }
+++        return true;
+++    }
+++
+++    @Override
+++    public Token next() throws TokenizerIOException {
+++        Token tok = peek();
+++        tokenReady = false;
+++        return tok;
+++    }
+++
+++    /**
+++     * Return the next token in the program without consuming the token.
+++     * 
+++     * @return the next token, without consuming it
+++     * @throws IOException
+++     *             if an IOException was thrown while trying to read from the
+++     *             source Reader
+++     * @throws EOFException
+++     *             if EOF was encountered while trying to lex the next token
+++     */
+++    public Token peek() throws TokenizerIOException {
+++        if (!tokenReady && !atEOF) try {
+++            lexOneToken();
+++        }
+++        catch (IOException e) {
+++            throw new TokenizerIOException(e);
+++        }
+++        catch (EOFException e) {
+++            // EOFException is thrown by encounteredEOF(), which should set
+++            // curTok to an EOFToken
+++        }
+++        return curTok;
+++    }
+++
+++    @Override
+++    public void remove() {
+++        throw new UnsupportedOperationException();
+++    }
+++
+++    /**
+++     * Close the reader opened by this tokenizer.
+++     */
+++    void close() {
+++        try {
+++            br.close();
+++        }
+++        catch (IOException e) {
+++            System.out.println("IOException:");
+++            System.out.println(e.getMessage());
+++            e.printStackTrace();
+++        }
+++    }
+++
+++    /**
+++     * Read one token from the reader. One token is always produced if the end
+++     * of file is not encountered, but that token may be an error token.
+++     * 
+++     * @throws IOException
+++     *             if an IOException was thrown when trying to read from the
+++     *             source Reader
+++     * @throws EOFException
+++     *             if EOF is encountered and a token cannot be produced.
+++     */
+++    private void lexOneToken() throws IOException, EOFException {
+++        setBufToFirstMeaningfulChar();
+++        char c = buf.charAt(0);
+++
+++        switch (c) {
+++        case '[':
+++            setNextTokenAndReset(LBRACKET);
+++            break;
+++        case ']':
+++            setNextTokenAndReset(RBRACKET);
+++            break;
+++        case '(':
+++            setNextTokenAndReset(LPAREN);
+++            break;
+++        case ')':
+++            setNextTokenAndReset(RPAREN);
+++            break;
+++        case '{':
+++            setNextTokenAndReset(LBRACE);
+++            break;
+++        case '}':
+++            setNextTokenAndReset(RBRACE);
+++            break;
+++        case ';':
+++            setNextTokenAndReset(SEMICOLON);
+++            break;
+++        case '=':
+++            setNextTokenAndReset(EQ);
+++            break;
+++        case '+':
+++            setNextTokenAndReset(PLUS);
+++            break;
+++        case '*':
+++            setNextTokenAndReset(MUL);
+++            break;
+++        case '/':
+++            lexSlash();
+++            break;
+++        case '<':
+++            lexLAngle();
+++            break;
+++        case '>':
+++            lexRAngle();
+++            break;
+++        case '-':
+++            lexDash();
+++            break;
+++        case ':':
+++            if (consume('=')) setNextTokenAndReset(ASSIGN);
+++            break;
+++        case '!':
+++            if (consume('=')) setNextTokenAndReset(NE);
+++            break;
+++        default:
+++            if (Character.isLetter(c))
+++                lexIdentifier();
+++            else if (Character.isDigit(c))
+++                lexNum();
+++            else unexpected();
+++        }
+++    }
+++
+++    /**
+++     * Consumes whitespace up until the first non-whitespace character, and sets
+++     * the buffer to that character
+++     * 
+++     * @throws IOException
+++     *             if an IOException is encountered while reading from the
+++     *             source Reader
+++     */
+++    private void setBufToFirstMeaningfulChar() throws IOException, EOFException {
+++        // Make sure there isn't any leftover from a previous lexing operation
+++        assert buf.length() <= 1;
+++        char c = buf.length() == 1 ? c = buf.charAt(0) : getNextCharAndAppend();
+++
+++        // consume whitespaces
+++        while (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
+++            if (c == '\n') lineNo++;
+++            c = getNextCharAndAppend();
+++        }
+++
+++        resetBufferWith(c);
+++    }
+++
+++    private void lexSlash() throws IOException, EOFException {
+++        int c = nextChar(false);
+++        if (c == -1)
+++            setNextTokenAndReset(DIV);
+++        else {
+++            char cc = (char) c;
+++            buf.append(cc);
+++            if (cc == '/') {
+++                // rest-of-line comment
+++                while (cc != '\n')
+++                    cc = getNextCharAndAppend();
+++                resetBufferWith(cc);
+++                setBufToFirstMeaningfulChar();
+++            }
+++            else setNextTokenAndResetWith(DIV, cc);
+++        }
+++    }
+++
+++    private void lexLAngle() throws IOException, EOFException {
+++        int c = nextChar(false);
+++        if (c == -1)
+++            setNextTokenAndReset(LT);
+++        else {
+++            char cc = (char) c;
+++            buf.append(cc);
+++            if (cc == '=')
+++                setNextTokenAndReset(LE);
+++            else setNextTokenAndResetWith(LT, cc);
+++        }
+++    }
+++
+++    private void lexRAngle() throws IOException, EOFException {
+++        int c = nextChar(false);
+++        if (c == -1)
+++            setNextTokenAndReset(GT);
+++        else {
+++            char cc = (char) c;
+++            buf.append(cc);
+++            if (cc == '=')
+++                setNextTokenAndReset(GE);
+++            else setNextTokenAndResetWith(GT, cc);
+++        }
+++    }
+++
+++    private void lexDash() throws IOException, EOFException {
+++        int[] cs = peekReader(2);
+++        if (cs[0] == -1) {
+++            consume('-'); // Dash already in the system
+++            setNextTokenAndReset(MINUS);
+++        }
+++        else { // Have one dash, what's next
+++               // If dash #2
+++            if ((char) cs[0] == '-') {
+++                // If >
+++                if ((char) cs[1] == '>') { // It's an arrow!
+++                    consume('-');
+++                    consume('>');
+++                    setNextTokenAndReset(ARR);
+++                }
+++                else {
+++                    consume('-');
+++                    setNextTokenAndResetWith(MINUS, '-');
+++                }
+++            }
+++            else { // No dash #2
+++                setNextTokenAndReset(MINUS);
+++            }
+++        }
+++    }
+++
+++    private void lexIdentifier() throws IOException, EOFException {
+++        int c;
+++        for (c = nextChar(false); c != -1 && Character.isLetter(c); c =
+++                nextChar(false))
+++            buf.append((char) c);
+++
+++        String id = buf.toString();
+++        TokenType tt = TokenType.getTypeFromString(id);
+++        if (tt != null) {
+++            setNextTokenAndReset(tt);
+++        }
+++        else {
+++            unexpected();
+++        }
+++
+++        if (c != -1) buf.append((char) c);
+++    }
+++
+++    private void lexNum() throws IOException, EOFException {
+++        int c;
+++        for (c = nextChar(false); c != -1 && Character.isDigit(c); c =
+++                nextChar(false))
+++            buf.append((char) c);
+++
+++        try {
+++            String num = buf.toString();
+++            int val = Integer.parseInt(num);
+++            curTok = new NumToken(val, lineNo);
+++            tokenReady = true;
+++            buf.setLength(0);
+++            if (c != -1) buf.append((char) c);
+++        }
+++        catch (NumberFormatException e) {
+++            unexpected();
+++        }
+++    }
+++
+++    /**
+++     * Read the next character from the reader, treating EOF as an error. If
+++     * successful, append the character to the buffer.
+++     * 
+++     * @return The next character
+++     * @throws IOException
+++     *             if an IOException was thrown when trying to read the next
+++     *             char
+++     * @throws EOFException
+++     *             if EOF is encountered
+++     */
+++    private char getNextCharAndAppend() throws IOException, EOFException {
+++        char c = (char) nextChar(true);
+++        buf.append(c);
+++        return c;
+++    }
+++
+++    /**
+++     * Read the next character from the reader. If isEOFerror, treat EOF as an
+++     * error. If successful, append the character to the buffer.
+++     * 
+++     * @param exceptionOnEOF
+++     * @return The integer representation of the next character
+++     * @throws IOException
+++     *             if an {@code IOException} is thrown when trying to read from
+++     *             the source Reader
+++     * @throws EOFException
+++     *             if EOF is encountered and isEOFerror is true
+++     */
+++    private int nextChar(boolean exceptionOnEOF) throws IOException,
+++            EOFException {
+++        int c = br.read();
+++        if (exceptionOnEOF && c == -1) encounteredEOF();
+++        return c;
+++    }
+++
+++    private void setNextTokenAndReset(TokenType tokenType) {
+++        curTok = new Token(tokenType, lineNo);
+++        tokenReady = true;
+++        buf.setLength(0);
+++    }
+++
+++    private void setNextTokenAndResetWith(TokenType tokenType, char c) {
+++        setNextTokenAndReset(tokenType);
+++        buf.append(c);
+++    }
+++
+++    private void resetBufferWith(char c) {
+++        buf.setLength(0);
+++        buf.append(c);
+++    }
+++
+++    /**
+++     * Read the next character and determine whether it is the expected
+++     * character. If not, the current buffer is an error
+++     * 
+++     * @param expected
+++     *            The expected next character
+++     * @return true if the next character is as expected
+++     * @throws IOException
+++     *             if an IOException was thrown when trying to read from the
+++     *             source Reader
+++     * @throws EOFException
+++     *             if EOF is encountered
+++     */
+++    private boolean consume(char expected) throws IOException, EOFException {
+++        int c = getNextCharAndAppend();
+++        if (c != expected) {
+++            unexpected();
+++            return false;
+++        }
+++        return true;
+++    }
+++
+++    /**
+++     * Make the current token an error token with the current contents of the
+++     * buffer
+++     */
+++    private void unexpected() {
+++        curTok = new ErrorToken(buf.toString(), lineNo);
+++        tokenReady = true;
+++        buf.setLength(0);
+++    }
+++
+++    private final int[] charBuf = new int[3];
+++
+++    private int[] peekReader(int distance) throws IOException {
+++        assert distance <= 3 && distance > 0;
+++        br.mark(distance + 1);
+++        for (int i = 0; i < distance; i++) {
+++            charBuf[i] = br.read();
+++        }
+++        br.reset();
+++        return charBuf;
+++    }
+++
+++    /**
+++     * Make the contents of the current buffer into an EOFToken, clearing the
+++     * buffer in the process, set atEOF to true, and set the current token to
+++     * the newly generated EOFToken, setting tokenReady in the process
+++     */
+++    private void encounteredEOF() throws EOFException {
+++        curTok = new EOFToken(buf.toString(), lineNo);
+++        buf.setLength(0);
+++        atEOF = true;
+++        tokenReady = true;
+++        throw new EOFException();
+++    }
+++
+++    /**
+++     * "Helper" exception to indicate that EOF was reached
+++     */
+++    static class EOFException extends Exception {
+++        private static final long serialVersionUID = -7333947165525391472L;
+++    }
+++
+++    static class TokenizerIOException extends RuntimeException {
+++        private static final long serialVersionUID = 8014027094822746940L;
+++
+++        TokenizerIOException(Throwable cause) {
+++            super(cause);
+++        }
+++    }
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
++new file mode 100644
++index 0000000..a58087f
++--- /dev/null
+++++ b/src/main/java/simulation/AbstractWorld.java
++@@ -0,0 +1,170 @@
+++package simulation;
+++
+++import java.util.HashMap;
+++import java.util.LinkedList;
+++
+++import interpret.Interpreter;
+++import interpret.InterpreterImpl;
+++
+++public abstract class AbstractWorld implements SimpleWorld
+++{
+++	/** A compilation of all the constants needed for world creation. */
+++	protected HashMap<String, Double> CONSTANTS;
+++	/** Stores all the critters present in the world, in the order in which they were created. */
+++	protected LinkedList<SimpleCritter> critterList;
+++	/** The number of time steps passed since this world's genesis. */
+++	protected int timePassed;
+++	
+++	@Override
+++	public int getMinMemory()
+++	{
+++		return CONSTANTS.get("MIN_MEMORY").intValue();
+++	}
+++
+++	@Override
+++	public int getMaxRules()
+++	{
+++		return CONSTANTS.get("MAX_RULES_PER_TURN").intValue();
+++	}
+++
+++	@Override
+++	public int numRemainingCritters()
+++	{
+++		return critterList.size();
+++	}
+++	
+++	@Override
+++	public int getTimePassed()
+++	{
+++		return timePassed;
+++	}
+++	
+++	@Override
+++	@SuppressWarnings("unchecked")
+++	public void advanceOneTimeStep()
+++	{
+++		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
+++		for(int i = 0; i < clone.size(); i++)
+++		{
+++			SimpleCritter sc = clone.get(i);
+++			Interpreter im = new InterpreterImpl(sc, this);
+++			im.simulateCritterTurn();
+++		}
+++		
+++		for(int i = 0; i < clone.size(); i++)
+++		{
+++			SimpleCritter sc = clone.get(i);
+++			sc.toggleMatingPheromones(false);
+++}
+++		
+++		timePassed++;
+++	}
+++
+++	@Override
+++	public abstract void loadCritters(String filename, int n, int direction);
+++	
+++	@Override
+++	public abstract StringBuilder printGrid();
+++	
+++	/* ========================================= */
+++	/* ----------- Critter Sensors ------------- */
+++	/* ========================================= */
+++	
+++	/**
+++	 * Looks at the contents of a hex adjacent to a critter.
+++	 * @param sc : the critter who is observing its surroundings
+++	 * @param dir : the direction in which to look
+++	 * @return an integer value based on the contents of the observed hex, determined by the {@code WorldObject}
+++	 * 		   method {@code getAppearance()}.
+++	 */
+++	public abstract int searchNearby(SimpleCritter sc, int dir);
+++
+++	/**
+++	 * Looks at the contents of a hex ahead of a critter.
+++	 * @param sc : the critter who is observing its surroundings
+++	 * @param index : how far ahead to look
+++	 * @return an integer value based on the contents of the observed hex, following the same scheme as {@code searchNearby}.
+++	 */
+++	public abstract int searchAhead(SimpleCritter sc, int index);
+++
+++	/* ========================================= */
+++	/* ----------- Critter Actions ------------- */
+++	/* ========================================= */
+++	
+++	/* 
+++	  A NOTE ON ACTIONS: all critter actions except WAIT expend energy. Most of them expend the same amount of energy whether
+++	  they succeed or not. If a critter tries to execute an action that requires more energy than it currently has, it will 
+++	  die without executing that action. If a critter has just enough energy to perform an action (i.e. the energy required
+++	  to perform that action is equal to the energy it currently has, it will execute that action and promptly die afterwards.
+++	*/
+++	
+++	/**
+++	 * Moves a critter, if there is nothing in the way and critter will not move off the world bounds.
+++	 * @param sc : the moving critter
+++	 * @param forward : whether or not the critter is moving forward or backward
+++	 */
+++	public abstract void moveCritter(SimpleCritter sc, boolean forward);
+++	
+++	/**
+++	 * Turns a critter.
+++	 * @param sc : the turning critter
+++	 * @param forward : whether or not the critter is turning clockwise or counterclockwise
+++	 */
+++	public abstract void turnCritter(SimpleCritter sc, boolean clockwise);
+++
+++	/**
+++	 * Forces a critter to eat, if there is food in the hex directly in front of it. This action replenishes energy
+++	 * equal to the caloric content of the food eaten.
+++	 * @param sc : the feasting critter
+++	 */
+++	public abstract void critterEat(SimpleCritter sc);
+++
+++	/**
+++	 * Grows a critter by one size.
+++	 * @param sc : the growing critter
+++	 */
+++	public abstract void growCritter(SimpleCritter sc);
+++
+++	/** 
+++	 * Simulates the results of one critter attacking another.
+++	 * @param attacker
+++	 */
+++	public abstract void critterBattle(SimpleCritter attacker);
+++	
+++	
+++	/** 
+++	 * Executes the result of one critter attempting to bud. The newly created offspring will appear directly behind
+++	 * the parent critter, unless there is something already in that hex (in which case no reproduction will occur).
+++	 * @param sc : the budding critter
+++	 */
+++	public abstract void critterBud(SimpleCritter sc);
+++	
+++	/**
+++	 * Executes the result of one critter attempting to mate with another critter. The other critter must be directly in
+++	 * front of the first critter and facing the first critter. The newly created offspring will appear directly behind
+++	 * one of the parent critters, unless there is something already in that hex (in which case no reproduction will occur).
+++	 * @param sc
+++	 */
+++	public abstract void critterMate(SimpleCritter sc);
+++	
+++	/**
+++	 * One critter "tags" another critter by setting its "tag" attribute in memory equal to the value of {@code index}.
+++	 * @param sc
+++	 * @param index
+++	 */
+++	public abstract void critterTag(SimpleCritter sc, int index);
+++	
+++	/**
+++	 * One critter severs a part of its soul (its energy) and places it on the hex in front of it in the form of food. It is
+++	 * possible for the critter to serve all of its remaining energy, killing it in the process
+++	 * @param sc : the overly generous critter
+++	 * @param index : the amount of food to serve
+++	 */
+++	public abstract void critterServe(SimpleCritter sc, int index);
+++	
+++	/**
+++	 * A critter does nothing but sit in the sun. It replenishes some energy in the process.
+++	 * @param sc
+++	 */
+++	public abstract void critterSoakEnergy(SimpleCritter sc);
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/Critter.java b/src/main/java/simulation/Critter.java
++new file mode 100644
++index 0000000..a414aab
++--- /dev/null
+++++ b/src/main/java/simulation/Critter.java
++@@ -0,0 +1,298 @@
+++package simulation;
+++
+++import ast.Program;
+++import java.util.Arrays;
+++
+++/** A critter is a creature that inhabits CritterWorld. */
+++public class Critter implements SimpleCritter
+++{
+++	/** The set of rules for this critter. */
+++	private Program prog;
+++	/** The memory of this critter, which stores important attributes of the critter. */
+++	private int[] memory;
+++	/** The length of this critter's memory. Must be at least 8. */
+++	private int memLength;
+++	/** The direction this critter is facing. */
+++	private Direction orientation;
+++	/** Whether or not this critter wants to mate. */
+++	private boolean readyToMingle;
+++	/** The name of this critter, used for identification purposes. */
+++	private String name;
+++	/** A string containing information about the last rule this critter completed. */
+++	private String lastRuleCompleted;
+++	
+++	/**
+++	 * Creates a new Critter with a specified ruleset, memory, orientation, and name.
+++	 * @param p
+++	 * @param mem
+++	 * @param dir
+++	 * @param s
+++	 */
+++	public Critter(Program p, int[] mem, String s, int dir)
+++	{
+++		prog = p;
+++		memory = mem;
+++		memLength = mem[0];
+++		name = s;
+++		readyToMingle = false;
+++		lastRuleCompleted = null;
+++		
+++		orientation = Direction.constructDir(dir);
+++	}
+++	
+++	/**
+++	 * Creates a new Critter with a specified ruleset, memory, name, and a random orientation.
+++	 * @param p
+++	 * @param mem
+++	 * @param s
+++	 */
+++	public Critter(Program p, int[] mem, String s)
+++	{
+++		prog = p;
+++		memory = mem;
+++		memLength = mem[0];
+++		name = s;
+++		readyToMingle = false;
+++		lastRuleCompleted = null;
+++		
+++		int rand = (int) (Math.random() * 6);
+++		orientation = Direction.constructDir(rand);
+++	}
+++	
+++	@Override
+++	public int size()
+++	{
+++		return memory[3];
+++	}
+++	
+++	@Override
+++	public int getMemLength()
+++	{
+++		return memLength;
+++	}
+++	
+++	@Override
+++	public Program getProgram()
+++	{
+++		return prog;
+++	}
+++	
+++	@Override
+++	public int getOrientation()
+++	{
+++		return orientation.getValue();
+++	}
+++	
+++	@Override
+++	public String getLastRule()
+++	{
+++		return lastRuleCompleted;
+++	}
+++	@Override
+++	public void setLastRule(String s)
+++	{
+++		lastRuleCompleted = s;
+++	}
+++	
+++	@Override
+++	public int readMemory(int index)
+++	{
+++		if(index < 0 || index >= memLength)
+++			return Integer.MIN_VALUE;
+++		return memory[index];
+++	}
+++	
+++	@Override
+++	public boolean setMemory(int val, int index)
+++	{
+++		//this method does nothing if it tries to alter an index of less than 7, or if the index is out of memory's bounds
+++		if(index < 7 || index >= memLength)
+++			return false;
+++		//the value of mem[7] must be in the range [0, 99] so attempting to set it to something else also has no effect
+++		if(index == 7 && !(val <= 99 && val >= 0))
+++			return false;
+++		
+++		memory[index] = val;
+++		return true;
+++	}
+++	
+++	@Override
+++	public String getName()
+++	{
+++		return name;
+++	}
+++	
+++	@Override
+++	public int getEnergy()
+++	{
+++		return memory[4];
+++	}
+++	
+++	@Override
+++	public void updateEnergy(int amount, int maxEnergyPerSize)
+++	{
+++		memory[4] += amount;
+++		if(memory[4] > maxEnergyPerSize * size())
+++			memory[4] = maxEnergyPerSize * size();
+++	}
+++	
+++	@Override
+++	public void incrementPass()
+++	{
+++		if(memory[5] < 999)
+++			memory[5]++;
+++	}
+++	
+++	@Override
+++	public void turn(boolean counterclockwise)
+++	{
+++		int curDir = orientation.getValue();
+++		int change = counterclockwise ? 1 : -1;
+++		
+++		int newDir = curDir + change;
+++		if(newDir > 5)
+++			newDir -= 6;
+++		else if(newDir < 0)
+++			newDir += 6;
+++		orientation = Direction.constructDir(newDir);
+++	}
+++	
+++	@Override
+++	public String toString()
+++	{
+++		return "" + orientation.getValue();
+++	}
+++	
+++	@Override
+++	public boolean wantsToMate()
+++	{
+++		return readyToMingle;
+++	}
+++	
+++	@Override
+++	public void toggleMatingPheromones(boolean b)
+++	{
+++		readyToMingle = b;
+++	}
+++	
+++	@Override
+++	public int complexity(int ruleCost, int abilityCost)
+++	{
+++		return prog.getRulesList().size() * ruleCost + (memory[1] + memory[2]) * abilityCost;
+++	}
+++	
+++	@Override
+++	public int getAppearance()
+++	{
+++		return memory[3] * 100000 + memory[6] * 1000 + memory[7] * 10 + orientation.getValue();
+++	}
+++
+++	@Override
+++	public int[] changeInPosition(boolean forward, int dir)
+++	{
+++		int[] result = new int[2];
+++		Direction d = Direction.constructDir(dir);
+++		switch(d)
+++		{
+++			case NORTH:
+++				result[0] = 0;
+++				result[1] = 1;
+++				break;
+++			case NORTHEAST:
+++				result[0] = 1;
+++				result[1] = 1;
+++				break;
+++			case SOUTHEAST:
+++				result[0] = 1;
+++				result[1] = 0;
+++				break;
+++			case SOUTH:
+++				result[0] = 0;
+++				result[1] = -1;
+++				break;
+++			case SOUTHWEST:
+++				result[0] = -1;
+++				result[1] = -1;
+++				break;
+++			case NORTHWEST:
+++				result[0] = -1;
+++				result[1] = 0;
+++				break;			
+++		}
+++		if(!forward)
+++		{
+++			result[0] *= -1;
+++			result[1] *= -1;
+++		}
+++		return result;
+++	}
+++	
+++	@Override
+++	public int[] getMemoryCopy()
+++	{
+++		return Arrays.copyOf(memory, memLength);
+++	}
+++	
+++	/** An enumeration of all the possible directions a critter can be facing. */
+++	public enum Direction
+++	{
+++		NORTH, NORTHEAST, SOUTHEAST, SOUTH, SOUTHWEST, NORTHWEST;
+++		
+++		/** 
+++		 * Returns an integer value of this direction based on an arbitrary numbering system that sets NORTH to 0 and 
+++		 * goes counterclockwise until it stops at NORTHEAST.
+++		 */
+++		public int getValue()
+++		{
+++			int result = 0;
+++			switch(this)
+++			{
+++				case NORTH:
+++					result = 0;
+++					break;
+++				case NORTHEAST:
+++					result = 1;
+++					break;
+++				case SOUTHEAST:
+++					result = 2;
+++					break;
+++				case SOUTH:
+++					result = 3;
+++					break;
+++				case SOUTHWEST:
+++					result = 4;
+++					break;
+++				case NORTHWEST:
+++					result = 5;
+++					break;
+++			}
+++			return result;
+++		}
+++		
+++		/**
+++		 * Returns a direction from an integer based on the aforementioned numbering system.
+++		 * @param n
+++		 * @return a direction that depends on the integer entered. If {@code n} is not in [0, 5], returns NORTH.
+++		 */
+++		public static Direction constructDir(int n)
+++		{
+++			switch(n)
+++			{
+++				case 0:
+++					return NORTH;
+++				case 1:
+++					return NORTHEAST;
+++				case 2:
+++					return SOUTHEAST;
+++				case 3:
+++					return SOUTH;
+++				case 4:
+++					return SOUTHWEST;
+++				case 5:
+++					return NORTHWEST;
+++				default:
+++					return NORTH;
+++			}
+++		}
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/FileParser.java b/src/main/java/simulation/FileParser.java
++new file mode 100644
++index 0000000..95dbc6b
++--- /dev/null
+++++ b/src/main/java/simulation/FileParser.java
++@@ -0,0 +1,183 @@
+++package simulation;
+++
+++import java.io.*;
+++import java.util.HashMap;
+++
+++import ast.Program;
+++import parse.Parser;
+++import parse.ParserFactory;
+++
+++/** This class supplies several static methods that may be useful for parsing files needed for world creation and modification. */
+++public class FileParser
+++{
+++	/**
+++	 * Constructs a critter from a file.
+++	 * @param br : a BufferedReader containing the file to be read
+++	 * @param minMemory : the minimum memory size for a critter
+++	 * @param direction : the direction the critter will be facing
+++	 * @return A SimpleCritter object made from the parsed file, or null if the program contains syntax errors
+++	 */
+++	public static SimpleCritter parseCritter(BufferedReader br, int minMemory, int direction)
+++	{
+++		String[] parsed = parseAttributes(br);
+++		String name = parsed[0].equals("") ? "Untitled #" : parsed[0];
+++		int[] critMem = FileParser.makeCritterMemory(parsed, minMemory);
+++		
+++		//parses the critter program. If the program isn't syntactically valid, returns null
+++		Parser p = ParserFactory.getParser();
+++		Program prog = p.parse(br);
+++		if(prog == null)
+++			return null;
+++		
+++		if((direction < 0 || direction > 5))
+++			return new Critter(prog, critMem, name);
+++		return new Critter(prog, critMem, name, direction);
+++	}
+++	
+++	/**
+++	 * Parses the attributes for a critter from a file into a String array.
+++	 * @param br : a BufferedReader containing the file to be read
+++	 * @return a String array containing the memory attributes needed to create the critter.
+++	 */
+++	public static String[] parseAttributes(BufferedReader br)
+++	{
+++		String name = parseAttributeFromLine(br, "species: ");
+++		String memsize = parseAttributeFromLine(br, "memsize: ");
+++		String defense = parseAttributeFromLine(br, "defense: ");
+++		String offense = parseAttributeFromLine(br, "offense: ");
+++		String size = parseAttributeFromLine(br, "size: ");
+++		String energy = parseAttributeFromLine(br, "energy: ");
+++		String posture = parseAttributeFromLine(br, "posture: ");
+++		
+++		return new String[] {name, memsize, defense, offense, size, energy, posture};
+++	}
+++	
+++	/**
+++	 * Given a BufferedReader, parses one attribute line from a file and returns a string containing only the attribute by
+++	 * trimming out a specified substring {@code substringToCut}. If {@code substringToCut} is not present in the line or the end
+++	 * of the file is reached, returns an empty string.
+++	 * 
+++	 * @param b : the BufferedReader to read lines from
+++	 * @param : substringToCut the substring to trim
+++	 * @return A string containing only the attribute given on the line
+++	 */
+++	public static String parseAttributeFromLine(BufferedReader b, String substringToCut)
+++	{
+++		String result = "";
+++		try
+++		{
+++			String line = b.readLine();
+++			int len = substringToCut.length();
+++			if(line != null && line.startsWith(substringToCut) && len < line.length())
+++				result = line.substring(len);
+++		}
+++		catch (IOException e)
+++		{
+++			return "";
+++		}
+++		return result;
+++	}
+++	
+++	/**
+++	 * Prepares an int array to be used as critter memory, based on a string array.<br>
+++	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
+++	 * @param strs : an array of strings created by the method {@code FileParser.parseAttributes(filename)}
+++	 * @param minMemory : the minimum memory size for a critter
+++	 * @return an int array, ready to be used as critter memory. Returns a default set of memory if {@code strs} is not compatible.
+++	 */
+++	private static int[] makeCritterMemory(String[] strs, int minMemory)
+++	{
+++		//if the strs array is less than 7, then we revert to a default set of memory
+++		if(strs.length < 7)
+++			return new int[] {minMemory, 3, 3, 1, 500, 0, 0, 0};
+++		
+++		int[] critterAttributes;
+++		
+++		int memsize = parseIntFromString(strs[1]);
+++		if(memsize < minMemory)
+++			memsize = minMemory;
+++		critterAttributes = new int[memsize];
+++		critterAttributes[0] = memsize;
+++		
+++		int defense = parseIntFromString(strs[2]);
+++		if(defense < 0)
+++			defense = 3;
+++		critterAttributes[1] = defense;
+++		
+++		int offense = parseIntFromString(strs[3]);
+++		if(offense < 0)
+++		offense = 3;
+++		critterAttributes[2] = offense;
+++		
+++		int size = parseIntFromString(strs[4]);
+++		if(size < 0)
+++			size = 1;
+++		critterAttributes[3] = size;
+++		
+++		int energy = parseIntFromString(strs[5]);
+++		if(energy < 0)
+++			energy = 500;
+++		critterAttributes[4] = energy;
+++		
+++		int pass = 0;
+++		critterAttributes[5] = pass;
+++		
+++		int tag = 0;
+++		critterAttributes[6] = tag;
+++		
+++		int posture = parseIntFromString(strs[6]);
+++		if(posture < 0 || posture > 99)
+++			posture = 0;
+++		critterAttributes[7] = posture;
+++		
+++		for(int i = 8; i < memsize; i++)
+++			critterAttributes[i] = 0;
+++		
+++		return critterAttributes;
+++	}
+++	/**
+++	 * Parses an integer value from a given string, or returns -1 if no integer was found.
+++	 * @param s : the string to parse
+++	 * @return the int parsed from the string, or -1 if no integer was found
+++	 */
+++	private static int parseIntFromString(String s)
+++	{
+++		try
+++		{
+++			return Integer.parseInt(s);
+++		}
+++		catch (NumberFormatException n)
+++		{
+++			return -1;
+++		}
+++	}
+++	
+++	/**
+++	 * Parses constants from a file and returns them in the form of a HashMap. Assumes that the file adheres to the format
+++	 * specified by the <a href="http://www.cs.cornell.edu/courses/cs2112/2017fa/project/constants.txt">constants file given
+++	 * to us</a>.
+++	 * @param b : a BufferedReader containing the file to be read.
+++	 * @return a HashMap containing the names of constants mapped to their values.
+++	 * @throws IllegalArgumentException if the file is not valid.
+++	 */
+++	public static HashMap<String, Double> parseConstants(BufferedReader b) throws IllegalArgumentException
+++	{
+++		HashMap<String, Double> result = new HashMap<String, Double>();
+++		try
+++		{
+++			String line = b.readLine();
+++			while(line != null)
+++			{
+++				String[] constant = line.split(" ");
+++				result.put(constant[0], Double.parseDouble(constant[1]));
+++				line = b.readLine();
+++			}
+++		}
+++		//If the constants file has any irregularities,
+++		catch (Exception e)
+++		{
+++			throw new IllegalArgumentException();
+++		}
+++		return result;
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/Food.java b/src/main/java/simulation/Food.java
++new file mode 100644
++index 0000000..ecc2e6f
++--- /dev/null
+++++ b/src/main/java/simulation/Food.java
++@@ -0,0 +1,31 @@
+++package simulation;
+++
+++/** A piece of food that can be present on one world hex. */
+++public class Food implements WorldObject
+++{
+++	/** The caloric value of this piece of food. */
+++	private int calories;
+++	
+++	/** Creates a new Food object with the specified amount of calories. */
+++	public Food(int amt)
+++	{
+++		calories = amt;
+++	}
+++	
+++	/** Returns the amount of calories in this piece of food. */
+++	public int getCalories()
+++	{
+++		return calories;
+++	}
+++	
+++	public String toString()
+++	{
+++		return "F";
+++	}
+++
+++	@Override
+++	public int getAppearance()
+++	{
+++		return -1 * (calories + 1);
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/Hex.java b/src/main/java/simulation/Hex.java
++new file mode 100644
++index 0000000..cd3bd91
++--- /dev/null
+++++ b/src/main/java/simulation/Hex.java
++@@ -0,0 +1,81 @@
+++package simulation;
+++
+++/** Stores the information for one hex in the world grid. */
+++public class Hex
+++{
+++	/** The column index of this Hex. */
+++	private int colIndex;
+++	/** The row index of this Hex. */
+++	private int rowIndex;
+++	/** What this hex contains. May be null if there is nothing on this hex. */
+++	private WorldObject content;
+++	
+++	/** Creates a new empty Hex object with the specified rowIndex and colIndex. */
+++	public Hex(int c, int r)
+++	{
+++		colIndex = c;
+++		rowIndex = r;
+++		content = null;
+++	}
+++	
+++	/** Returns the column index of this Hex. */
+++	public int getColumnIndex()
+++	{
+++		return colIndex;
+++	}
+++	
+++	/** Returns the row index of this Hex. */
+++	public int getRowIndex()
+++	{
+++		return rowIndex;
+++	}
+++	
+++	/**
+++	 * Adds a world object to this hex, if it is empty.
+++	 * @param wo the object to add
+++	 * @return whether or not {@code wo} was able to be added to this hex.
+++	 */
+++	public boolean addContent(WorldObject wo)
+++	{
+++		if(isEmpty())
+++		{
+++			content = wo;
+++			return true;
+++		}
+++		return false;
+++	}
+++	
+++	/** Removes the content on this hex. */
+++	public void removeContent()
+++	{
+++		content = null;
+++	}
+++	
+++	public WorldObject getContent()
+++	{
+++		return content;
+++	}
+++	/** Returns {@code true} if and only if {@code content == null}. */
+++	public boolean isEmpty()
+++	{
+++		return content == null;
+++	}
+++	
+++	/**
+++	 * Returns an integer representing how this hex appears to a critter. If this hex is empty, this integer is 0,
+++	 * but otherwise, this value is determined by {@code content.getAppearance()}, which follows the numbering scheme
+++	 * described in the interface {@code WorldObject}.
+++	 */
+++	public int hexAppearance()
+++	{
+++		return isEmpty() ? 0 : content.getAppearance();
+++	}
+++	
+++	@Override
+++	public String toString()
+++	{
+++		if(content == null)
+++			return "-";
+++		return content.toString();
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/Rock.java b/src/main/java/simulation/Rock.java
++new file mode 100644
++index 0000000..fd7ac7f
++--- /dev/null
+++++ b/src/main/java/simulation/Rock.java
++@@ -0,0 +1,17 @@
+++package simulation;
+++
+++/** This is a <a href = "https://en.wikipedia.org/wiki/Rock_(geology)">rock</a>. */
+++public class Rock implements WorldObject
+++{
+++	@Override
+++	public String toString()
+++	{
+++		return "#";
+++	}
+++
+++	@Override
+++	public int getAppearance()
+++	{
+++		return -1;
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/SimpleCritter.java b/src/main/java/simulation/SimpleCritter.java
++new file mode 100644
++index 0000000..0bfb0f2
++--- /dev/null
+++++ b/src/main/java/simulation/SimpleCritter.java
++@@ -0,0 +1,80 @@
+++package simulation;
+++
+++import ast.Program;
+++
+++public interface SimpleCritter extends WorldObject
+++{
+++	/** Returns the ruleset of this critter. */
+++	public Program getProgram();
+++	
+++	/** Returns the size of this critter. */
+++	public int size();
+++	
+++	/** Returns the memory length of this critter. */
+++	public int getMemLength();
+++	
+++	/** Returns the orientation of this critter. */
+++	public int getOrientation();
+++	
+++	/** Returns the current energy level of this critter. */
+++	public int getEnergy();
+++	
+++	/** Updates the critter's energy by the amount specified. */
+++	public void updateEnergy(int amount, int maxEnergyPerSize);
+++	
+++	/** 
+++	 * Returns the value of {@code memory[index]}.
+++	 * @param index
+++	 * @return the value of this critter's memory at the specified index, or {@code Integer.MIN_VALUE} if the index lies out-of-bounds
+++	 */
+++	public int readMemory(int index);
+++	
+++	/**
+++	 * Sets the memory at index to val. Does nothing if {@code index} is an out-of-bounds or unassignable index
+++	 * or if {@code val} is not within the restrictions of that array index.
+++	 * @param val
+++	 * @param index
+++	 * @return Whether or not the memory array was actually altered
+++	 */
+++	public boolean setMemory(int val, int index);
+++	
+++	@Override
+++	public int getAppearance();
+++	
+++	/** Returns a copy of the memory. */
+++	public int[] getMemoryCopy();
+++	
+++	/** Returns the species name of this critter. */
+++	public String getName();
+++	
+++	/** Returns a string representation of the last rule executed by this critter. */
+++	public String getLastRule();
+++	
+++	/** Sets the last rule executed. */
+++	public void setLastRule(String s);
+++	
+++	/** Increments the pass number of this critter (memory index 5) by one, if it is less than 999. */
+++	public void incrementPass();
+++	
+++	/**
+++	 * Turns this critter in the direction specified.
+++	 * @param counterclockwise
+++	 */
+++	public void turn(boolean clockwise);
+++	
+++	/**
+++	 * Returns an array of length 2 that symbolizes the change in position of a critter if it moves one hex in the specified direction.
+++	 * @param forward : whether or not the hex will be accessed by moving forward or backward
+++	 * @param dir : the direction the hex is in
+++	 */
+++	public int[] changeInPosition(boolean forward, int dir);
+++	
+++	/** Whether or not this critter wants to mate. */
+++	public boolean wantsToMate();
+++	
+++	/** Turns mating signals of this critter on or off. */
+++	public void toggleMatingPheromones(boolean b);
+++	
+++	/** Returns an integer value representing this critter's complexity. */
+++	public int complexity(int ruleCost, int abilityCost);
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
++new file mode 100644
++index 0000000..ac97405
++--- /dev/null
+++++ b/src/main/java/simulation/SimpleWorld.java
++@@ -0,0 +1,51 @@
+++package simulation;
+++
+++/** An interface containing the basic functions of the world. */
+++public interface SimpleWorld
+++{
+++	/** Returns the minimum critter memory size for this world. Cannot be less than 8. */
+++	int getMinMemory();
+++	
+++	/** Returns the maximum number of rules that may be executed per turn for this world. */
+++	int getMaxRules();
+++	
+++	/** Returns the number of living critters currently in the simulation. */
+++	int numRemainingCritters();
+++	
+++	/** Returns the amount of time passed since this world's genesis. */
+++	int getTimePassed();
+++	
+++	/**
+++	 * Loads critters of following a set pattern into this world.
+++	 * @param filename the file containing the critter information
+++	 * @param n the number of critters to load
+++	 * @param direction the orientation of the critter. If this value is less than 0, a critter orientation
+++	 * 					will be chosen at random.
+++	 */
+++	void loadCritters(String filename, int n, int direction);
+++	
+++	/** Advances the world state by a single time step. */
+++	void advanceOneTimeStep();
+++	
+++	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
+++	boolean isValidHex(int c, int r);
+++	
+++	/**
+++	 * Returns information about a hex. Assumes that the 
+++	 * @param c
+++	 * @param r
+++	 * @return
+++	 */
+++	int analyzeHex(int c, int r);
+++	
+++	/**
+++	 * 
+++	 * @param c
+++	 * @param r
+++	 * @return
+++	 */
+++	SimpleCritter analyzeCritter(int c, int r);
+++
+++	/** Returns a StringBuilder containing the printed version of the world grid. */
+++	StringBuilder printGrid();
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
++new file mode 100644
++index 0000000..ae9bd56
++--- /dev/null
+++++ b/src/main/java/simulation/World.java
++@@ -0,0 +1,845 @@
+++package simulation;
+++
+++import java.io.BufferedReader;
+++import java.io.FileNotFoundException;
+++import java.io.FileReader;
+++import java.io.InputStream;
+++import java.io.InputStreamReader;
+++import java.util.HashMap;
+++import java.util.LinkedList;
+++import java.util.Random;
+++
+++import ast.Program;
+++import ast.ProgramImpl;
+++import ast.Rule;
+++
+++/** A class to simulate the world state. */
+++public class World extends AbstractWorld
+++{
+++	/** The name of this world. */
+++	private String worldname;
+++	/** Contains the hex grid of the world. */
+++	private Hex[][] grid;
+++	/** Maps each critter to a location in the world */
+++	private HashMap<SimpleCritter, Hex> critterMap;
+++	/** The number of columns in the world grid. */
+++	private int columns;
+++	/** The number of rows in the world grid. */
+++	private int rows;
+++	/** The number of hexes that lie on the world grid. */
+++	private int numValidHexes;
+++
+++	/**
+++	 * Loads a world based on a world description file.
+++	 * 
+++	 * @param filename The name of the file that contains world information.
+++	 * @throws FileNotFoundException if the world file could not be found
+++	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
+++	 */
+++	public World(String filename) throws FileNotFoundException, IllegalArgumentException
+++	{
+++		// sets constants and initializes instance fields
+++		super();
+++		setConstants();
+++		critterMap = new HashMap<SimpleCritter, Hex>();
+++		super.critterList = new LinkedList<SimpleCritter>();
+++		super.timePassed = 0;
+++
+++		BufferedReader bf = new BufferedReader(new FileReader(filename));
+++
+++		// parses the world name, and if no valid one is parsed, supplies a default one
+++		worldname = FileParser.parseAttributeFromLine(bf, "name ");
+++		if (worldname.equals(""))
+++			worldname = "Arrakis";
+++
+++		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
+++		try
+++		{
+++			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
+++			String[] dim = worldDimensions.split(" ");
+++			columns = Integer.parseInt(dim[0]);
+++			rows = Integer.parseInt(dim[1]);
+++
+++			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
+++			{
+++				columns = CONSTANTS.get("COLUMNS").intValue();
+++				rows = CONSTANTS.get("ROWS").intValue();
+++			}
+++		}
+++		catch (Exception e)
+++		{
+++			columns = CONSTANTS.get("COLUMNS").intValue();
+++			rows = CONSTANTS.get("ROWS").intValue();
+++		}
+++		numValidHexes = 0;
+++
+++		// initializes world grid
+++		grid = new Hex[columns][rows];
+++		for (int i = 0; i < grid.length; i++)
+++			for (int j = 0; j < grid[0].length; j++)
+++				if (isValidHex(i, j))
+++				{
+++					grid[i][j] = new Hex(i, j);
+++					numValidHexes++;
+++				}
+++
+++		try
+++		{
+++			// loads in world objects from file
+++			String line = bf.readLine();
+++			while (line != null)
+++			{
+++				String[] info = line.split(" ");
+++				switch (info[0])
+++				{
+++					case "rock":
+++						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+++						break;
+++					case "food":
+++						Food f = new Food(Integer.parseInt(info[3]));
+++						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+++						break;
+++					case "critter":
+++						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
+++						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
+++								Integer.parseInt(info[4]));
+++						if(sc == null)
+++						{
+++							System.err.println("The critter file " + filename + " does not have the right syntax, so it was not loaded.");
+++							break;
+++						}
+++							
+++						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
+++						break;
+++				}
+++				line = bf.readLine();
+++			}
+++		}
+++		catch (Exception e)
+++		{
+++			return;
+++		}
+++	}
+++
+++	/**
+++	 * Generates a default size world containing nothing but randomly placed rocks.
+++	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
+++	 */
+++	public World() throws IllegalArgumentException
+++	{
+++		// sets constants and initializes instance fields
+++		super();
+++		worldname = "Arrakis";
+++		setConstants();
+++		critterMap = new HashMap<SimpleCritter, Hex>();
+++		critterList = new LinkedList<SimpleCritter>();
+++		timePassed = 0;
+++
+++		super.critterList = new LinkedList<SimpleCritter>();
+++		super.timePassed = 0;
+++
+++		columns = CONSTANTS.get("COLUMNS").intValue();
+++		rows = CONSTANTS.get("ROWS").intValue();
+++		numValidHexes = 0;
+++
+++		grid = new Hex[columns][rows];
+++		for (int i = 0; i < grid.length; i++)
+++			for (int j = 0; j < grid[0].length; j++)
+++			{
+++				if (isValidHex(i, j))
+++				{
+++					grid[i][j] = new Hex(i, j);
+++					numValidHexes++;
+++				}
+++			}
+++
+++		// randomly fills about 1/40 of the hexes in the world with rocks
+++		int c = (int) (Math.random() * columns);
+++		int r = (int) (Math.random() * rows);
+++		int n = 0;
+++		while (n < numValidHexes / 40)
+++		{
+++			c = (int) (Math.random() * columns);
+++			r = (int) (Math.random() * rows);
+++			if (isValidHex(c, r))
+++			{
+++				grid[c][r].addContent(new Rock());
+++				n++;
+++			}
+++		}
+++	}
+++
+++	/**
+++	 * Parses the constants file in the project directory and stores the constants in the CONSTANTS field.
+++	 * @throws IllegalArgumentException if the constants file couldn't be found or is improperly formatted
+++	 */
+++	private void setConstants() throws IllegalArgumentException
+++	{
+++		InputStream in = World.class.getResourceAsStream("constants.txt");
+++		if(in == null)
+++		{ 
+++			System.err.println("The constants.txt file could not be found in bin/simulation.");
+++			System.exit(0);
+++		}
+++		
+++		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
+++		CONSTANTS = FileParser.parseConstants(bf);
+++	}
+++
+++	@Override
+++	public boolean isValidHex(int c, int r)
+++	{
+++		if (c < 0 || r < 0)
+++			return false;
+++		else if (c >= columns || r >= rows)
+++			return false;
+++		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
+++			return false;
+++		return true;
+++	}
+++
+++	@Override
+++	public void loadCritters(String filename, int n, int direction)
+++	{
+++		try
+++		{
+++			BufferedReader br = new BufferedReader(new FileReader(filename));
+++			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
+++
+++			for (int i = 0; i < n; i++)
+++			{
+++
+++				int randc = (int) (Math.random() * columns);
+++				int randr = (int) (Math.random() * rows);
+++				while (!isValidHex(randc, randr))
+++				{
+++					randc = (int) (Math.random() * columns);
+++					randr = (int) (Math.random() * rows);
+++				}
+++
+++				if (isValidHex(randc, randr))
+++					loadOneCritter(sc, randc, randr);
+++			}
+++		}
+++		catch (FileNotFoundException e)
+++		{
+++			System.err.println("Critter file not found.");
+++			return;
+++		}
+++	}
+++
+++	/**
+++	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
+++	 * the hex is not within the world boundaries, or if there is something already present at the hex.
+++	 * 
+++	 * @param sc the critter to add
+++	 * @param c the column index of the hex where the critter will be added
+++	 * @param r the row index of the hex where the critter will be added
+++	 */
+++	private void loadOneCritter(SimpleCritter sc, int c, int r)
+++	{
+++		if (!isValidHex(c, r))
+++			return;
+++		boolean added = grid[c][r].addContent(sc);
+++		if (added)
+++		{
+++			critterList.add(sc);
+++			critterMap.put(sc, grid[c][r]);
+++		}
+++	}
+++
+++	/**
+++	 * Loads a single non-critter world object into the world at the specified coordinates, if possible.
+++	 * Does nothing if the hex is not within the world boundaries or if there is something already present at
+++	 * the hex. This method cannot be used to add critters into the world. Use the method
+++	 * {@code loadCritter(SimpleCritter sc, int c, int r)} instead.
+++	 * 
+++	 * @param sc the object to add
+++	 * @param c the column index of the hex where the object will be added
+++	 * @param r the row index of the hex where the object will be added
+++	 */
+++	private void addNonCritterObject(WorldObject wo, int c, int r)
+++	{
+++		if (wo instanceof Critter)
+++			return;
+++		if (!isValidHex(c, r))
+++			return;
+++		grid[c][r].addContent(wo);
+++	}
+++
+++	/* ========================================= */
+++	/* ----------- Critter Sensors ------------- */
+++	/* ========================================= */
+++
+++	@Override
+++	public int searchNearby(SimpleCritter sc, int dir)
+++	{
+++		//determines the row and column coordinates of the critter
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++		
+++		// finds the hex to look in, based on the value of dir
+++		if (dir < 0)
+++			dir = 0;
+++		else if (dir > 6)
+++			dir %= 6;
+++		int nearbyc = c + sc.changeInPosition(true, dir)[0];
+++		int nearbyr = r + sc.changeInPosition(true, dir)[1];
+++
+++		// critters see rock when they look off the edge of the world
+++		if (!isValidHex(nearbyc, nearbyr))
+++			return -1;
+++		Hex nearby = grid[nearbyc][nearbyr];
+++		return nearby.hexAppearance();
+++	}
+++
+++	@Override
+++	public int searchAhead(SimpleCritter sc, int index)
+++	{
+++		//determines the row and column coordinates of the critter
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++		
+++		if (index < 0)
+++			index = 0;
+++		int aheadc = c + sc.changeInPosition(true, sc.getOrientation())[0] * index;
+++		int aheadr = r + sc.changeInPosition(true, sc.getOrientation())[1] * index;
+++
+++		if (!isValidHex(aheadc, aheadr))
+++			return -1;
+++		Hex nearby = grid[aheadc][aheadr];
+++		return nearby.hexAppearance();
+++	}
+++
+++	/* ========================================= */
+++	/* ----------- Critter Actions ------------- */
+++	/* ========================================= */
+++
+++	@Override
+++	public void moveCritter(SimpleCritter sc, boolean forward)
+++	{
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		int cost = CONSTANTS.get("MOVE_COST").intValue() * sc.size();
+++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		// if the critter did not have enough energy to complete this action, kills the critter
+++		if (sc.getEnergy() < 0)
+++		{
+++			kill(sc);
+++			return;
+++		}
+++
+++		int[] changeInCoords = sc.changeInPosition(forward, sc.getOrientation());
+++		int newc = c + changeInCoords[0];
+++		int newr = r + changeInCoords[1];
+++
+++		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
+++		{
+++			if (sc.getEnergy() == 0)
+++				kill(sc);
+++			return;
+++		}
+++		grid[c][r].removeContent();
+++		critterMap.remove(sc);
+++		grid[newc][newr].addContent(sc);
+++		critterMap.put(sc, grid[newc][newr]);
+++		if (sc.getEnergy() == 0)
+++			kill(sc);
+++	}
+++
+++	@Override
+++	public void turnCritter(SimpleCritter sc, boolean clockwise)
+++	{
+++		int cost = sc.size();
+++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		// if the critter did not have enough energy to complete this action, kills the critter
+++		if (sc.getEnergy() < 0)
+++		{
+++			kill(sc);
+++			return;
+++		}
+++
+++		sc.turn(clockwise);
+++		if (sc.getEnergy() == 0)
+++			kill(sc);
+++	}
+++
+++	@Override
+++	public void critterEat(SimpleCritter sc)
+++	{
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		int cost = sc.size();
+++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		// if the critter did not have enough energy to complete this action, kills the critter
+++		if (sc.getEnergy() < 0)
+++		{
+++			kill(sc);
+++			return;
+++		}
+++
+++		int newc = c + sc.changeInPosition(true, sc.getOrientation())[0];
+++		int newr = r + sc.changeInPosition(true, sc.getOrientation())[1];
+++		if (!isValidHex(newc, newr))
+++		{
+++			if (sc.getEnergy() == 0)
+++				kill(sc);
+++			return;
+++		}
+++
+++		Hex directlyInFront = grid[newc][newr];
+++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof Food)
+++		{
+++			Food nourishment = (Food) directlyInFront.getContent();
+++			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++			directlyInFront.removeContent();
+++		}
+++		if (sc.getEnergy() == 0)
+++			kill(sc);
+++	}
+++
+++	@Override
+++	public void growCritter(SimpleCritter sc)
+++	{
+++		int cost = sc.size()
+++				* sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
+++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		// if the critter did not have enough energy to complete this action, kills the critter
+++		if (sc.getEnergy() < 0)
+++		{
+++			kill(sc);
+++			return;
+++		}
+++
+++		int currentSize = sc.readMemory(3);
+++		sc.setMemory(currentSize + 1, 3);
+++	}
+++
+++	@Override
+++	public void critterBattle(SimpleCritter attacker)
+++	{
+++		Hex location = critterMap.get(attacker);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		int cost = attacker.size() * CONSTANTS.get("ATTACK_COST").intValue();
+++		attacker.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		//if the critter did not have enough energy to complete this action, kills the critter
+++		if (attacker.getEnergy() < 0)
+++		{
+++			kill(attacker);
+++			return;
+++		}
+++
+++		int newc = c + attacker.changeInPosition(true, attacker.getOrientation())[0];
+++		int newr = r + attacker.changeInPosition(true, attacker.getOrientation())[1];
+++		if (!isValidHex(newc, newr))
+++		{
+++			if (attacker.getEnergy() == 0)
+++				kill(attacker);
+++			return;
+++		}
+++
+++		Hex directlyInFront = grid[newc][newr];
+++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
+++		{
+++			// Calculates the damage dealt to the target critter
+++			SimpleCritter target = (SimpleCritter) (directlyInFront.getContent());
+++			int baseDamage = CONSTANTS.get("BASE_DAMAGE").intValue();
+++			double dmgMultiplier = CONSTANTS.get("DAMAGE_INC").doubleValue();
+++			int dmgBeforeScaling = (attacker.size() * attacker.readMemory(2)) - (target.size() * target.readMemory(1));
+++			int damage = baseDamage * attacker.size() * logisticFunction(dmgMultiplier * (double)dmgBeforeScaling);
+++
+++			// kills the target if it took damage greater than or equal to its current energy
+++			target.updateEnergy(-1 * damage, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++			if (target.getEnergy() <= 0)
+++				kill(target);
+++		}
+++
+++		if (attacker.getEnergy() == 0)
+++			kill(attacker);
+++	}
+++
+++	/** Performs the logistic function 1 / (1 + e^-x), floored to an integer value. */
+++	private int logisticFunction(double x)
+++	{
+++		double exponent = -1 * x;
+++		return (int) (1 / (1 + Math.exp(exponent)));
+++	}
+++
+++	@Override
+++	public void critterBud(SimpleCritter sc)
+++	{
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		int complexity = sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
+++		sc.updateEnergy(-1 * CONSTANTS.get("BUD_COST").intValue() * complexity,
+++				CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		//if the critter did not have enough energy to complete this action, kills the critter
+++		if (sc.getEnergy() < 0)
+++		{
+++			kill(sc);
+++			return;
+++		}
+++
+++		int newc = c + sc.changeInPosition(false, sc.getOrientation())[0];
+++		int newr = r + sc.changeInPosition(false, sc.getOrientation())[1];
+++		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
+++		{
+++			if (sc.getEnergy() == 0)
+++				kill(sc);
+++			return;
+++		}
+++
+++		//Constructs the baby critter's memory, copying memory length, offense, and defense from the parent
+++		int[] babymem = new int[sc.getMemLength()];
+++		babymem[0] = sc.getMemLength();
+++		babymem[1] = sc.readMemory(1);
+++		babymem[2] = sc.readMemory(2);
+++		babymem[3] = 1;
+++		babymem[4] = 250;
+++		for (int i = 5; i < babymem.length; i++)
+++			babymem[i] = 0;
+++
+++		String name = sc.getName() + " Jr.";
+++		Program prog = sc.getProgram();
+++		int numMutations = numberMutations();
+++		for (int i = 0; i < numMutations; i++)
+++			prog = prog.mutate();
+++
+++		SimpleCritter baby = new Critter(prog, babymem, name, sc.getOrientation());
+++		loadOneCritter(baby, newc, newr);
+++
+++		if (sc.getEnergy() == 0)
+++			kill(sc);
+++	}
+++
+++	@Override
+++	public void critterMate(SimpleCritter sc)
+++	{
+++		sc.toggleMatingPheromones(true);
+++		Hex location = critterMap.get(sc);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++		int behindColumnParent1 = c + sc.changeInPosition(false, sc.getOrientation())[0];
+++		int behindRowParent1 = r + sc.changeInPosition(false, sc.getOrientation())[1];
+++		if (!isValidHex(behindColumnParent1, behindRowParent1))
+++		{
+++			sc.toggleMatingPheromones(false);
+++			return;
+++		}
+++		// coordinates of Parent 2
+++		int columnParent2 = c + sc.changeInPosition(true, sc.getOrientation())[0];
+++		int rowParent2 = r + sc.changeInPosition(true, sc.getOrientation())[1];
+++		if (!isValidHex(columnParent2, rowParent2))
+++		{
+++			sc.toggleMatingPheromones(false);
+++			return;
+++		}
+++		Hex directlyInFront = grid[columnParent2][rowParent2];
+++		if (!(directlyInFront.getContent() instanceof SimpleCritter))
+++		{
+++			sc.toggleMatingPheromones(false);
+++			return;
+++		}
+++		SimpleCritter parent2 = (SimpleCritter) (directlyInFront.getContent());
+++		int behindColumnParent2 = columnParent2 + sc.changeInPosition(false, sc.getOrientation())[0];
+++		int behindRowParent2 = rowParent2 + sc.changeInPosition(false, sc.getOrientation())[1];
+++		if (!isValidHex(behindColumnParent2, behindRowParent2))
+++		{
+++			sc.toggleMatingPheromones(false);
+++			return;
+++		}
+++		// checks if Parent 2 wants to mate
+++		if (!parent2.wantsToMate())
+++			return;
+++		int parent1Direction = sc.getOrientation();
+++		int parent2Direction = parent2.getOrientation();
+++
+++		// direction checking
+++		if (!(Math.abs(parent1Direction - parent2Direction) == 3))
+++		{
+++			sc.toggleMatingPheromones(false);
+++			return;
+++		}
+++
+++		// energy calculation
+++		sc.updateEnergy(-sc.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++		parent2.updateEnergy(-parent2.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++		if (sc.getEnergy() < 0 || parent2.getEnergy() < 0)
+++		{
+++			if (sc.getEnergy() < 0)
+++				kill(sc);
+++			if (parent2.getEnergy() < 0)
+++				kill(parent2);
+++			return;
+++		}
+++		initiateMatingProcess(sc, parent2);
+++	}
+++
+++	/** Randomly determines the number of mutations that will occur during mating or budding. */
+++	private int numberMutations()
+++	{
+++		double randomNumber = Math.random();
+++		int returnValue = 0;
+++		double temp = 0.25;
+++
+++		for (int i = 0; i < 10; i++)
+++		{
+++			if (randomNumber < temp)
+++				returnValue++;
+++			temp = Math.pow(0.25, i + 1);
+++		}
+++		return returnValue;
+++	}
+++
+++	/** Executes the mating process, as long as there is one empty hex around the two critters. */
+++	private void initiateMatingProcess(SimpleCritter sc1, SimpleCritter sc2)
+++	{
+++		Random random = new Random();
+++		// energy calculation
+++		int complexity1 = sc1.complexity(CONSTANTS.get("RULE_COST").intValue(),
+++				CONSTANTS.get("ABILITY_COST").intValue());
+++		int complexity2 = sc2.complexity(CONSTANTS.get("RULE_COST").intValue(),
+++				CONSTANTS.get("ABILITY_COST").intValue());
+++		sc1.updateEnergy(-5 * complexity1, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++		sc2.updateEnergy(-5 * complexity2, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++		if (sc1.getEnergy() < 0 || sc2.getEnergy() < 0)
+++		{
+++			if (sc1.getEnergy() < 0)
+++				kill(sc1);
+++			if (sc2.getEnergy() < 0)
+++				kill(sc2);
+++			return;
+++		}
+++
+++		// generating RuleSet
+++		LinkedList<Rule> babyRules = new LinkedList<Rule>();
+++		int ruleSetSize = 0;
+++		if (random.nextBoolean())
+++			ruleSetSize = sc1.getProgram().getRulesList().size();
+++		else
+++			ruleSetSize = sc2.getProgram().getRulesList().size();
+++		for (int i = 0; i < ruleSetSize; i++)
+++		{
+++			if (random.nextBoolean())
+++			{
+++				if (i >= sc1.getProgram().getRulesList().size())
+++					babyRules.add(sc2.getProgram().getRulesList().get(i));
+++				else
+++					babyRules.add(sc1.getProgram().getRulesList().get(i));
+++			}
+++			else
+++			{
+++				if (i >= sc2.getProgram().getRulesList().size())
+++					babyRules.add(sc1.getProgram().getRulesList().get(i));
+++				else
+++					babyRules.add(sc2.getProgram().getRulesList().get(i));
+++			}
+++		}
+++		Program prog = new ProgramImpl(babyRules);
+++
+++		//generating memory
+++		int[] babymem = null;
+++		if (random.nextBoolean())
+++		{
+++			babymem = new int[sc1.getMemLength()];
+++			babymem[0] = sc1.getMemLength();
+++		}
+++		else
+++		{
+++			babymem = new int[sc2.getMemLength()];
+++			babymem[0] = sc2.getMemLength();
+++		}
+++		for (int i = 1; i <= 2; i++)
+++		{
+++			if (random.nextBoolean())
+++				babymem[i] = sc1.readMemory(i);
+++			else
+++				babymem[i] = sc2.readMemory(i);
+++		}
+++		babymem[3] = 1;
+++		babymem[4] = 250;
+++		for (int i = 5; i < babymem.length; i++)
+++			babymem[i] = 0;
+++
+++		// coordinate Generation
+++		int babyColumn = 0;
+++		int babyRow = 0;
+++		if (random.nextBoolean())
+++		{
+++			Hex location = critterMap.get(sc1);
+++			babyColumn = location.getColumnIndex() + sc1.changeInPosition(false, sc1.getOrientation())[0];
+++			babyRow = location.getRowIndex() + sc1.changeInPosition(false, sc1.getOrientation())[1];
+++		}
+++		else
+++		{
+++			Hex location = critterMap.get(sc2);
+++			babyColumn = location.getColumnIndex() + sc2.changeInPosition(false, sc2.getOrientation())[0];
+++			babyRow = location.getRowIndex() + sc2.changeInPosition(false, sc2.getOrientation())[1];
+++		}
+++
+++		int numMutations = numberMutations();
+++		for (int i = 0; i < numMutations; i++)
+++			prog = prog.mutate();
+++		String name = sc1.getName() + sc2.getName() + " Jr.";
+++		SimpleCritter baby = new Critter(prog, babymem, name, 0);
+++		loadOneCritter(baby, babyColumn, babyRow);
+++
+++		if (sc1.getEnergy() == 0 || sc2.getEnergy() == 0)
+++		{
+++			if (sc1.getEnergy() == 0)
+++				kill(sc1);
+++			if (sc2.getEnergy() == 0)
+++				kill(sc2);
+++			return;
+++		}
+++		sc1.toggleMatingPheromones(false);
+++		sc2.toggleMatingPheromones(false);
+++	}
+++
+++	@Override
+++	public void critterTag(SimpleCritter tagger, int val)
+++	{
+++		Hex location = critterMap.get(tagger);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		tagger.updateEnergy(-1 * tagger.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		//if the critter did not have enough energy to complete this action, kills the critter
+++		if (tagger.getEnergy() < 0)
+++		{
+++			kill(tagger);
+++			return;
+++		}
+++
+++		int newc = c + tagger.changeInPosition(true, tagger.getOrientation())[0];
+++		int newr = r + tagger.changeInPosition(true, tagger.getOrientation())[1];
+++		if (!isValidHex(newc, newr))
+++		{
+++			if (tagger.getEnergy() == 0)
+++				kill(tagger);
+++			return;
+++		}
+++
+++		Hex directlyInFront = grid[newc][newr];
+++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
+++		{
+++			SimpleCritter taggee = (SimpleCritter) (directlyInFront.getContent());
+++			if (!(val < 0 || val > 99))
+++				taggee.setMemory(val, 6);
+++		}
+++
+++		if (tagger.getEnergy() == 0)
+++			kill(tagger);
+++	}
+++
+++	@Override
+++	public void critterServe(SimpleCritter donator, int index)
+++	{
+++		Hex location = critterMap.get(donator);
+++		int c = location.getColumnIndex();
+++		int r = location.getRowIndex();
+++
+++		if (index < 0)
+++			index = 0;
+++		else if(index > donator.getEnergy() + donator.size())
+++			index = donator.getEnergy() + donator.size();
+++
+++		donator.updateEnergy(-1 * (donator.size() + index), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++
+++		//if the critter did not have enough energy to complete this action, kills the critter
+++		if (donator.getEnergy() < 0)
+++		{
+++			kill(donator);
+++			return;
+++		}
+++
+++		int newc = c + donator.changeInPosition(true, donator.getOrientation())[0];
+++		int newr = r + donator.changeInPosition(true, donator.getOrientation())[1];
+++		if (!isValidHex(newc, newr))
+++		{
+++			if (donator.getEnergy() == 0)
+++				kill(donator);
+++			return;
+++		}
+++
+++		Hex directlyInFront = grid[newc][newr];
+++		if (directlyInFront.isEmpty())
+++		{
+++			Food f = new Food(index);
+++			directlyInFront.addContent(f);
+++		}
+++		if (donator.getEnergy() == 0)
+++			kill(donator);
+++	}
+++
+++	@Override
+++	public void critterSoakEnergy(SimpleCritter sc)
+++	{
+++		sc.updateEnergy(CONSTANTS.get("SOLAR_FLUX").intValue(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+++	}
+++
+++	/** Kills a critter and removes it from any lists or mappings of critters. Rest in peace, buddy. */
+++	private void kill(SimpleCritter sc)
+++	{
+++		Hex location = critterMap.get(sc);
+++		location.removeContent();
+++		critterMap.remove(sc);
+++		critterList.remove(sc);
+++
+++		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
+++		location.addContent(remnant);
+++	}
+++
+++	@Override
+++	public StringBuilder printGrid()
+++	{	
+++		StringBuilder result = new StringBuilder();
+++		for(int i = 0; i < 2 * rows - columns; i++)
+++		{
+++			StringBuilder sb = new StringBuilder();
+++			if(i % 2 != 0)
+++				sb.append("  ");
+++			for(int c = i % 2, r = (int) Math.ceil(i / 2.0); c < columns && r < rows; c += 2, r++)
+++			{
+++				if(isValidHex(c, r))
+++					sb.append("" + grid[c][r].toString() + "   ");
+++			}
+++			result.insert(0, sb.toString() + "\n");
+++		}
+++		result.insert(0, "World name: " + worldname + "\n");
+++		return result;
+++	}
+++	
+++	@Override
+++	public int analyzeHex(int c, int r)
+++	{
+++		if(!isValidHex(c, r))
+++			return Integer.MIN_VALUE;
+++		return grid[c][r].hexAppearance();
+++	}
+++	
+++	@Override
+++	public SimpleCritter analyzeCritter(int c, int r)
+++	{
+++		if(!isValidHex(c, r) || !(grid[c][r].getContent() instanceof SimpleCritter))
+++			return null;
+++		return (SimpleCritter) (grid[c][r].getContent());
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/main/java/simulation/WorldObject.java b/src/main/java/simulation/WorldObject.java
++new file mode 100644
++index 0000000..4b03632
++--- /dev/null
+++++ b/src/main/java/simulation/WorldObject.java
++@@ -0,0 +1,16 @@
+++package simulation;
+++
+++public interface WorldObject
+++{
+++	/** Returns the ASCII art representation of this object. */
+++	public String toString();
+++	
+++	/** 
+++	 * Returns an integer value based on this world object. This value depends on the type of this object:
+++	 * 		   <ul><li>If this object is a critter, the value will be a positive integer equal to the critter's
+++	 * 				   appearance, as determined by {@code SimpleCritter.getAppearance()}.</li>
+++	 * 		   <li>If this object is a rock, the value will be -1.</li>
+++	 * 		   <li>If the hex contains food, the value will be {@code -1 * ([food calories] + 1)}.</li.</ul>
+++	 */
+++	public int getAppearance();
+++}
++\ No newline at end of file
++diff --git a/src/main/resources/constants.txt b/src/main/resources/constants.txt
++new file mode 100644
++index 0000000..52649f0
++--- /dev/null
+++++ b/src/main/resources/constants.txt
++@@ -0,0 +1,19 @@
+++BASE_DAMAGE 100 {The multiplier for all damage done by attacking}
+++DAMAGE_INC 0.2 {Controls how quickly increased offensive or defensive ability affects damage}
+++ENERGY_PER_SIZE 500 {How much energy a critter can have per point of size}
+++FOOD_PER_SIZE 200 {How much food is created per point of size when a critter dies}
+++MAX_SMELL_DISTANCE 10 {Maximum distance at which food can be sensed}
+++ROCK_VALUE -1 {The value reported when a rock is sensed}
+++COLUMNS 50 {Default number of columns in the world map}
+++ROWS 68 {Default number of rows in the world map}
+++MAX_RULES_PER_TURN 999 {The maximum number of rules that can be run per critter turn}
+++SOLAR_FLUX 1 {Energy gained from sun by doing nothing}
+++MOVE_COST 3 {Energy cost of moving (per unit size)}
+++ATTACK_COST 5 {Energy cost of attacking (per unit size)}
+++GROW_COST 1 {Energy cost of growing (per size and complexity)}
+++BUD_COST 9 {Energy cost of budding (per unit complexity)}
+++MATE_COST 5 {Energy cost of successful mating (per unit complexity)}
+++RULE_COST 2 {Complexity cost of having a rule}
+++ABILITY_COST 25 {Complexity cost of having an ability point}
+++INITIAL_ENERGY 250 {Energy of a newly birthed critter}
+++MIN_MEMORY 8 {Minimum number of memory entries in a critter}
++\ No newline at end of file
++diff --git a/src/main/resources/world.txt b/src/main/resources/world.txt
++new file mode 100644
++index 0000000..91bdd68
++--- /dev/null
+++++ b/src/main/resources/world.txt
++@@ -0,0 +1,14 @@
+++name Small world
+++size 10 15
+++rock 2 2
+++rock 3 6
+++rock 9 10
+++
+++// Some food
+++food 4 4 500
+++food 1 3 1000
+++
+++// example-critter.txt should be in the working directory
+++critter example-critter.txt 2 5 3
+++critter example-critter.txt 4 3 1
+++critter example-critter.txt 4 4 2
++diff --git a/src/test/java/asttests/RemoveTest.java b/src/test/java/asttests/RemoveTest.java
++deleted file mode 100644
++index 86ace0d..0000000
++--- a/src/test/java/asttests/RemoveTest.java
+++++ /dev/null
++@@ -1,118 +0,0 @@
++-package asttests;
++-
++-import static org.junit.Assert.*;
++-
++-import java.util.LinkedList;
++-import org.junit.Test;
++-
++-import ast.*;
++-import ast.BinaryCondition.Operator;
++-import ast.BinaryExpr.MathOp;
++-import ast.Relation.RelOp;
++-import ast.UnaryExpr.ExprType;
++-
++-/**
++- * 
++- * RemoveTest tests the remove function for the different Node types.
++- *
++- */
++-public class RemoveTest
++-{	
++-	@Test
++-	public void testUpdate1()
++-	{
++-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
++-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
++-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
++-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
++-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
++-		Command c = new Command(ll, u6);
++-		
++-		int previousSize = c.size();
++-		u2.acceptMutation(new MutationRemove(true));
++-		assertTrue(previousSize > c.size());
++-		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
++-	}
++-	
++-	@Test
++-	public void testUpdate2()
++-	{
++-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		ll.add(u);
++-		Command c = new Command(ll, u2);
++-		
++-		int previousSize = c.size();
++-		u2.acceptMutation(new MutationRemove(true));
++-		assertTrue(previousSize > c.size());
++-		assertTrue(c.toString().equals(u.toString()));
++-	}
++-	
++-	@Test
++-	public void testUpdate3()
++-	{
++-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		ll.add(u);
++-		Command c = new Command(ll, u2);
++-		
++-		int previousSize = c.size();
++-		u.acceptMutation(new MutationRemove(true));
++-		assertTrue(previousSize > c.size());
++-		assertTrue(c.toString().equals(u2.toString()));
++-	}
++-	@Test
++-	public void testChildlessUnaryExpr()
++-	{
++-		UnaryExpr ue = new UnaryExpr(3);
++-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
++-		String before = be.toString();
++-		ue.acceptMutation(new MutationRemove(true));
++-		assertTrue(before.equals(be.toString()));
++-	}
++-	
++-	@Test
++-	public void testUnaryExpr()
++-	{
++-		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
++-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
++-		
++-		int previousSize = be.size();
++-		String before = be.toString();
++-		ue.acceptMutation(new MutationRemove(true));
++-		assertTrue(previousSize > be.size());
++-		assertTrue("3 + 2".equals(be.toString()));
++-	}
++-	
++-	@Test
++-	public void testCondition()
++-	{
++-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
++-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++-		UnaryExpr e1 = new UnaryExpr(2);
++-		UnaryExpr e2 = new UnaryExpr(12);
++-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
++-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
++-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
++-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
++-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		LinkedList<Update> ll = new LinkedList<Update>();
++-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++-		ll.add(u2);
++-		ll.add(u3);
++-		ll.add(u4);
++-		Command c = new Command(ll, u);
++-		Rule rule = new Rule(con, c);
++-		
++-		con.acceptMutation(new MutationRemove(true));
++-		Rule predictedMutatedRule = new Rule(r1, c);
++-		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
++-	}
++-}
++\ No newline at end of file
++diff --git a/src/test/java/interpretertests/EvalSensingTest.java b/src/test/java/interpretertests/EvalSensingTest.java
++new file mode 100644
++index 0000000..ac1c857
++--- /dev/null
+++++ b/src/test/java/interpretertests/EvalSensingTest.java
++@@ -0,0 +1,120 @@
+++package interpretertests;
+++
+++import static org.junit.Assert.*;
+++
+++import org.junit.Before;
+++
+++import ast.*;
+++import ast.BinaryCondition.Operator;
+++import ast.BinaryExpr.MathOp;
+++import ast.Relation.RelOp;
+++import ast.UnaryExpr.ExprType;
+++import console.Console;
+++import interpret.Interpreter;
+++import interpret.InterpreterImpl;
+++import simulation.Critter;
+++import simulation.World;
+++
+++import org.junit.Test;
+++
+++public class EvalSensingTest
+++{
+++	int[] arr = {3, 5};
+++	Interpreter i;
+++	
+++	@Before
+++	public void setUp()
+++	{
+++		i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+++	}
+++	
+++	@Test
+++	public void testEvalBinaryCondition()
+++	{
+++		UnaryExpr e1 = new UnaryExpr(2);
+++		UnaryExpr e2 = new UnaryExpr(12);
+++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+++		
+++		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
+++		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
+++		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
+++		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
+++		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
+++		
+++		assertTrue(new BinaryCondition(r1, Operator.AND, r2).acceptEvaluation(i));
+++		assertTrue(new BinaryCondition(r1, Operator.OR, r2).acceptEvaluation(i));
+++		assertTrue(new BinaryCondition(r1, Operator.OR, r3).acceptEvaluation(i));
+++		assertFalse(new BinaryCondition(r1, Operator.AND, r3).acceptEvaluation(i));
+++		assertFalse(new BinaryCondition(r3, Operator.AND, r4).acceptEvaluation(i));
+++		assertFalse(new BinaryCondition(r5, Operator.OR, r3).acceptEvaluation(i));
+++	}
+++
+++	@Test
+++	public void testEvalRelation()
+++	{
+++		int[] arr = {3, 5};
+++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+++		UnaryExpr e1 = new UnaryExpr(2);
+++		UnaryExpr e2 = new UnaryExpr(12);
+++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+++		
+++		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
+++		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
+++		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
+++		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
+++		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
+++		assertTrue(r1.acceptEvaluation(i));
+++		assertTrue(r2.acceptEvaluation(i));
+++		assertFalse(r3.acceptEvaluation(i));
+++		assertTrue(r4.acceptEvaluation(i));
+++		assertFalse(r5.acceptEvaluation(i));
+++	}
+++
+++	@Test
+++	public void testEvalBinaryExpr()
+++	{
+++		int[] arr = {3, 5};
+++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+++		UnaryExpr e1 = new UnaryExpr(2);
+++		UnaryExpr e2 = new UnaryExpr(12);
+++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+++		
+++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+++		assertEquals(e3.acceptEvaluation(i), 24);
+++		assertEquals(e4.acceptEvaluation(i), -24);
+++		assertEquals(e5.acceptEvaluation(i), 73);
+++		assertEquals(e6.acceptEvaluation(i), -3);
+++	}
+++
+++	@Test
+++	public void testEvalUnaryExpr()
+++	{
+++		int[] arr = {3, 5};
+++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+++		
+++		UnaryExpr e1 = new UnaryExpr(123123);
+++		UnaryExpr e2 = new UnaryExpr(253);
+++		
+++		assertEquals(123123, e1.acceptEvaluation(i));
+++		assertEquals(253, e2.acceptEvaluation(i));
+++	}
+++	
+++	@Test
+++	/** If the critter in this world senses the world boundary, it will backup. */
+++	public void testSenseWorldEdge()
+++	{
+++		Console c = new Console();
+++		c.loadWorld("src/test/resources/simulationTests/SensingWorld.txt");
+++		c.worldInfo();
+++		c.advanceTime(1);
+++		c.worldInfo();
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/test/java/mutationtests/TestMutateDuplicate.java b/src/test/java/mutationtests/TestMutateDuplicate.java
++index 3bc10ca..5d75a27 100644
++--- a/src/test/java/mutationtests/TestMutateDuplicate.java
+++++ b/src/test/java/mutationtests/TestMutateDuplicate.java
++@@ -13,13 +13,11 @@ import ast.MutationReplace;
++ import ast.Program;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ 
++ /**
++- * 
++  * This test class essentially tests the Duplicate Mutation by applying the Duplicate Mutation to random nodes 
++  * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
++- *
++  */
++ public class TestMutateDuplicate {
++ 
++@@ -27,7 +25,7 @@ public class TestMutateDuplicate {
++ 
++ 	@Before
++ 	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++ 		Reader r = new BufferedReader(new InputStreamReader(in));
++ 		Parser p = ParserFactory.getParser();
++ 		prog = p.parse(r);
++diff --git a/src/test/java/mutationtests/TestMutateInsert.java b/src/test/java/mutationtests/TestMutateInsert.java
++index 7e07e96..e1a07bd 100644
++--- a/src/test/java/mutationtests/TestMutateInsert.java
+++++ b/src/test/java/mutationtests/TestMutateInsert.java
++@@ -19,7 +19,7 @@ import ast.Sensor;
++ import ast.UnaryExpr;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ 
++ /**
++  * 
++@@ -32,7 +32,7 @@ public class TestMutateInsert {
++ 	Program prog;
++ 	@Before
++ 	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++         Reader r = new BufferedReader(new InputStreamReader(in));
++         Parser p = ParserFactory.getParser();
++         prog = p.parse(r);
++diff --git a/src/test/java/mutationtests/TestMutateRemove.java b/src/test/java/mutationtests/TestMutateRemove.java
++index 6128c76..f20e9c7 100644
++--- a/src/test/java/mutationtests/TestMutateRemove.java
+++++ b/src/test/java/mutationtests/TestMutateRemove.java
++@@ -1,48 +1,164 @@
++ package mutationtests;
++ 
+++import static org.junit.Assert.assertTrue;
+++
++ import java.io.BufferedReader;
++ import java.io.InputStream;
++ import java.io.InputStreamReader;
++ import java.io.Reader;
+++import java.util.LinkedList;
++ 
++ import org.junit.Before;
++ import org.junit.Test;
++ 
++ import ast.BinaryCondition;
+++import ast.BinaryExpr;
+++import ast.Command;
+++import ast.Condition;
++ import ast.MutationRemove;
++ import ast.Program;
+++import ast.Relation;
++ import ast.Rule;
+++import ast.UnaryExpr;
++ import ast.Update;
+++import ast.BinaryCondition.Operator;
+++import ast.BinaryExpr.MathOp;
+++import ast.Relation.RelOp;
+++import ast.UnaryExpr.ExprType;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ 
++ /**
++- * 
++- * This test class essentially tests the Remove Mutation by applying the Random Mutation to random nodes 
++- * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
++- *
+++ * This test class essentially tests the Remove Mutation by applying the mutation to random nodes in the
+++ * program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
++  */
++-public class TestMutateRemove {
+++public class TestMutateRemove
+++{
++ 	Program prog;
++ 
++ 	@Before
++-	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++	public void setup()
+++	{
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++ 		Reader r = new BufferedReader(new InputStreamReader(in));
++ 		Parser p = ParserFactory.getParser();
++ 		prog = p.parse(r);
++ 	}
++ 	
++ 	@Test
++-	public void testMutate() {
+++	public void testRandom()
+++	{
++ 		int n = 0;
++ 		for (int i = 0; i < prog.size(); i++)
+++		{
++ 			n = (int) (Math.random() * (prog.size()));
++-			try {
+++			try 
+++			{
++ 				System.out.println(prog.mutate(n, new MutationRemove(true)).toString());
++-			} catch (NullPointerException e) {
+++			}
+++			catch (NullPointerException e)
+++			{
++ 				 System.out.println("Incompatible node type");
++ 			}
+++		}
+++	}
+++	
+++	@Test
+++	public void testUpdate1()
+++	{
+++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+++		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
+++		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
+++		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
+++		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
+++		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+++		LinkedList<Update> ll = new LinkedList<Update>();
+++		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
+++		Command c = new Command(ll, u6);
+++		
+++		int previousSize = c.size();
+++		u2.acceptMutation(new MutationRemove(true));
+++		assertTrue(previousSize > c.size());
+++		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
+++	}
+++	
+++	@Test
+++	public void testUpdate2()
+++	{
+++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+++		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+++		LinkedList<Update> ll = new LinkedList<Update>();
+++		ll.add(u);
+++		Command c = new Command(ll, u2);
+++		
+++		int previousSize = c.size();
+++		u2.acceptMutation(new MutationRemove(true));
+++		assertTrue(previousSize > c.size());
+++		assertTrue(c.toString().equals(u.toString()));
+++	}
+++	
+++	@Test
+++	public void testUpdate3()
+++	{
+++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+++		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+++		LinkedList<Update> ll = new LinkedList<Update>();
+++		ll.add(u);
+++		Command c = new Command(ll, u2);
+++		
+++		int previousSize = c.size();
+++		u.acceptMutation(new MutationRemove(true));
+++		assertTrue(previousSize > c.size());
+++		assertTrue(c.toString().equals(u2.toString()));
+++	}
+++	@Test
+++	public void testChildlessUnaryExpr()
+++	{
+++		UnaryExpr ue = new UnaryExpr(3);
+++		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+++		String before = be.toString();
+++		ue.acceptMutation(new MutationRemove(true));
+++		assertTrue(before.equals(be.toString()));
+++	}
+++	
+++	@Test
+++	public void testUnaryExpr()
+++	{
+++		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
+++		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+++		
+++		int previousSize = be.size();
+++		String before = be.toString();
+++		ue.acceptMutation(new MutationRemove(true));
+++		assertTrue(previousSize > be.size());
+++		assertTrue("3 + 2".equals(be.toString()));
+++	}
+++	
+++	@Test
+++	public void testCondition()
+++	{
+++		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
+++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+++		UnaryExpr e1 = new UnaryExpr(2);
+++		UnaryExpr e2 = new UnaryExpr(12);
+++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+++		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
+++		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
+++		Condition con = new BinaryCondition(r1, Operator.AND, r2);
+++		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
+++		LinkedList<Update> ll = new LinkedList<Update>();
+++		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+++		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+++		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+++		ll.add(u2);
+++		ll.add(u3);
+++		ll.add(u4);
+++		Command c = new Command(ll, u);
+++		Rule rule = new Rule(con, c);
+++		
+++		con.acceptMutation(new MutationRemove(true));
+++		Rule predictedMutatedRule = new Rule(r1, c);
+++		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
++ 	}
++ }
++diff --git a/src/test/java/mutationtests/TestMutateReplace.java b/src/test/java/mutationtests/TestMutateReplace.java
++index 22513a6..5f70bb3 100644
++--- a/src/test/java/mutationtests/TestMutateReplace.java
+++++ b/src/test/java/mutationtests/TestMutateReplace.java
++@@ -13,7 +13,7 @@ import ast.MutationTransform;
++ import ast.Program;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ 
++ /**
++  * 
++@@ -27,7 +27,7 @@ public class TestMutateReplace {
++ 
++ 	@Before
++ 	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++ 		Reader r = new BufferedReader(new InputStreamReader(in));
++ 		Parser p = ParserFactory.getParser();
++ 		prog = p.parse(r);
++diff --git a/src/test/java/mutationtests/TestMutateSwap.java b/src/test/java/mutationtests/TestMutateSwap.java
++index 3e4206a..d5b046b 100644
++--- a/src/test/java/mutationtests/TestMutateSwap.java
+++++ b/src/test/java/mutationtests/TestMutateSwap.java
++@@ -17,7 +17,7 @@ import ast.MutationInsert;
++ import ast.BinaryExpr.*;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ import ast.MutationSwap;
++ import ast.Program;
++ import ast.UnaryExpr;
++@@ -34,7 +34,7 @@ public class TestMutateSwap {
++ 	Program prog;
++ 	@Before
++ 	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++         Reader r = new BufferedReader(new InputStreamReader(in));
++         Parser p = ParserFactory.getParser();
++         prog = p.parse(r);
++diff --git a/src/test/java/mutationtests/TestMutateTransform.java b/src/test/java/mutationtests/TestMutateTransform.java
++index ee87cca..4011203 100644
++--- a/src/test/java/mutationtests/TestMutateTransform.java
+++++ b/src/test/java/mutationtests/TestMutateTransform.java
++@@ -23,7 +23,7 @@ import ast.UnaryExpr;
++ import ast.Update;
++ import parse.Parser;
++ import parse.ParserFactory;
++-import parsertests.ParserTest;
+++import parsertests.ASTParserTest;
++ 
++ /**
++  * 
++@@ -37,7 +37,7 @@ public class TestMutateTransform {
++ 
++ 	@Before
++ 	public void setup() {
++-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
++ 		Reader r = new BufferedReader(new InputStreamReader(in));
++ 		Parser p = ParserFactory.getParser();
++ 		prog = p.parse(r);
++diff --git a/src/test/java/parsertests/ParserTest.java b/src/test/java/parsertests/ASTParserTest.java
++similarity index 92%
++rename from src/test/java/parsertests/ParserTest.java
++rename to src/test/java/parsertests/ASTParserTest.java
++index 4d3711c..2789d73 100644
++--- a/src/test/java/parsertests/ParserTest.java
+++++ b/src/test/java/parsertests/ASTParserTest.java
++@@ -15,19 +15,19 @@ import parse.ParserFactory;
++ import parse.Tokenizer;
++ 
++ /** This class contains tests for the Critter parser. */
++-public class ParserTest
+++public class ASTParserTest
++ {
++     /** Checks that a valid critter program is not {@code null} when parsed. 
++      * Different test cases were run using this same method by changing the filename for the input stream
++      * This methodology was implemented because the program terminates elsewhere in the program, so the 
++      * remainder of the tests cannot be performed. A key of the filename and the type of error it tests is included
++      * in the overview.
++-     * */
+++     */
++ 	
++     @Test
++     public void testProgramIsNotNull()
++     {
++-        InputStream in = ParserTest.class.getResourceAsStream("draw_critter.txt");
+++        InputStream in = ASTParserTest.class.getResourceAsStream("draw_critter.txt");
++         Reader r = new BufferedReader(new InputStreamReader(in));
++         Parser p = ParserFactory.getParser();
++         Program prog = p.parse(r);
++diff --git a/src/test/java/parsertests/FileParserTest.java b/src/test/java/parsertests/FileParserTest.java
++new file mode 100644
++index 0000000..52571a2
++--- /dev/null
+++++ b/src/test/java/parsertests/FileParserTest.java
++@@ -0,0 +1,149 @@
+++package parsertests;
+++
+++import static org.junit.Assert.*;
+++import java.io.*;
+++import org.junit.Test;
+++
+++import ast.Program;
+++import parse.Parser;
+++import parse.ParserFactory;
+++import simulation.Critter;
+++import simulation.FileParser;
+++import simulation.SimpleCritter;
+++
+++public class FileParserTest
+++{
+++
+++	@Test
+++	public void testParseAttributes1()
+++	{
+++		try
+++		{
+++			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/example-critter.txt")));
+++			
+++			assertEquals(test.length, 7);
+++			assertTrue(test[0].equals("example"));
+++			assertTrue(test[1].equals("9"));
+++			assertTrue(test[2].equals("2"));
+++			assertTrue(test[3].equals("3"));
+++			assertTrue(test[4].equals("1"));
+++			assertTrue(test[5].equals("500"));
+++			assertTrue(test[6].equals("17"));
+++		}
+++		catch (FileNotFoundException e)
+++		{
+++			fail();
+++		}
+++	}
+++	
+++	@Test
+++	public void testParseAttributes2()
+++	{
+++		try
+++		{
+++			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/failure-example-critter1.txt")));
+++			
+++			assertEquals(test.length, 7);
+++			assertTrue(test[0].equals(""));
+++			assertTrue(test[1].equals(""));
+++			assertTrue(test[2].equals(""));
+++			assertTrue(test[3].equals(""));
+++			assertTrue(test[4].equals(""));
+++			assertTrue(test[5].equals(""));
+++			assertTrue(test[6].equals(""));
+++		}
+++		catch (FileNotFoundException e)
+++		{
+++			fail();
+++		}
+++	}
+++	
+++	@Test
+++	public void testConsoleLoad() //TODO remove when done testing
+++	{
+++		try
+++		{
+++			BufferedReader br = new BufferedReader(new FileReader("examples/example-critter.txt"));
+++			String[] parsed = FileParser.parseAttributes(br);
+++			String name = parsed[0].equals("") ? "Untitled" : parsed[0];
+++			int[] critAttr = makeCritterAttributes(parsed);
+++			
+++			Parser p = ParserFactory.getParser();
+++			Program prog = p.parse(br);
+++			
+++			SimpleCritter sc = new Critter(prog, critAttr, name, -1);
+++		}
+++		catch (FileNotFoundException e)
+++		{
+++			System.err.println("Critter file not found.");
+++			return;
+++		}
+++	}
+++	
+++	/**
+++	 * Prepares an int array to be used as critter memory, based on a string array.<br>
+++	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
+++	 * @param strs an array of strings created by the method {@code FileParser.parseAttributes(filename)}
+++	 * @return an int array, ready to be used as critter memory
+++	 */
+++	private int[] makeCritterAttributes(String[] strs)
+++	{
+++		int[] critterAttributes;
+++		
+++		int memsize = parseIntFromString(strs[1]);
+++		if(memsize < 8)
+++			memsize = 8;
+++		critterAttributes = new int[memsize];
+++		critterAttributes[0] = memsize;
+++		
+++		int defense = parseIntFromString(strs[2]);
+++		if(defense < 0)
+++			defense = 3;
+++		critterAttributes[1] = defense;
+++		
+++		int offense = parseIntFromString(strs[3]);
+++		if(offense < 0)
+++		offense = 3;
+++		critterAttributes[2] = offense;
+++		
+++		int size = parseIntFromString(strs[4]);
+++		if(size < 0)
+++			size = 1;
+++		critterAttributes[3] = size;
+++		
+++		int energy = parseIntFromString(strs[5]);
+++		if(energy < 0)
+++			energy = 500;
+++		critterAttributes[4] = energy;
+++		
+++		int pass = 0;
+++		critterAttributes[5] = pass;
+++		
+++		int tag = 0;
+++		critterAttributes[6] = tag;
+++		
+++		int posture = parseIntFromString(strs[6]);
+++		if(posture < 0 || posture > 99)
+++			posture = 0;
+++		critterAttributes[7] = posture;
+++		
+++		return critterAttributes;
+++	}
+++	
+++	/**
+++	 * Parses an integer value from a given string, or returns -1 if no integer was found.
+++	 * @param s the string to parse
+++	 * @return the int parsed from the string, or -1 if no integer was found
+++	 */
+++	private int parseIntFromString(String s)
+++	{
+++		try
+++		{
+++			return Integer.parseInt(s);
+++		}
+++		catch (NumberFormatException n)
+++		{
+++			return -1;
+++		}
+++	}
+++}
++\ No newline at end of file
++diff --git a/src/test/java/simulationTests/AttackTests.java b/src/test/java/simulationTests/AttackTests.java
++new file mode 100644
++index 0000000..2859cb7
++--- /dev/null
+++++ b/src/test/java/simulationTests/AttackTests.java
++@@ -0,0 +1,28 @@
+++package simulationTests;
+++
+++import org.junit.Before;
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class AttackTests {
+++
+++	Console console1 = null;
+++	
+++	@Before
+++	 public void setup() {
+++		 console1 = new Console();
+++		 console1.loadWorld("src/test/resources/simulationTests/AttackWorld.txt");
+++	 }
+++	
+++	/**
+++	 * testBasicAttack tests attack by having a massive critter attack a tiny critter. The smaller critter
+++	 * should die.
+++	 */
+++	@Test
+++	public void testBasicAttack() {
+++		console1.worldInfo();
+++		console1.advanceTime(1);
+++		console1.worldInfo();
+++	}
+++}
++diff --git a/src/test/java/simulationTests/BudTest.java b/src/test/java/simulationTests/BudTest.java
++new file mode 100644
++index 0000000..e24891d
++--- /dev/null
+++++ b/src/test/java/simulationTests/BudTest.java
++@@ -0,0 +1,67 @@
+++package simulationTests;
+++
+++import static org.junit.Assert.*;
+++
+++import org.junit.Before;
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class BudTest {
+++
+++	Console console1 = null;
+++	Console console2 = null;
+++	Console console3 = null;
+++
+++	@Before
+++	public void setup() {
+++		console1 = new Console();
+++		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
+++		console2 = new Console();
+++		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
+++		console3 = new Console();
+++		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
+++	}
+++
+++	/**
+++	 * testBasicBud checks to see if a critter can bud under normal circumstances.
+++	 */
+++	@Test
+++	public void testBasicBud() {
+++		System.out.println("testBasicBud");
+++		int initialNumCritters = console1.crittersAlive();
+++		console1.worldInfo();
+++		console1.advanceTime(1);
+++		console1.worldInfo();
+++		assertEquals(initialNumCritters + 1, console1.crittersAlive());
+++	}
+++
+++	/**
+++	 * testBudWithRock checks to see that a critter does not bud when there is a
+++	 * rock behind it.
+++	 */
+++	@Test
+++	public void testBudWithRock() {
+++		System.out.println("testBudWithRock");
+++		int initialNumCritters = console2.crittersAlive();
+++		console2.worldInfo();
+++		console2.advanceTime(1);
+++		console2.worldInfo();
+++		assertEquals(initialNumCritters, console2.crittersAlive());
+++	}
+++
+++	/**
+++	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
+++	 * It also tests to see if critter death properly adds a food object onto the site of death.
+++	 */
+++	@Test
+++	public void testBudNoEnergy() {
+++		System.out.println("testBudNoEnergy");
+++		int initialNumCritters = console3.crittersAlive();
+++		console3.worldInfo();
+++		console3.advanceTime(1);
+++		console3.worldInfo();
+++		assertEquals(initialNumCritters - 1, console3.crittersAlive());
+++	}
+++
+++}
++diff --git a/src/test/java/simulationTests/MateTest.java b/src/test/java/simulationTests/MateTest.java
++new file mode 100644
++index 0000000..7c6efad
++--- /dev/null
+++++ b/src/test/java/simulationTests/MateTest.java
++@@ -0,0 +1,83 @@
+++package simulationTests;
+++
+++import org.junit.Before;
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class MateTest {
+++	Console console1 = null;
+++	Console console2 = null;
+++	Console console3 = null;
+++	Console console4 = null;
+++	
+++	@Before
+++	public void setUp()
+++	{
+++		console1 = new Console();
+++		console1.loadWorld("src/test/resources/simulationTests/MateWorld.txt");
+++		console2 = new Console();
+++		console2.loadWorld("src/test/resources/simulationTests/MateWorldRock.txt");
+++		console3 = new Console();
+++		console3.loadWorld("src/test/resources/simulationTests/MateWorldLittleEnergy.txt");
+++		console4 = new Console();
+++		console4.loadWorld("src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt");
+++	}
+++	
+++	/**
+++	 * simpleTest tests to see if two critters who want to mate can mate and create an offspring.
+++	 */
+++	
+++	
+++	@Test
+++	public void simpleTest() {
+++		System.out.println("simpleTest");
+++		console1.worldInfo();
+++		console1.advanceTime(1);
+++		console1.worldInfo();
+++	}
+++	
+++	
+++	/**
+++	 * mateWithRock tests to see what happens when a couple of critters tries to mate but with a rock behind one of
+++	 * them. The mating works if the baby is put behind the critter that is not in front of the rock, and the baby dies
+++	 * if it is placed on the rock. 
+++	 */
+++	
+++	@Test
+++	public void mateWithRock() {
+++		System.out.println("mateWithRock");
+++		console2.worldInfo();
+++		console2.advanceTime(1);
+++		console2.worldInfo();
+++	}
+++	
+++	/**
+++	 * mateLittleEnergy checks to see what happens to the parents when they try to mate when they
+++	 * do not have enough energy. The parents then die. 
+++	 */
+++	@Test
+++	public void mateLittleEnergy() {
+++		System.out.println("mateLittleEnergy");
+++		console3.worldInfo();
+++		console3.advanceTime(1);
+++		console3.worldInfo();
+++	}
+++	
+++	
+++	
+++	/**
+++	 * mateDifferentTimeStep checks to see what happens when two parents want to mate, but they
+++	 * want to mate on different time steps. While one of the parents wants to mate, the other one waits
+++	 * and vice versa. As a result, the parents should not be able to mate. During this test, wait is also
+++	 * tested in this test.
+++	 */
+++	@Test
+++	public void mateDifferentTimeStep() {
+++		System.out.println("mateDifferentTimeStep");
+++		console4.worldInfo();
+++		console4.advanceTime(17);
+++		console4.worldInfo();
+++	}
+++	
+++}
++diff --git a/src/test/java/simulationTests/MovingTest.java b/src/test/java/simulationTests/MovingTest.java
++new file mode 100644
++index 0000000..18ff962
++--- /dev/null
+++++ b/src/test/java/simulationTests/MovingTest.java
++@@ -0,0 +1,74 @@
+++package simulationTests;
+++
+++import static org.junit.Assert.*;
+++
+++import org.junit.Before;
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class MovingTest
+++{
+++	Console console1 = null;
+++	Console console2 = null;
+++	Console console3 = null;
+++	Console console4 = null;
+++	
+++	@Before
+++	public void setUp()
+++	{
+++		console1 = new Console();
+++		console1.loadWorld("src/test/resources/simulationTests/MovingWorld.txt");
+++		console2 = new Console();
+++		console2.loadWorld("src/test/resources/simulationTests/MovingWorldFileRock.txt");
+++		console3 = new Console();
+++		console3.loadWorld("src/test/resources/simulationTests/MovingWorldThree.txt");
+++		console4 = new Console();
+++		console4.loadWorld("src/test/resources/simulationTests/MovingWorldFour.txt");
+++		
+++	}
+++	/**
+++	 * testNormalMove tests to see if moving forward normally works.
+++	 */
+++	@Test
+++	public void testNormalMove()
+++	{
+++		System.out.println("testNormalMove");
+++		console1.worldInfo();
+++		console1.advanceTime(1);
+++		console1.worldInfo();
+++	}
+++	
+++	/**
+++	 * testMoveWithRock tests to see that critter won't move when there is a rock in front of it.
+++	 */
+++	@Test
+++	public void testMoveWithRock() {
+++		System.out.println("testMoveWithRock");
+++		console2.worldInfo();
+++		console2.advanceTime(1);
+++		console2.worldInfo();
+++	}
+++	
+++	/**
+++	 * testMovingWithNoEnergy tests to see that a critter without enough energy to move dies.
+++	 */
+++	@Test
+++	public void testMovingWithNoEnergy() {
+++		System.out.println("testMovingWithNoEnergy");
+++		console3.worldInfo();
+++		console3.advanceTime(1);
+++		console3.worldInfo();
+++	}
+++
+++	/**
+++	 * testMoveInvalidLocation checks to see if a critter does not move to an invalid location
+++	 */
+++	@Test
+++	public void testMovingInvalidLocation() {
+++		System.out.println("testMovingInvalidLocation");
+++		console4.worldInfo();
+++		console4.advanceTime(1);
+++		console4.worldInfo();
+++	}
+++}
++diff --git a/src/test/java/simulationTests/SpiralCritterTest.java b/src/test/java/simulationTests/SpiralCritterTest.java
++new file mode 100644
++index 0000000..18af1b3
++--- /dev/null
+++++ b/src/test/java/simulationTests/SpiralCritterTest.java
++@@ -0,0 +1,29 @@
+++package simulationTests;
+++
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class SpiralCritterTest
+++{
+++
+++	@Test
+++	/** 
+++	 * There isn't really any world functionality that allows us to perform automated testing for the spiral critter in any
+++	 * practical way, so we just used this simple test and analyzed the successive printouts of the world grid after each
+++	 * successive turn.
+++	 */
+++	public void test()
+++	{
+++		Console c = new Console();
+++		c.loadWorld("src/test/resources/simulationTests/SpiralCritterWorld.txt");
+++		c.worldInfo();
+++		
+++		for(int i = 0; i < 60; i++)
+++		{
+++			c.advanceTime(1);
+++			c.worldInfo();
+++		}
+++	}
+++
+++}
++diff --git a/src/test/java/simulationTests/TurnAndNearbyTests.java b/src/test/java/simulationTests/TurnAndNearbyTests.java
++new file mode 100644
++index 0000000..a1aa66a
++--- /dev/null
+++++ b/src/test/java/simulationTests/TurnAndNearbyTests.java
++@@ -0,0 +1,48 @@
+++package simulationTests;
+++
+++import org.junit.Before;
+++import org.junit.Test;
+++
+++import console.Console;
+++
+++public class TurnAndNearbyTests {
+++
+++	Console console1 = null;
+++	Console console2 = null;
+++	Console console3 = null;
+++	Console console4 = null;
+++
+++	@Before
+++	public void setUp() {
+++		console1 = new Console();
+++		console1.loadWorld("src/test/resources/simulationTests/TurnWorldTwo.txt");
+++		console2 = new Console();
+++		console2.loadWorld("src/test/resources/simulationTests/TurnNearbyWorld.txt");
+++
+++	}
+++
+++	/**
+++	 * simpleTurn checks to see if a critter can turn right and left properly
+++	 */
+++	@Test
+++	public void simpleTurn() {
+++		System.out.println("simpleTurn");
+++		console1.worldInfo();
+++		console1.advanceTime(1);
+++		console1.worldInfo();
+++	}
+++
+++	/**
+++	 * turnIfFood tests to see if a critter can turn if there is food right next to it. Nearby was
+++	 * also tested by placing the food at different points around the critter and having the critter turn if
+++	 * it can sense it. As a result, this test covers both functionalities. 
+++	 */
+++	
+++	@Test
+++	public void turnIfFood() {
+++		System.out.println("turnIfFood");
+++		console2.worldInfo();
+++		console2.advanceTime(1);
+++		console2.worldInfo();
+++	}
+++}
++diff --git a/src/test/resources/simulationTests/AttackCritter1.txt b/src/test/resources/simulationTests/AttackCritter1.txt
++new file mode 100644
++index 0000000..efa20bd
++--- /dev/null
+++++ b/src/test/resources/simulationTests/AttackCritter1.txt
++@@ -0,0 +1,8 @@
+++species: Attack Critter 2
+++memsize: 11
+++defense: 2
+++offense: 3000
+++size: 50
+++energy: 50000
+++posture: 17
+++3 = 3 --> attack;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/AttackCritter2.txt b/src/test/resources/simulationTests/AttackCritter2.txt
++new file mode 100644
++index 0000000..5b14f81
++--- /dev/null
+++++ b/src/test/resources/simulationTests/AttackCritter2.txt
++@@ -0,0 +1,8 @@
+++species: Attack Critter 2
+++memsize: 11
+++defense: 1
+++offense: 3
+++size: 1
+++energy: 5
+++posture: 17
+++3 = 3 --> wait;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/AttackWorld.txt b/src/test/resources/simulationTests/AttackWorld.txt
++new file mode 100644
++index 0000000..d1151bb
++--- /dev/null
+++++ b/src/test/resources/simulationTests/AttackWorld.txt
++@@ -0,0 +1,5 @@
+++name Attack World 
+++size 5 10
+++
+++critter src/test/resources/simulationTests/AttackCritter1.txt 3 4 0
+++critter src/test/resources/simulationTests/AttackCritter2.txt 3 5 3
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/BudCritter.txt b/src/test/resources/simulationTests/BudCritter.txt
++new file mode 100644
++index 0000000..18fcd09
++--- /dev/null
+++++ b/src/test/resources/simulationTests/BudCritter.txt
++@@ -0,0 +1,8 @@
+++species: example
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 5000000
+++posture: 17
+++3 = 3 --> bud;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/BudCritterNoEnergy.txt b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
++new file mode 100644
++index 0000000..f289ce6
++--- /dev/null
+++++ b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
++@@ -0,0 +1,8 @@
+++species: example
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 200
+++posture: 17
+++3 = 3 --> bud;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/BudWorld.txt b/src/test/resources/simulationTests/BudWorld.txt
++new file mode 100644
++index 0000000..f606bf2
++--- /dev/null
+++++ b/src/test/resources/simulationTests/BudWorld.txt
++@@ -0,0 +1,4 @@
+++name Bud World 1
+++size 5 10
+++
+++critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/BudWorld3.txt b/src/test/resources/simulationTests/BudWorld3.txt
++new file mode 100644
++index 0000000..aea4f1b
++--- /dev/null
+++++ b/src/test/resources/simulationTests/BudWorld3.txt
++@@ -0,0 +1,4 @@
+++name Bud World 3
+++size 5 10
+++
+++critter src/test/resources/simulationTests/BudCritterNoEnergy.txt 3 5 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/BudWorldRock.txt b/src/test/resources/simulationTests/BudWorldRock.txt
++new file mode 100644
++index 0000000..e3bed1c
++--- /dev/null
+++++ b/src/test/resources/simulationTests/BudWorldRock.txt
++@@ -0,0 +1,4 @@
+++name Bud World 2
+++size 5 10
+++rock 3 4
+++critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MateWorld.txt b/src/test/resources/simulationTests/MateWorld.txt
++new file mode 100644
++index 0000000..62ea1a2
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MateWorld.txt
++@@ -0,0 +1,5 @@
+++name Mate World 
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
+++critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
++new file mode 100644
++index 0000000..127dfcd
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
++@@ -0,0 +1,5 @@
+++name Mate World Different Time Steps
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MatingParent5.txt 3 4 0
+++critter src/test/resources/simulationTests/MatingParent6.txt 3 5 3
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MateWorldLittleEnergy.txt b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
++new file mode 100644
++index 0000000..7fe7a11
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
++@@ -0,0 +1,5 @@
+++name Mate World Little Energy
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MatingParent3.txt 3 4 0
+++critter src/test/resources/simulationTests/MatingParent4.txt 3 5 3
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MateWorldRock.txt b/src/test/resources/simulationTests/MateWorldRock.txt
++new file mode 100644
++index 0000000..5c3b717
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MateWorldRock.txt
++@@ -0,0 +1,5 @@
+++name Mate World Rock
+++size 5 10
+++rock 3 6
+++critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
+++critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent1.txt b/src/test/resources/simulationTests/MatingParent1.txt
++new file mode 100644
++index 0000000..f64bca0
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent1.txt
++@@ -0,0 +1,8 @@
+++species: Parent 1
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 5
+++energy: 50000
+++posture: 17
+++3 = 3 --> mate;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent2.txt b/src/test/resources/simulationTests/MatingParent2.txt
++new file mode 100644
++index 0000000..15b068a
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent2.txt
++@@ -0,0 +1,8 @@
+++species: Parent 2
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 5
+++energy: 50000
+++posture: 17
+++3 = 3 --> mate;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent3.txt b/src/test/resources/simulationTests/MatingParent3.txt
++new file mode 100644
++index 0000000..1944f06
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent3.txt
++@@ -0,0 +1,8 @@
+++species: Parent 3
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 50000
+++posture: 17
+++3 = 3 --> mate;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent4.txt b/src/test/resources/simulationTests/MatingParent4.txt
++new file mode 100644
++index 0000000..e740384
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent4.txt
++@@ -0,0 +1,8 @@
+++species: Parent 4
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 50000
+++posture: 17
+++3 = 3 --> mate;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent5.txt b/src/test/resources/simulationTests/MatingParent5.txt
++new file mode 100644
++index 0000000..6f0890a
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent5.txt
++@@ -0,0 +1,9 @@
+++species: Parent 5
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 5
+++energy: 50000
+++posture: 17
+++mem[8] = 0 --> mem[8] := 1 wait;
+++mem[8] = 1 --> mem[8] := 0 mate;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MatingParent6.txt b/src/test/resources/simulationTests/MatingParent6.txt
++new file mode 100644
++index 0000000..b112422
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MatingParent6.txt
++@@ -0,0 +1,9 @@
+++species: Parent 6
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 5
+++energy: 50000
+++posture: 17
+++mem[8] = 0 --> mem[8] := 1 mate;
+++mem[8] = 1 --> mem[8] := 0 wait;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MovingCritter.txt b/src/test/resources/simulationTests/MovingCritter.txt
++new file mode 100644
++index 0000000..3bb2486
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingCritter.txt
++@@ -0,0 +1,8 @@
+++species: example
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 500
+++posture: 17
+++3 = 3 --> forward;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
++new file mode 100644
++index 0000000..1dc3af5
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
++@@ -0,0 +1,8 @@
+++species: example
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 2
+++posture: 17
+++3 = 3 --> forward;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MovingWorld.txt b/src/test/resources/simulationTests/MovingWorld.txt
++new file mode 100644
++index 0000000..6f1baea
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingWorld.txt
++@@ -0,0 +1,4 @@
+++name Moving World
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MovingWorldFileRock.txt b/src/test/resources/simulationTests/MovingWorldFileRock.txt
++new file mode 100644
++index 0000000..845f953
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingWorldFileRock.txt
++@@ -0,0 +1,4 @@
+++name Moving World2
+++size 5 10
+++rock 3 6
+++critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
++diff --git a/src/test/resources/simulationTests/MovingWorldFour.txt b/src/test/resources/simulationTests/MovingWorldFour.txt
++new file mode 100644
++index 0000000..c9a3ea8
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingWorldFour.txt
++@@ -0,0 +1,4 @@
+++name Moving World 4
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MovingCritter.txt 4 9 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/MovingWorldThree.txt b/src/test/resources/simulationTests/MovingWorldThree.txt
++new file mode 100644
++index 0000000..322aa54
++--- /dev/null
+++++ b/src/test/resources/simulationTests/MovingWorldThree.txt
++@@ -0,0 +1,4 @@
+++name Moving World 3
+++size 5 10
+++
+++critter src/test/resources/simulationTests/MovingCritterLittleEnergy.txt 3 5 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/SensingCritter.txt b/src/test/resources/simulationTests/SensingCritter.txt
++new file mode 100644
++index 0000000..dcb097b
++--- /dev/null
+++++ b/src/test/resources/simulationTests/SensingCritter.txt
++@@ -0,0 +1,9 @@
+++species: Sensing Critter
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 500
+++posture: 17
+++
+++ahead[1] = -1 --> backward;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
++new file mode 100644
++index 0000000..5abacf0
++--- /dev/null
+++++ b/src/test/resources/simulationTests/SensingWorld.txt
++@@ -0,0 +1,4 @@
+++name Sensing World 1
+++size 5 10
+++
+++critter SensingCritter.txt 4 9 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
++new file mode 100644
++index 0000000..7102f96
++--- /dev/null
+++++ b/src/test/resources/simulationTests/SpiralCritterWorld.txt
++@@ -0,0 +1,3 @@
+++name Spiral World
+++size 11 13
+++critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/TurnNearbyWorld.txt b/src/test/resources/simulationTests/TurnNearbyWorld.txt
++new file mode 100644
++index 0000000..64bb6c2
++--- /dev/null
+++++ b/src/test/resources/simulationTests/TurnNearbyWorld.txt
++@@ -0,0 +1,4 @@
+++name Turn World 1
+++size 5 10
+++food 3 3 500
+++critter src/test/resources/simulationTests/Turner1.txt 3 4 0
++diff --git a/src/test/resources/simulationTests/TurnWorldTwo.txt b/src/test/resources/simulationTests/TurnWorldTwo.txt
++new file mode 100644
++index 0000000..d53c1bb
++--- /dev/null
+++++ b/src/test/resources/simulationTests/TurnWorldTwo.txt
++@@ -0,0 +1,3 @@
+++name Turn World 1
+++size 5 10
+++critter src/test/resources/simulationTests/Turner2.txt 3 4 0
++diff --git a/src/test/resources/simulationTests/Turner1.txt b/src/test/resources/simulationTests/Turner1.txt
++new file mode 100644
++index 0000000..1647100
++--- /dev/null
+++++ b/src/test/resources/simulationTests/Turner1.txt
++@@ -0,0 +1,8 @@
+++species: Turner 1
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 50000
+++posture: 17
+++nearby[3] < -1 --> right;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/Turner2.txt b/src/test/resources/simulationTests/Turner2.txt
++new file mode 100644
++index 0000000..56f98be
++--- /dev/null
+++++ b/src/test/resources/simulationTests/Turner2.txt
++@@ -0,0 +1,8 @@
+++species: Turner 1
+++memsize: 11
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 50000
+++posture: 17
+++3 = 3  --> left;
++\ No newline at end of file
++diff --git a/src/test/resources/simulationTests/spiral_critter.txt b/src/test/resources/simulationTests/spiral_critter.txt
++new file mode 100644
++index 0000000..8da44ad
++--- /dev/null
+++++ b/src/test/resources/simulationTests/spiral_critter.txt
++@@ -0,0 +1,21 @@
+++species: Spiral
+++memsize: 12
+++defense: 2
+++offense: 3
+++size: 1
+++energy: 500
+++posture: 17
+++
+++//ensures that the critter has enough energy, and will eat food in its way
+++ENERGY <= SIZE * 3 --> wait;
+++ahead[1] < -1 --> eat;
+++
+++mem[9] = 0 --> mem[8] := mem[8] + 1 mem[9] := 1 forward;
+++
+++mem[9] = 1 and mem[10] = 0 --> mem[10] := mem[10] + 1 right;
+++mem[10] = 1 and mem[11] < mem[8] - 1 --> mem[11] := mem[11] + 1 forward;
+++mem[10] = 1 and mem[11] = mem[8] - 1 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+++
+++mem[11] < mem[8] --> mem[11] := mem[11] + 1 forward;
+++mem[11] = mem[8] and mem[10] < 6 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+++mem[10] = 6 and mem[9] = 1 --> mem[9] := 0 mem[10] := 0 mem[11] := 0;
++\ No newline at end of file
++diff --git a/world.txt b/world.txt
++new file mode 100644
++index 0000000..91bdd68
++--- /dev/null
+++++ b/world.txt
++@@ -0,0 +1,14 @@
+++name Small world
+++size 10 15
+++rock 2 2
+++rock 3 6
+++rock 9 10
+++
+++// Some food
+++food 4 4 500
+++food 1 3 1000
+++
+++// example-critter.txt should be in the working directory
+++critter example-critter.txt 2 5 3
+++critter example-critter.txt 4 3 1
+++critter example-critter.txt 4 4 2
+diff --git a/log.txt b/log.txt
+index 7aedfce..c324f63 100644
+--- a/log.txt
++++ b/log.txt
+@@ -1,122 +1,147 @@
+-[33mcommit fce536fec1b6d39c94b8eb25247226e99b89f023[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
++commit 06cb727814873d6888a15d8da8ad12d94cb8e408
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 23:26:00 2017 -0400
++
++    Testing Finished
++
++commit 0536fee80bfb57c1dac79b65123fbaa29a995502
++Merge: 221e8ca cb93ef2
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 23:09:59 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 221e8cafbb3634896fea5fd40c47cb06e9eb8172
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 23:09:32 2017 -0400
++
++    Attack Tests
++
++commit cb93ef26d11bd86c1a934f2a1b9d46993bb0cb53
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 22:49:26 2017 -0400
++
++    fix merge
++
++commit fce536fec1b6d39c94b8eb25247226e99b89f023
+ Merge: faaae27 41fe28e
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 22:47:22 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit faaae27e8751ae57808ad7b3b0819f7624e3e782[m
++commit faaae27e8751ae57808ad7b3b0819f7624e3e782
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 22:46:48 2017 -0400
+ 
+     Final tests
+ 
+-[33mcommit 41fe28e826698ca5cf3e31913bdf54842644b50c[m
++commit 41fe28e826698ca5cf3e31913bdf54842644b50c
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 22:44:40 2017 -0400
+ 
+     Testing Done
+ 
+-[33mcommit 3f34641d080ef40ea4dbab4d1980324643736d26[m
++commit 3f34641d080ef40ea4dbab4d1980324643736d26
+ Merge: 3631e4c 2e8bab8
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 21:38:55 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit 3631e4cef53d386e115ab7fa8364e9d22a95efe9[m
++commit 3631e4cef53d386e115ab7fa8364e9d22a95efe9
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 21:38:49 2017 -0400
+ 
+     Turning Tests
+ 
+-[33mcommit 2e8bab888d0b606f53dda0b449210c2f3996abdc[m
++commit 2e8bab888d0b606f53dda0b449210c2f3996abdc
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 21:35:36 2017 -0400
+ 
+     More Tests
+ 
+-[33mcommit 90fd50cc87b830aff15673e999c4cd22044a9543[m
++commit 90fd50cc87b830aff15673e999c4cd22044a9543
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 20:43:50 2017 -0400
+ 
+     Tests!
+ 
+-[33mcommit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5[m
++commit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 20:14:08 2017 -0400
+ 
+     SpiralCritter works now
+ 
+-[33mcommit 9bdbd6cc4f186af60209dce78176917924f76428[m
++commit 9bdbd6cc4f186af60209dce78176917924f76428
+ Merge: 4c6c2ee 4892088
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 16:57:49 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51[m
++commit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 16:57:41 2017 -0400
+ 
+     Minor fixes
+ 
+-[33mcommit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac[m
++commit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 15:37:39 2017 -0400
+ 
+     Mating Testing Final
+ 
+-[33mcommit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3[m
++commit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 15:31:26 2017 -0400
+ 
+     Mating Testing
+ 
+-[33mcommit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460[m
++commit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460
+ Merge: d3b6060 753823a
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 14:59:59 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit d3b60607e47ccc71ddb9a8a65f249e65e127bb22[m
++commit d3b60607e47ccc71ddb9a8a65f249e65e127bb22
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 14:58:53 2017 -0400
+ 
+     Mate Test Change
+ 
+-[33mcommit 9ca82f204cd008b0e3449775ebc042e96557f9a4[m
++commit 9ca82f204cd008b0e3449775ebc042e96557f9a4
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 14:57:30 2017 -0400
+ 
+     File Parser Update
+ 
+-[33mcommit ecdea17320fd143cf698fc9faa53d5b39131f071[m
++commit ecdea17320fd143cf698fc9faa53d5b39131f071
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 14:57:00 2017 -0400
+ 
+     Mate Testing Done and Bug Fixed
+ 
+-[33mcommit b669ff85cd406986cb387789b43c622d2fd53366[m
++commit b669ff85cd406986cb387789b43c622d2fd53366
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 13:11:19 2017 -0400
+ 
+     Mate Testing
+ 
+-[33mcommit b24dcaeecb0961141406915da0977e58847259c1[m
++commit b24dcaeecb0961141406915da0977e58847259c1
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 13:01:45 2017 -0400
+ 
+     Testing
+ 
+-[33mcommit d9804214694a1287b36387ab5096161119fb7d2a[m
++commit d9804214694a1287b36387ab5096161119fb7d2a
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 13:00:32 2017 -0400
+ 
+     Testing2
+ 
+-[33mcommit 760b3702d46d973fc51fdfe2988e1365e553c229[m
++commit 760b3702d46d973fc51fdfe2988e1365e553c229
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 12:59:02 2017 -0400
+ 
+@@ -124,25 +149,25 @@ Date:   Tue Oct 31 12:59:02 2017 -0400
+     
+     This reverts commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28.
+ 
+-[33mcommit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28[m
++commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 12:54:41 2017 -0400
+ 
+     Testing
+ 
+-[33mcommit 753823a1f154f70f6e374d0b5e88df5d8239cd1e[m
++commit 753823a1f154f70f6e374d0b5e88df5d8239cd1e
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 12:49:12 2017 -0400
+ 
+     more fixes
+ 
+-[33mcommit 086816869af82477368bfd3c77e6e9f1cff9e8fd[m
++commit 086816869af82477368bfd3c77e6e9f1cff9e8fd
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 12:46:23 2017 -0400
+ 
+     Fixes
+ 
+-[33mcommit a02473c4318c5f7012d276aed173e05a84fa7cfd[m
++commit a02473c4318c5f7012d276aed173e05a84fa7cfd
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 12:42:26 2017 -0400
+ 
+@@ -151,121 +176,1232 @@ Date:   Tue Oct 31 12:42:26 2017 -0400
+     This reverts commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b, reversing
+     changes made to 21179a6b02c48db2457e6bdb649d6b4b581bd6e3.
+ 
+-[33mcommit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b[m
++commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b
+ Merge: 21179a6 8fc49a4
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 12:41:21 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3[m
++commit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 12:40:30 2017 -0400
+ 
+     Stuff
+ 
+-[33mcommit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24[m
++commit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 12:39:25 2017 -0400
+ 
+     Tokenizer Has Been Updated With Correct Solution
+ 
+-[33mcommit cebe8f1a5273b0a0a02553cd42f682511f53e186[m
++commit cebe8f1a5273b0a0a02553cd42f682511f53e186
+ Merge: 0343510 878321e
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 09:16:26 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit 03435103759b26ede1d3b7c4215dd1f117cd927a[m
++commit 03435103759b26ede1d3b7c4215dd1f117cd927a
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Tue Oct 31 09:16:19 2017 -0400
+ 
+     Bud Test
+ 
+-[33mcommit 878321e363ceaa0b2d586c8be5b0102618d50634[m
++commit 878321e363ceaa0b2d586c8be5b0102618d50634
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 02:11:11 2017 -0400
+ 
+     Documentation
+ 
+-[33mcommit dc3812325cb76cf5af623bba64f907b01ca7e243[m
++commit dc3812325cb76cf5af623bba64f907b01ca7e243
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 01:31:22 2017 -0400
+ 
+     Misc stuff
+ 
+-[33mcommit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba[m
++commit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 01:09:31 2017 -0400
+ 
+     Documentation + finishing up console
+ 
+-[33mcommit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9[m
++commit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9
+ Author: Andy <az389@cornell.edu>
+ Date:   Tue Oct 31 00:01:43 2017 -0400
+ 
+     More documentation
+ 
+-[33mcommit 4c6783d0533f75d5d9b97742f61e7803f5aa4390[m
++commit 4c6783d0533f75d5d9b97742f61e7803f5aa4390
+ Merge: c4f5689 adc8c91
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 23:51:40 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit c4f56899144a8923b956408256221a5e46fcc436[m
++commit c4f56899144a8923b956408256221a5e46fcc436
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 23:51:38 2017 -0400
+ 
+     Documentation
+ 
+-[33mcommit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b[m
++commit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b
+ Merge: 88613b7 ef684b3
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Mon Oct 30 23:47:38 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2[m
++commit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Mon Oct 30 23:47:33 2017 -0400
+ 
+     Moving Test Done
+ 
+-[33mcommit ef684b37c2fe6924efcc416a45c716297c9f46d6[m
++commit ef684b37c2fe6924efcc416a45c716297c9f46d6
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 23:45:01 2017 -0400
+ 
+     Fixes
+ 
+-[33mcommit 067278303066953f1241de39755d7545b4cb4b1e[m
++commit 067278303066953f1241de39755d7545b4cb4b1e
+ Merge: a6d2ead 5a4812d
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 23:43:56 2017 -0400
+ 
+     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+ 
+-[33mcommit a6d2eadf9badd7c0c163420549e66e2f9eaa2145[m
++commit a6d2eadf9badd7c0c163420549e66e2f9eaa2145
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 23:43:41 2017 -0400
+ 
+     Spiral stuff
+ 
+-[33mcommit 5a4812d93de841aed1720ee36c4a6e9304f368e0[m
++commit 5a4812d93de841aed1720ee36c4a6e9304f368e0
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Mon Oct 30 23:25:53 2017 -0400
+ 
+     Moving Test Initial
+ 
+-[33mcommit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c[m
++commit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c
+ Author: Andy <az389@cornell.edu>
+ Date:   Mon Oct 30 17:53:50 2017 -0400
+ 
+     SpiralCritter stuff
+ 
+-[33mcommit 200b419d4d5d2162ef30ddeb630491a180dd968d[m
++commit 200b419d4d5d2162ef30ddeb630491a180dd968d
+ Author: sn438 <31802007+sn438@users.noreply.github.com>
+ Date:   Mon Oct 30 17:35:38 2017 -0400
+ 
+- 
+\ No newline at end of file
++    SpiralCritter
++
++commit b4cab4286088176f2f7ee316592c66d85e0d54f5
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 16:49:55 2017 -0400
++
++    Misc documentation
++
++commit 4fe3d49e3f68f9dd82055f7a2ab67133fa85d7c3
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 13:45:54 2017 -0400
++
++    printGrid() done + documentation
++
++commit a8a0b4d970eb609ccdd7ca775bbd6be0f16e69e9
++Merge: 9c7dfe2 ccf4130
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 16:48:55 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 9c7dfe2312d03c62c5836b8bad57421da07b2bcc
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 16:48:52 2017 -0400
++
++    Fixing stuff
++
++commit ccf413096637d20c08578d5a8471d265917e5b91
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 29 15:51:11 2017 -0400
++
++    Revert "Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw""
++    
++    This reverts commit 1659d793a583869999bcf2ca34ff03cf3d7a0325.
++
++commit 1659d793a583869999bcf2ca34ff03cf3d7a0325
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 29 15:51:04 2017 -0400
++
++    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw"
++    
++    This reverts commit 1dc49ddf303427f10e7b9c582c9b300e915c92ee, reversing
++    changes made to 3c4e297b634c05eb3ff84b6914cc68f1249cdb62.
++
++commit 1dc49ddf303427f10e7b9c582c9b300e915c92ee
++Merge: 3c4e297 b95cc0d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 29 15:45:30 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 3c4e297b634c05eb3ff84b6914cc68f1249cdb62
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 29 15:42:47 2017 -0400
++
++    Mate is Now Written
++
++commit b95cc0d1aea9e658efa280b562408048438a012a
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 14:34:45 2017 -0400
++
++    Documentation and misc fixes
++
++commit 2f35f14b524a751d259dba895bf349faeab53abf
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 12:55:05 2017 -0400
++
++    Bug fixes
++
++commit 39c7d863224537bf0cf67f30caec497663b95fae
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 02:19:48 2017 -0400
++
++    Minor changes
++
++commit 6634ef197704354faec0a7b034f6b247ca272555
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 29 01:33:02 2017 -0400
++
++    Everything except mate seems to be working
++
++commit 688c6243af2b3043fe323a82912db4a89029c96e
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 28 20:03:09 2017 -0400
++
++    Bug fixes
++
++commit e17d79d4e673173cee38ae77407ec73ccaaacef5
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 28 18:50:25 2017 -0400
++
++    Mutations Now Works For the Offspring
++
++commit 574213e79aa5e7cc53ae933330ba27746fa1cc0d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 28 17:45:31 2017 -0400
++
++    Bud Written Not Tested Yet
++
++commit d6b1f8e0753d0729480649d58fd6df8711f5e4cb
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 28 15:56:42 2017 -0400
++
++    More work on actions
++
++commit ba76d56c96f3cdaefab5a3f0f39e316eb5f4081c
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 28 14:05:44 2017 -0400
++
++    Bug fix
++
++commit 230d8656c6b125a062282412a7de04656dd53e7b
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 28 13:48:55 2017 -0400
++
++    Working on critter actions
++
++commit 6864476813997db576208179515867002b196da4
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 28 02:35:09 2017 -0400
++
++    Work on executing actions
++
++commit eded6017adc247fd6b87d6efeb51f9c53e4e9456
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 27 16:23:06 2017 -0400
++
++    Miscellaneous fixes for world creation
++
++commit 817e650e1e7db5b5331a4451d3e1bd84090b33f6
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 27 15:34:25 2017 -0400
++
++    We can parse and create worlds now!
++
++commit b85b3471c254a4ee7e833dcb0b0171cb6de01812
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 27 02:23:09 2017 -0400
++
++    Random world creation seems to work now
++
++commit 0505e11fa4626d992d410e1cb6bc4e4fe43169ce
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 26 13:16:13 2017 -0400
++
++    A5 grind
++
++commit ed8272a172cba17610fa47e1b46b9439929a40ed
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 25 00:44:21 2017 -0400
++
++    More A5 stuff!
++
++commit 026920b66cdbb1770bb68f357d95b2fd22ec9c01
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 24 22:47:15 2017 -0400
++
++    More stuff on A5!
++
++commit 99d68e420850d05d9909afc7a4dd3bd3a77f695f
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 23 14:29:41 2017 -0400
++
++    Finishing up interpreter
++
++commit 33f80a05f8d015b98f73df2d4472e38d083547eb
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 23 00:44:43 2017 -0400
++
++    A crap ton of work for A5
++
++commit 9644950902cbbc61d88496792a8b3f41b4bd01c9
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 22 00:32:16 2017 -0400
++
++    Beginning of A5
++
++commit 234a8439af7fdd86f54cef7019fc9988347a6b11
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 18 15:33:29 2017 -0400
++
++    Deleted old log
++
++commit 1d3a3be36fa9efdef8151b9499ffb94c9a963f2b
++Merge: 9e38ff4 815597a
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Tue Oct 17 07:59:37 2017 -0400
++
++    Merge branch 'master' of github.coecis.cornell.edu:cs2112-f17/a4-release
++
++commit 9e38ff4fbd847de76c423e16030186127ff61a09
++Merge: 539a973 b6b5f8a
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 23:42:49 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 539a973e0a1f2fd93738bc8548010653f62d3dec
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 23:42:44 2017 -0400
++
++    Final Test Cases
++
++commit b6b5f8aeb7baf817366791f98bf13014fd5b7707
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 23:20:26 2017 -0400
++
++    More cleanup
++
++commit 1a1c3d3553c93eb032c45404eb36f35c72c7a24f
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 23:01:09 2017 -0400
++
++    Adding print statements
++
++commit 8a5f8d6866f15d8e16b2c9350d0c27aa40aa3861
++Merge: bd7441c 881c12e
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 22:48:57 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit bd7441c49ab620dc59422d9581ffc0551b75b7f1
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 22:47:36 2017 -0400
++
++    Comments and Stuff
++
++commit 881c12e3a491495aa1cbbe61ec014c593153da90
++Merge: cdf51fe f2b31b9
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 22:39:06 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit cdf51fecb03134fd191148a1a1f0c8f06ee69dc2
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 22:39:04 2017 -0400
++
++    Miscellaneous changes
++
++commit f2b31b9cd307bbf907a39144dd1767f1d06d5833
++Merge: 0dde501 be7a6a2
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 22:13:53 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 0dde5016b2473b3d613e3b1948602e10653c19ea
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 22:13:06 2017 -0400
++
++    Mutation Print Statements
++
++commit be7a6a2b421e718c7e3eea8350bd0acbb7531348
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 21:22:41 2017 -0400
++
++    Added findRoot method to AbstractMutation
++
++commit c3c23f9177547bc361c9ec616369dfd6ea77ef04
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 20:58:58 2017 -0400
++
++    Weird merge conflict stuff
++
++commit 80d565be7e0f32e0182148a87cac4ca258143483
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 20:55:46 2017 -0400
++
++    Weird merge stuff
++
++commit f26b34db1f30d59e2c56eef98676916f577339b7
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 20:50:37 2017 -0400
++
++    Fixing merge conflicts
++
++commit b4502b00fd077833f6575bebdbdac40c22a51a55
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 20:48:48 2017 -0400
++
++    More cleanup
++
++commit cab431590fb2de5ef7deb5d279f39ae118b7f252
++Merge: ac14d01 2aa663d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 20:29:09 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit ac14d0164cea23c7df5135484e9cd6d40011a1f4
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 20:29:00 2017 -0400
++
++    Some Tests
++
++commit 2aa663d222343983b171ec0e4fc96e99f8212812
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 20:21:33 2017 -0400
++
++    Cleanups and bug fixes
++
++commit 77c50a2f2d3ca7911530e09be609d7b16ff40e91
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 18:52:09 2017 -0400
++
++    Work on insert
++
++commit 052da7bfa11e0af2d724abd4bd13e7a10d117043
++Merge: 4348a7f 49143d7
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 16:36:52 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 4348a7fd47861e5aaa1a22107e0d666f82eb5b28
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 16:36:47 2017 -0400
++
++    Misc work and documentation
++
++commit 49143d7b6092206f2dab796946e131ff0ccfc1d4
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 16:35:11 2017 -0400
++
++    Test File
++
++commit 15bbc3900bca53f73ad3bb93098b38fefa10e330
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 15:20:10 2017 -0400
++
++    Some work with insert and transform
++
++commit adcfb0219416b5f91e935af7173dd4e7c08e3d87
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 14:40:50 2017 -0400
++
++    Fixes and testing
++
++commit 7f8a314e2ced238eac2adc978e9fe8ad62894119
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 14:40:22 2017 -0400
++
++    Testing Files
++
++commit 965e2c3c48b6c322c753bcab5e1622f2e1a3097c
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 14:33:15 2017 -0400
++
++    Commit Initial Insert Implementation
++
++commit 3a959f4ced103fd74673d3143364e34f4d7bff3c
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 13:39:31 2017 -0400
++
++    Fixed a bug in NodeAt
++
++commit c0fcbf70408211cdbde427b43ca0cb205254dcc7
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 12:37:22 2017 -0400
++
++    Debugging replace
++
++commit 2b2ef6c1b2244f0158abb886610f1444ad62c2cf
++Merge: 5579cb2 cf67aa2
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 03:24:25 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 5579cb28b24cfb8bced689e99425491f2c13a7fa
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 03:24:18 2017 -0400
++
++    MutateTransform Seems To Work
++
++commit cf67aa2c2c409216685336a0dbad683c23579e1f
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 02:33:39 2017 -0400
++
++    Work on MutationDuplicate
++
++commit f5077ecfad932393c2169603cabf21d4d212c5d4
++Merge: 3fb5b19 794d787
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 00:37:58 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 3fb5b19bc7b640015fb64e10a8f3cf378bc464a8
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 16 00:37:54 2017 -0400
++
++    Merge Commit
++
++commit 794d787d96838141819c1a0c058ad517e4953e58
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 16 00:25:57 2017 -0400
++
++    Finished MutationRemove and added test
++
++commit 67d2fc084ce4f9255c8458739709060518916d2c
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 23:43:32 2017 -0400
++
++    Work with MutationRemove
++
++commit fce2eb0a237809e95033466be57fa074339ba33c
++Merge: dee740e 69ab4d9
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 20:50:35 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit dee740e95e3b8f21629e303d0b5ac5924f6163be
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 20:49:52 2017 -0400
++
++    More Cleanup
++
++commit 69ab4d9e8387ae53be31316f33f36c6a86777cad
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 20:47:49 2017 -0400
++
++    MergeSwap Now Works
++
++commit bcde017f3da5a46ebd5a3060e3d47eaba6f6bdef
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 20:37:07 2017 -0400
++
++    Mutation interface changes
++
++commit e22722cb347b4bd4597320b36c3e2d687b9329b1
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 20:34:00 2017 -0400
++
++    Start on searchChildrenForType
++
++commit 4890a5574cdfc395934203b490a71e9005c4bf8f
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 18:53:58 2017 -0400
++
++    Cleanup
++
++commit 3cf383381d9e20c46263215b7c53dd673660079d
++Merge: be1604c 5433934
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 18:46:22 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit be1604cea9b62399a5eb8d9a5fb2cb72fa7735f4
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 18:45:03 2017 -0400
++
++    Work on Mutations
++
++commit 5433934f070810b8dc4f55f12d6be122aa8ca303
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 18:43:22 2017 -0400
++
++    Tokenizer Bug Fix
++
++commit 815597af6fb9f775869ef2ba51bb5d6f66027c42
++Author: Shiyu <sw673@cornell.edu>
++Date:   Sun Oct 15 18:38:42 2017 -0400
++
++    update A5 README
++
++commit d31d9d429f0307d5ecb5b5d2498d5b406add1989
++Merge: 5433ba1 08798b1
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 18:11:20 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 5433ba10a88a3470d48feefb5100f6e8e70f4636
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 18:11:04 2017 -0400
++
++    Merge
++
++commit 08798b19810497041a9105b84cbdfcdc1a92851e
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 15:58:22 2017 -0400
++
++    Fixing merge gibberish
++
++commit ed7b982c359a0cf5028f3907ca2a366c9dc0487c
++Merge: 6198a3a 6bf1984
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 15:56:24 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 6198a3a2db240f566d1fe0a1395fbfc2f0ba04cb
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 15:56:21 2017 -0400
++
++    Added NodeType functionality
++
++commit 6bf1984c29bbb21a072ec9ab88e98af3b034ab2c
++Merge: cdbf211 d2ffb8d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 12:43:36 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit cdbf21130d6847eb62f3f09849e45138d0e86053
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sun Oct 15 12:43:17 2017 -0400
++
++    Merge
++
++commit d2ffb8dbde25f019f2e6121692a2c1093fbf7594
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 12:41:57 2017 -0400
++
++    Added parent pointers and some basic mutation stuff
++
++commit 11944723dbd966f12e45714c69d45eda8fe23af6
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 15 03:08:30 2017 -0400
++
++    Initial Mutation stuff
++
++commit c81daea79acf1103989b63f10af31fea388a1c80
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 14 18:23:03 2017 -0400
++
++    Cleanup
++
++commit 41775701fe1f4cd4e303419abde0f7cea7f50c06
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 14 17:16:23 2017 -0400
++
++    AST Now Understands Comments
++
++commit 364eada1687bb165343dc1308ecab6728bb28857
++Merge: f5e3749 4a58bfd
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 14 16:53:32 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit f5e3749e998d2d41338f7d078823fb27ea415b3e
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 14 16:53:28 2017 -0400
++
++    Merge
++
++commit 4a58bfd50f953b609438bbc6bbb1964685051f63
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 14 16:52:18 2017 -0400
++
++    Added Deep Copy functionality (UNTESTED)
++
++commit d8c3aa8b584ede7a25e30f0ce44137271248f632
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Sat Oct 14 07:48:38 2017 -0400
++
++    Revert "Remove a4 main class"
++    
++    This reverts commit 620c7a43d207103c789c3fb1c4c2290bae429a95.
++
++commit 8903ca5826cbcffb5d969663e051fb3d949ed641
++Author: Shiyu <sw673@cornell.edu>
++Date:   Fri Oct 13 23:03:05 2017 -0400
++
++    added example world and critter
++
++commit 01683953258616d8f04a2a1a243b74bdae4fdfc3
++Author: Shiyu <sw673@cornell.edu>
++Date:   Fri Oct 13 22:54:15 2017 -0400
++
++    update main class in build.gradle
++
++commit 620c7a43d207103c789c3fb1c4c2290bae429a95
++Author: Shiyu <sw673@cornell.edu>
++Date:   Fri Oct 13 22:48:04 2017 -0400
++
++    Remove a4 main class
++
++commit e0892b69efdf555834a762fa1e1afcf557191e94
++Author: Shiyu <sw673@cornell.edu>
++Date:   Fri Oct 13 22:19:12 2017 -0400
++
++    Initial commit for A5
++
++commit a1b0c9a25c1d72d5515a5f710187730fb5cc3212
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 13 13:16:17 2017 -0400
++
++    Cleanups
++
++commit d2cf11bbe6b8d6c36003611c02d76551ee31a446
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Fri Oct 13 01:27:54 2017 -0400
++
++    Example Failing Test Case
++
++commit 033ac4142a2e18462f1bb8bb7d96d9cdc3057ee5
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 13 00:53:51 2017 -0400
++
++    Garbage push
++
++commit 75f7148b8470b3f597517da1e261da53ca76ad4d
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 13 00:51:07 2017 -0400
++
++    Completed Parser? Need to test more
++
++commit ba48d2d9dc0cfee34bca14de6a24ae305076c74b
++Merge: a27ded0 45e3d2d
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 23:32:43 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit a27ded04f3377f3ac5c0f3b206837f30efdd88e1
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 23:32:41 2017 -0400
++
++    Finished parseCommand and parseUpdate and parseAction
++
++commit 45e3d2d5f5c2616c5ee58cacad3c68b9d7a347ba
++Merge: d386876 e95541a
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Thu Oct 12 23:14:38 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit e95541ad13e483b8c30e3409b9eec240ff9a70fb
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 23:07:02 2017 -0400
++
++    Some progress on parseCommand
++
++commit d3868761baad8d335305a4e91c28a86889a836f8
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Thu Oct 12 22:55:48 2017 -0400
++
++    Tiniest Bug Fix Possible
++
++commit 5b6b5dea06ff0fc7f29a750e2bd36f767e612d55
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 20:50:01 2017 -0400
++
++    Cleanup
++
++commit 91c94e87e37f76410ccf4101db475ebe47d58020
++Merge: 8e6f5e2 8cf5213
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Thu Oct 12 20:45:21 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 8e6f5e292e1bc5ef54b26a136b449802d5514b4d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Thu Oct 12 20:44:58 2017 -0400
++
++    Why Dis Class So Hard Man Why?
++
++commit 8cf521393c289017de01457c5e0ded53f4e22941
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 20:42:01 2017 -0400
++
++    Please work
++
++commit a7ff5c820d294545869aa282db3b5114cabd9cc6
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 11:47:24 2017 -0400
++
++    Cleanup
++
++commit 969d32c75a5faf0c28a1617be5eb52066a3d3b7a
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 11:47:03 2017 -0400
++
++    Fixed null pointer exception
++
++commit fd04c2d04013628a89e5bb5412c731c1d01caa73
++Author: Andy <az389@cornell.edu>
++Date:   Thu Oct 12 00:53:40 2017 -0400
++
++    nodeAt (haven't tested yet)
++
++commit 3a1dda2498a8d6bb6b87a91cb8c867f14eb52326
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 22:30:07 2017 -0400
++
++    Misc cleanups and nodeAt
++
++commit 466b9b9a08343fb7921d06495253c19e53cbd300
++Merge: 903080a af51dd6
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 22:01:12 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 903080a857fcbc75d73630f33da1784c05539f7c
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 22:00:44 2017 -0400
++
++    Beginning work on nodeAt
++
++commit af51dd6f4ed60fcbc5caa0996d3d3c2caee47e47
++Merge: 54b7d39 eee15a8
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 21:47:27 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 54b7d3996d9c29b7bfac734a9a66f855d0ddfca6
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 21:47:19 2017 -0400
++
++    Merge Commit
++
++commit eee15a85f8b493a6be97175f53db9e3b95752016
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 21:30:38 2017 -0400
++
++    Fixed reading negative factors
++
++commit ddf500da2295a4719b474d3d6b379d811fdc6ddc
++Merge: d63d441 c501e26
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 20:29:20 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit d63d4411597c35f42363e0a75a3d632aa2200184
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 20:29:18 2017 -0400
++
++    Cleaning up messy switch statements
++
++commit c501e26957402726c65b8b4300ec505a0b66c0a3
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 20:28:49 2017 -0400
++
++    Terrible Implementation
++
++commit e933565781f0b5707a5446ecdbc0fdccdfbd3ff2
++Merge: c8f60da f17469e
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 18:46:08 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit c8f60da07b0ccae5da938571eb81463efcdf4c9e
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 18:46:06 2017 -0400
++
++    Testing and added a //TODO comment
++
++commit f17469ec34dbcd41116efc06a7eb332fbb9a5aa5
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 18:37:07 2017 -0400
++
++    Expression Should Work Now After Office Hours
++
++commit b9a4e80a64f9bc28831138393851c5b40905d5ce
++Merge: a4c8cf4 cdfd63d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 18:12:26 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit a4c8cf478fcac632de340171beedd3ee6ce0465e
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 18:12:21 2017 -0400
++
++    Expression With Different Negation Implementation
++
++commit cdfd63d7bfa7201a37b73d20dc57b792df0cf637
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 11 13:22:29 2017 -0400
++
++    Added proper ProgramImpl creation to ParserImpl.
++    
++    Also wrote a bunch of documentation.
++
++commit af0ea59522e428a21b3778495eae7eb25e903ae9
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 02:47:25 2017 -0400
++
++    Expression Seems to Be Working
++
++commit 5719f8120bc4964435082a0356ed3d73c3629170
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 11 01:34:27 2017 -0400
++
++    Parsing With Factor Implementation
++    
++    Has some String statements in it that should be taken out later.
++
++commit 6b706c206f2527bd22b0f9d9a746120244dfae85
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 17:09:35 2017 -0400
++
++    Quick tests for pretty printing and size
++
++commit 889d7b84753d324325101306191ca57dc1a13ad2
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 16:49:40 2017 -0400
++
++    Added size() functionality.
++    
++    Still untested.
++
++commit e1030c17f851653566849017e22b768c052e6031
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 16:10:05 2017 -0400
++
++    Changed name of evaluateNode() to evaluate()
++
++commit 2ada007083b7cdecbb26dbdd7dfcc4b67d2f34bb
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 16:02:24 2017 -0400
++
++    More AST pretty printing
++    
++    Also added some more documentation.
++
++commit 383380ffb26ff7e01067a28cb44c33bb60536a0d
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 15:07:29 2017 -0400
++
++    Adding more AST nodes
++    
++    Completed pretty printing functionality? Have yet to test it
++
++commit 19867a0c71bac3e419e5338a676d45dcf943e363
++Merge: b54de06 98c4bd3
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 10 01:36:10 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit b54de06e76296f1ba7df64efe344799b03d2e238
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 10 01:35:15 2017 -0400
++
++    Merge Test
++
++commit 98c4bd3a5a800d9369962d220742cc0b2b9c1275
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 10 01:17:13 2017 -0400
++
++    More nodes
++
++commit 0dae210c65395ae9820102e9a71cf7702131efe3
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 9 23:02:17 2017 -0400
++
++    Cleaning up prettyprinting
++
++commit 98c807bfc3555f5b885f2ab601d13f6e0d549707
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 9 22:14:32 2017 -0400
++
++    Cleaned Up Some of The Weird Git Merge Errors
++
++commit 7e4058e0ef9cb2cefa542892c68551b810d2c5b5
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 9 20:39:48 2017 -0400
++
++    Garbage Commit
++
++commit d8c18b9e183bddf66b80cfd3979fdf24b54fef16
++Merge: 14f9246 bcbac9a
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 9 20:36:49 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++commit 14f9246264248a07b22811dc4322c8773963b6ef
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 9 20:36:28 2017 -0400
++
++    Initial Parsing Commit: Barely Working
++
++commit bcbac9a71a41a75cc4a622474fdf2d9fa785a8ad
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 9 13:38:50 2017 -0400
++
++    Added PrettyPrint functionality to some nodes.
++
++commit 2dca9ff6a23bf526c5f994bc090580fa5ced4a0d
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 9 02:40:38 2017 -0400
++
++    Initial Parsing Code
++
++commit b44bc837fd76add8a499b11b53ee9bd154c8ef72
++Author: Andy <az389@cornell.edu>
++Date:   Sun Oct 8 23:24:03 2017 -0400
++
++    Creating a few more classes
++
++commit 1eacab181ac1ee04aa9b05b959639b6829f78fe0
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 23:17:48 2017 -0400
++
++    More misc
++
++commit 9cacefa5a19dbc46c63c8c6d55670c5820ee824d
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 23:17:00 2017 -0400
++
++    Miscellaneous work
++
++commit d82ed5429c812f117f6140060fc55498975f3a37
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 7 21:11:25 2017 -0400
++
++    UnaryExpr
++
++commit 312ed20a032d4fa9877d84c950b145762fc7b797
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 19:19:06 2017 -0400
++
++    Work on BinaryExpr
++
++commit c73bb400d579e7c63fd6cd4518213c3be54b099a
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 17:38:42 2017 -0400
++
++    Testing
++
++commit 00e1fa6f353a61b9381ef49841235a87da6eee0a
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 17:35:03 2017 -0400
++
++    What is going on
++
++commit c003dedf29be628930a8790de3114bec89d4eaa8
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 7 17:32:34 2017 -0400
++
++    Commit
++
++commit 8ae4fdc7dc881dc1ef2fb01c30d0841bbc14e492
++Merge: 6f05ca4 53c4c2b
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 7 17:28:23 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++    
++    That's okay just let it merge.
++
++commit 6f05ca4d729156e6660d11e35db5cc4476a70eaa
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Sat Oct 7 17:27:41 2017 -0400
++
++    Third Test
++
++commit 53c4c2b2145a668b9c209d5424c0d100e8456a74
++Author: Andy <az389@cornell.edu>
++Date:   Sat Oct 7 17:25:38 2017 -0400
++
++    Adding new classes
++    
++    Added BinaryExpr and AbstractNode
++
++commit d01569a2a53f3e351619f70779987c94d145f8a4
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 6 16:15:07 2017 -0400
++
++    FORMATTING AHHHHH
++    
++    yes.
++
++commit 8bc818d587a8432fa93c77b69d2ba5eac16ddde4
++Author: Andy <az389@cornell.edu>
++Date:   Fri Oct 6 01:23:17 2017 -0400
++
++    FORMATTING.
++    
++    AHHHHHH
++
++commit 9a24289728ff1947e893643e7d52f3631401faea
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Wed Oct 4 23:26:09 2017 -0400
++
++    Second Test
++
++commit 27b2ad811e24b1b047922ab388e7607e3dcb4e27
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 4 21:10:07 2017 -0400
++
++    Test commit
++
++commit d86b272fc0997fb0e6317c52a4b008a10876e047
++Author: Andy <az389@cornell.edu>
++Date:   Wed Oct 4 16:33:10 2017 -0400
++
++    Formatting.
++    
++    Did not touch the classes Tokenizer and TokenType.
++
++commit ec0c0cbfcf07c48337cb8418401fd0706f517d00
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Wed Sep 27 07:00:30 2017 -0400
++
++    fix build.gradle
++
++commit 04b331b5522051b14e575f07b2604064ff6a2331
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Wed Sep 27 06:57:53 2017 -0400
++
++    update main class in jar
++
++commit 12522579bc0cd8c1ac044bf393c472d01c0b8bbc
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Wed Sep 27 06:56:20 2017 -0400
++
++    update readme
++
++commit a93e8a384e79dcf6275a0388d7c2e7903fdea7d9
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Wed Sep 27 06:54:42 2017 -0400
++
++    update readme
++
++commit 36f6c0347f6c3833028aa5e3d85a2cd1bf552a7c
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Tue Sep 26 20:28:47 2017 -0400
++
++    update gitignore
++
++commit 8821b53a01fc5c1b3ed87534b79dc77701244810
++Author: Jacob Glueck <swimgiraffe435@gmail.com>
++Date:   Tue Sep 26 20:15:08 2017 -0400
++
++    rename
++
++commit 7df160b24f17047dc8728648aef62e25d002364e
++Author: Kenneth Wang Fang <kwf37@cornell.edu>
++Date:   Sun Sep 24 21:33:33 2017 -0400
++
++    Update README.md
++
++commit eaec237ed515ae2af243f363faf468de1f0bf79d
++Author: Kenneth Wang Fang <kwf37@cornell.edu>
++Date:   Sun Sep 24 19:19:05 2017 -0400
++
++    Update README.md
++
++commit f3047f3b22aab046b1bcad165dd49edee47efa6e
++Author: Travis Stephen Westura <tsw52@cornell.edu>
++Date:   Sun Sep 24 16:07:29 2017 -0400
++
++    Updated README.md to fix a few typos
++
++commit 20b5fdf1415a432f9883ecea18a3693e50f637e9
++Author: Kenneth Wang Fang <kwf37@cornell.edu>
++Date:   Sun Sep 24 15:04:08 2017 -0400
++
++    Added some gradle info
++
++commit 9071e6c4bea8d968e0228b7c421f3389cc3f3164
++Author: Kenneth Wang Fang <kwf37@cornell.edu>
++Date:   Sun Sep 24 14:28:28 2017 -0400
++
++    Added Git instructinos
++
++commit f35fb464b5841565a1d7499cfada19183b1a1f02
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 19:01:04 2017 -0400
++
++    small update to example test
++
++commit e166fa58cf171728212f8b39a5654485f796d41c
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:59:35 2017 -0400
++
++    Add example test
++
++commit f68e672761aaf65c8d725208c6e96a949ffe0518
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:32:19 2017 -0400
++
++    Add readme file to the test directory
++
++commit 0962bf39e4b12cde0a84e89e705ba3590dae28ea
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:30:05 2017 -0400
++
++    Update jar output in gradle build file
++
++commit 614cf3ad27c42a61bfc1555f1d87ccaa1efcceda
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:28:02 2017 -0400
++
++    Move example program resources to the test
++
++commit 69d53902393fb0cab3dd9cba9a187a11d7466bbb
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:25:39 2017 -0400
++
++    Remove repeated resources folder
++
++commit fe07f661c087d1eaab52333f88fc237afd0c9879
++Author: Travis Westura <twestura@gmail.com>
++Date:   Sat Sep 23 18:21:52 2017 -0400
++
++    Initial commit of a4 files
+diff --git a/src/main/java/ast/MutationTransform.java b/src/main/java/ast/MutationTransform.java
+index ea98f5f..5540e47 100644
+--- a/src/main/java/ast/MutationTransform.java
++++ b/src/main/java/ast/MutationTransform.java
+@@ -154,7 +154,7 @@ public class MutationTransform extends AbstractMutation
+ 	public boolean mutate(UnaryExpr ue)
+ 	{
+ 		Random r = new Random();
+-		ue.setValue(java.lang.Integer.MAX_VALUE/r.nextInt());
++		ue.setValue(java.lang.Integer.MAX_VALUE/(r.nextInt(java.lang.Integer.MAX_VALUE) + 1));
+ 		if(printMutationDetail)
+ 			System.out.println("Transformed the Unary Expression node\n" + ue + "\n");
+ 		return true;
+diff --git a/src/main/java/gui/A6_written_problems.txt b/src/main/java/gui/A6_written_problems.txt
+new file mode 100644
+index 0000000..4a2f8b6
+--- /dev/null
++++ b/src/main/java/gui/A6_written_problems.txt
+@@ -0,0 +1,28 @@
++1. An implementation of or() is provided below:
++
++/** Returns: disjunction of this and that (this OR that). */
++public TVBool or(TVBool that) {
++	TVBool result = new TVBool();
++	result.state = Math.max(this.state, that.state);
++	return result;
++}
++
++2. normalize() is implemented correctly because it is simply a checking method whose job is to assert that there isn't any flaws in the logic of the other methods. It never actually changes the representation of the TVBool when being accessed by different classes because if the normalize method retains the sign of the field state even if the technical value of the field is changed. not() is implemented correctly because it never actually changes the value of the field state. It creates a new object, sets the state of that object, and returns that object. It never alters the state of the original object.
++
++3. The hashCode() method is incorrect because if two TVBools are equal, they need to have the same hash code. The given implementation does not have this property. A correct implementation is provided below:
++
++@Override
++public int hashCode() {
++	return Integer.signum(state);
++}
++
++An implementation of equals() is provided below:
++
++@Override
++public boolean equals(Object o) {
++	if (Integer.signum(state) == Integer.signum(o.state)) {
++		return true;
++	} else {
++		return false;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/gui/Controller.java b/src/main/java/gui/Controller.java
+new file mode 100644
+index 0000000..5e2fb56
+--- /dev/null
++++ b/src/main/java/gui/Controller.java
+@@ -0,0 +1,434 @@
++package gui;
++
++import java.io.File;
++import java.io.FileNotFoundException;
++import java.util.Optional;
++import java.util.concurrent.Executors;
++import java.util.concurrent.ScheduledExecutorService;
++import java.util.concurrent.TimeUnit;
++
++import ast.Program;
++import javafx.animation.KeyFrame;
++import javafx.animation.Timeline;
++import javafx.beans.value.ChangeListener;
++import javafx.beans.value.ObservableValue;
++import javafx.event.ActionEvent;
++import javafx.event.EventHandler;
++import javafx.fxml.FXML;
++import javafx.scene.canvas.Canvas;
++import javafx.scene.control.Alert;
++import javafx.scene.control.Alert.AlertType;
++import javafx.scene.control.Button;
++import javafx.scene.control.Label;
++import javafx.scene.control.MenuItem;
++import javafx.scene.control.RadioButton;
++import javafx.scene.control.ScrollPane;
++import javafx.scene.control.Slider;
++import javafx.scene.control.TextArea;
++import javafx.scene.control.TextField;
++import javafx.scene.control.TextInputDialog;
++import javafx.scene.control.ToggleGroup;
++import javafx.scene.input.MouseEvent;
++import javafx.scene.input.ScrollEvent;
++import javafx.scene.text.Text;
++import javafx.stage.FileChooser;
++import javafx.stage.Popup;
++import javafx.util.Duration;
++import simulation.SimpleCritter;
++
++/**
++ * This class handles user inputs and sends information to the world model and
++ * world view to update their states accordingly.
++ */
++public class Controller {
++	@FXML
++	private MenuItem help;
++	@FXML
++	private MenuItem close;
++
++	@FXML
++	private Text columnText;
++	@FXML
++	private Text rowText;
++	@FXML
++	private Text memSizeText;
++	@FXML
++	private Text speciesText;
++	@FXML
++	private Text defenseText;
++	@FXML
++	private Text offenseText;
++	@FXML
++	private Text energyText;
++	@FXML
++	private Text passText;
++	@FXML
++	private Text tagText;
++	@FXML
++	private Text postureText;
++	@FXML
++	private Text sizeText;
++	@FXML
++	private TextArea lastRuleDisplay;
++	@FXML
++	private Button displayProgram;
++	
++	@FXML
++	private Button newWorld;
++	@FXML
++	private Button loadWorld;
++	@FXML
++	private Button loadCritterFile;
++	@FXML
++	private ToggleGroup LoadChoice;
++	@FXML
++	private RadioButton chkRand;
++	@FXML
++	private RadioButton chkSpecify;
++	@FXML
++	private TextField numCritters;
++	@FXML
++	private Button stepForward;
++	@FXML
++	private Button run;
++	@FXML
++	private Button pause;
++	@FXML
++	private Button reset;
++	@FXML
++	private Slider simulationSpeed;
++
++	@FXML
++	private ScrollPane scroll;
++	@FXML
++	private Canvas c;
++	@FXML
++	private Label crittersAlive;
++	@FXML
++	private Label stepsTaken;
++
++	private Timeline timeline;
++	/** The model that contains the world state. */
++	private WorldModel model;
++	/** Controls the hex grid. */
++	private WorldMap map;
++
++	private double mousePanPressedX;
++	private double mousePanPressedY;
++	
++	/** The rate at which the simulation is run. */
++	private long simulationRate;
++	/** The executor that is used to step the world periodically. */
++	private ScheduledExecutorService executor;
++
++	@FXML
++	public void initialize() {
++		model = new WorldModel();
++		simulationRate = 30;
++		
++		newWorld.setDisable(false);
++		loadWorld.setDisable(false);
++		loadCritterFile.setDisable(true);
++		chkRand.setDisable(true);
++		chkSpecify.setDisable(true);
++		numCritters.setDisable(true);
++		stepForward.setDisable(true);
++		run.setDisable(true);
++		pause.setDisable(true);
++		reset.setDisable(true);
++		simulationSpeed.setDisable(true);
++
++		c.getGraphicsContext2D().clearRect(0, 0, c.getWidth(), c.getHeight());
++		c.setDisable(true);
++		c.setVisible(false);
++
++		c.heightProperty().bind(scroll.heightProperty());
++		c.widthProperty().bind(scroll.widthProperty());
++		
++		simulationSpeed.valueProperty().addListener(new ChangeListener<Number>() {
++            public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
++                        simulationRate = new_val.longValue();
++                }
++            });
++	}
++
++	@FXML
++	private void handleNewWorldPressed(MouseEvent me) {
++		model.createNewWorld();
++		map = new WorldMap(c, model);
++		newWorld.setDisable(true);
++		loadWorld.setDisable(true);
++		chkRand.setDisable(false);
++		chkSpecify.setDisable(false);
++		stepForward.setDisable(false);
++		run.setDisable(false);
++		reset.setDisable(false);
++		simulationSpeed.setDisable(false);
++		c.setDisable(false);
++		c.setVisible(true);
++
++		map.draw();
++	}
++
++	@FXML
++	private void handleLoadWorldPressed(MouseEvent me) throws FileNotFoundException, IllegalArgumentException {
++		FileChooser fc = new FileChooser();
++		fc.setTitle("Choose World File");
++		File worldFile = fc.showOpenDialog(new Popup());
++		try {
++			model.loadWorld(worldFile);
++		} catch (FileNotFoundException f) {
++			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
++			a.setTitle("Invalid File");
++			a.showAndWait();
++			return;
++		}
++		map = new WorldMap(c, model);
++
++		newWorld.setDisable(true);
++		loadWorld.setDisable(true);
++		chkRand.setDisable(false);
++		chkSpecify.setDisable(false);
++		stepForward.setDisable(false);
++		run.setDisable(false);
++		reset.setDisable(false);
++		simulationSpeed.setDisable(false);
++		c.setDisable(false);
++		c.setVisible(true);
++
++		map.draw();
++	}
++
++	@FXML
++	private void handleChkRandom(ActionEvent ae) {
++		numCritters.setDisable(false);
++		loadCritterFile.setDisable(false);
++	}
++
++	@FXML
++	private void handleChkSpecify(ActionEvent ae) {
++		numCritters.setDisable(true);
++		loadCritterFile.setDisable(false);
++	}
++
++	@FXML
++	private void handleLoadCritters(MouseEvent me) {
++		FileChooser fc = new FileChooser();
++		fc.setTitle("Choose Critter File");
++		File critterFile = fc.showOpenDialog(new Popup());
++		
++		RadioButton choice = (RadioButton) LoadChoice.getSelectedToggle();
++		if(choice == chkRand)
++		{
++			try
++			{
++				int n = Integer.parseInt(numCritters.getText());
++				model.loadRandomCritters(critterFile, n);
++			}
++			catch (NumberFormatException e)
++			{
++				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid number of critters to load in.");
++				a.setTitle("Invalid Number");
++				a.showAndWait();
++				return;
++			}
++		}
++		else
++		{	
++			TextInputDialog dialog = new TextInputDialog();
++			dialog.setTitle("Choose Hex");
++			dialog.setHeaderText("Enter \"[columns] [rows]\".");
++			Optional<String> result = dialog.showAndWait();
++			
++			try
++			{
++				result.ifPresent(location -> 
++				{
++					String col = result.get().split(" ")[0];
++					String row = result.get().split(" ")[1];
++					int c = Integer.parseInt(col);
++					int r = Integer.parseInt(row);
++					model.loadCritterAtLocation(critterFile, c, r);
++				});
++			}
++			catch (Exception e)
++			{
++				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid location");
++				a.setTitle("Invalid Location");
++				a.showAndWait();
++				return;
++			}
++		}
++		
++		map.draw();
++	}
++
++	@FXML
++	private void handleStep(MouseEvent me) {
++		model.advanceTime();
++		map.draw();
++		crittersAlive.setText("Critters Alive: " + model.numCritters);
++		stepsTaken.setText("Time: " + model.time);
++	}
++
++	@FXML
++	private void handleRunPressed(MouseEvent me) {
++		if(simulationRate == 0)
++			return;
++		
++		Thread worldUpdateThread = new Thread(new Runnable()
++		{
++			@Override
++			public void run()
++			{
++				model.advanceTime();
++			}
++		});
++		worldUpdateThread.setDaemon(true);
++		
++		executor = Executors.newSingleThreadScheduledExecutor();
++		executor.scheduleAtFixedRate(worldUpdateThread, 0, 1000 / simulationRate, TimeUnit.MILLISECONDS);
++		
++		timeline = new Timeline(new KeyFrame(Duration.millis(1000 / 30), new EventHandler<ActionEvent>() {
++		
++			@Override
++			public void handle(ActionEvent ae)
++			{ 
++				map.draw();
++				crittersAlive.setText("Critters Alive: " + model.numCritters);
++				stepsTaken.setText("Time: " + model.time);
++			}
++		}));
++
++		timeline.setCycleCount(Timeline.INDEFINITE);
++		timeline.play();
++
++		newWorld.setDisable(true);
++		loadWorld.setDisable(true);
++		loadCritterFile.setDisable(true);
++		chkRand.setDisable(true);
++		chkSpecify.setDisable(true);
++		numCritters.setDisable(true);
++		stepForward.setDisable(true);
++		run.setDisable(true);
++		reset.setDisable(true);
++		simulationSpeed.setDisable(true);
++
++		pause.setDisable(false);
++	}
++
++	@FXML
++	private void handlePauseClicked(MouseEvent me) {
++		executor.shutdownNow();
++
++		newWorld.setDisable(false);
++		loadWorld.setDisable(false);
++		loadCritterFile.setDisable(false);
++		chkRand.setDisable(false);
++		chkSpecify.setDisable(false);
++		numCritters.setDisable(false);
++		stepForward.setDisable(false);
++		run.setDisable(false);
++		reset.setDisable(false);
++		simulationSpeed.setDisable(false);
++
++		timeline.stop();
++		pause.setDisable(true);
++	}
++
++	@FXML
++	private void handleMapClicked(MouseEvent me) {
++		if (!me.isPrimaryButtonDown()) {
++			mousePanPressedX = me.getScreenX();
++			mousePanPressedY = me.getScreenY();
++		}
++		else
++		{
++			double xCoordinateSelected = me.getSceneX();
++			double yCoordinateSelected = me.getSceneY();
++			int[] hexCoordinatesSelected = new int[2];
++			boolean shouldUpdateRowColumn = map.select(xCoordinateSelected, yCoordinateSelected);
++			hexCoordinatesSelected = map.getSelectedHex();
++			if(shouldUpdateRowColumn)
++			{
++				rowText.setText(String.valueOf(hexCoordinatesSelected[0]));
++				columnText.setText(String.valueOf(hexCoordinatesSelected[1]));
++				if (model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]) != null)
++				{
++					SimpleCritter critter = model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]);
++					memSizeText.setText(String.valueOf(critter.getMemLength()));
++					speciesText.setText(critter.getName());
++					int[] critterMemoryCopy = new int[critter.getMemLength()];
++					critterMemoryCopy = critter.getMemoryCopy();
++					defenseText.setText(String.valueOf(critterMemoryCopy[1]));
++					offenseText.setText(String.valueOf(critterMemoryCopy[2]));
++					sizeText.setText(String.valueOf(critterMemoryCopy[3]));
++					energyText.setText(String.valueOf(critterMemoryCopy[4]));
++					passText.setText(String.valueOf(critterMemoryCopy[5]));
++					tagText.setText(String.valueOf(critterMemoryCopy[6]));
++					postureText.setText(String.valueOf(critterMemoryCopy[7]));
++					lastRuleDisplay.setText(critter.getLastRule());
++				}
++				else
++				{
++					memSizeText.setText("");
++					speciesText.setText("");
++					defenseText.setText("");
++					offenseText.setText("");
++					sizeText.setText("");
++					energyText.setText("");
++					passText.setText("");
++					tagText.setText("");
++					postureText.setText("");
++				}
++			}
++		}
++	}
++
++	@FXML
++	private void handleResetClicked(MouseEvent me) {
++		if (executor != null)
++			executor.shutdownNow();
++		if (timeline != null)
++			timeline.stop();
++		initialize();
++	}
++
++	@FXML
++	private void handleMapScroll(ScrollEvent se) {
++		if (se.getDeltaY() > 0)
++			map.zoom(true);
++		else
++			map.zoom(false);
++	}
++
++	@FXML
++	private void handleMapDrag(MouseEvent me) {
++		if (!me.isPrimaryButtonDown()) {
++			map.drag(me.getScreenX() - mousePanPressedX, me.getScreenY() - mousePanPressedY);
++		}
++	}
++
++	@FXML
++	private void close(ActionEvent ae) {
++		if (executor != null)
++			executor.shutdownNow();
++		if (timeline != null)
++			timeline.stop();
++		System.exit(0);
++	}
++	
++	@FXML
++	private void handleDisplayProgram(MouseEvent me) {
++		int[] hexCoordinates = new int[2];
++		hexCoordinates = map.getSelectedHex();
++		if (model.getCritter(hexCoordinates[0], hexCoordinates[1]) != null) {
++			SimpleCritter critter = model.getCritter(hexCoordinates[0], hexCoordinates[1]);
++			Program critterProgram = critter.getProgram();
++			String critterProgramString = critterProgram.toString();
++			Alert alert = new Alert(AlertType.INFORMATION, critterProgramString);
++			alert.setHeaderText("Critter Program");
++			alert.showAndWait();
++		}
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/gui/Main.java b/src/main/java/gui/Main.java
+new file mode 100644
+index 0000000..fd11749
+--- /dev/null
++++ b/src/main/java/gui/Main.java
+@@ -0,0 +1,46 @@
++package gui;
++
++import java.net.URL;
++
++import javafx.application.Application;
++import javafx.fxml.FXMLLoader;
++import javafx.scene.Scene;
++import javafx.stage.Stage;
++
++public class Main extends Application {
++
++	public static void main(String[] args) {
++		launch(args);
++	}
++
++	@Override
++	public void start(Stage stage) {
++		stage.setMinHeight(800);
++		stage.setMinWidth(1000);
++
++		try {
++			URL r = getClass().getResource("gui.fxml");
++			if (r == null)
++				throw new Exception("No FXML resource found.");
++			Scene scene = new Scene(FXMLLoader.load(r));
++			stage.setTitle("CRITTERWORLD!");
++			stage.setScene(scene);
++			stage.sizeToScene();
++			stage.show();
++		} catch (Exception e) {
++			
++		}
++	}
++
++}
++
++// TODO fix zooming + panning position
++// TODO fix hex selection upon zoom
++// TODO fix weird lagginess in panning
++// TODO black universe, grey hex grid, grey fully filled hexes as rocks, neon
++// circles for food (maybe yellow), neon isosceles triangles for critters (maybe
++// green + species variation so different shades)
++// TODO tableview for hexinfo
++// TODO when unselecting a hex, kill the critter info in corner
++// TODO figure out what to do when selecting a rock or food
++// TODO change title of critter program message box
+\ No newline at end of file
+diff --git a/src/main/java/gui/ResizableCanvas.java b/src/main/java/gui/ResizableCanvas.java
+new file mode 100644
+index 0000000..4a29646
+--- /dev/null
++++ b/src/main/java/gui/ResizableCanvas.java
+@@ -0,0 +1,12 @@
++package gui;
++
++import javafx.scene.canvas.Canvas;
++
++public class ResizableCanvas extends Canvas
++{
++	@Override
++	public boolean isResizable()
++	{
++		return true;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/gui/WorldMap.java b/src/main/java/gui/WorldMap.java
+new file mode 100644
+index 0000000..28cbfb9
+--- /dev/null
++++ b/src/main/java/gui/WorldMap.java
+@@ -0,0 +1,508 @@
++package gui;
++
++import java.io.InputStream;
++import java.util.Arrays;
++import java.util.HashMap;
++import java.util.Map;
++
++import javafx.scene.canvas.Canvas;
++import javafx.scene.canvas.GraphicsContext;
++import javafx.scene.image.Image;
++import javafx.scene.paint.Color;
++import javafx.scene.text.Font;
++import javafx.scene.text.TextAlignment;
++import simulation.Food;
++import simulation.Hex;
++import simulation.Rock;
++import simulation.SimpleCritter;
++import simulation.WorldObject;
++
++public class WorldMap {
++	private WorldModel model;
++	private GraphicsContext gc;
++	private Canvas canvas;
++	private int[] selectedHex;
++
++	/**
++	 * The minimum acceptable hex sidelength (zoom will not allow the user to zoom
++	 * in any further.
++	 */
++	private final int MIN_SIDELENGTH = 20;
++
++	/**
++	 * The maximum acceptable hex sidelength (zoom will not allow the user to zoom
++	 * out any further.
++	 */
++	private final int MAX_SIDELENGTH = 60;
++
++	/** How much each scroll tick zooms the hex grid by. */
++	private final double ZOOM_FACTOR = 3.0;
++
++	/** The background color of the canvas. */
++	private final Color BACKGROUND_COLOR = Color.DIMGRAY;
++	/** The outline color of hexagons. */
++	private final Color HEX_COLOR = Color.LIGHTGRAY;
++	/** The color of a highlighted hex. */
++	private final Color HIGHLIGHT_COLOR = Color.rgb(176, 224, 230, 0.3);
++
++	private double height;
++	private double width;
++	private int rows;
++	private int columns;
++
++	/** The sideLength of a hexagon. Used as a measure of scale. */
++	private double sideLength;
++
++	// these four variables are used to help drawing methods
++	private int column_drawing_marker;
++	private int row_drawing_marker;
++	private double x_position_marker;
++	private double y_position_marker;
++
++	/**
++	 * Marks the rectangular x coordinate of the origin (the (0, 0) hex coordinate).
++	 */
++	private double origin_x;
++
++	/**
++	 * Marks the rectangular y coordinate of the origin (the (0, 0) hex coordinate).
++	 */
++	private double origin_y;
++
++	private HashMap<String, Image> pictures;
++
++	/**
++	 * Creates a new world map.
++	 * 
++	 * @param can
++	 *            The Canvas to draw on
++	 * @param wm
++	 *            The WorldModel to work off of
++	 */
++	public WorldMap(Canvas can, WorldModel wm) {
++		gc = can.getGraphicsContext2D();
++		canvas = can;
++		model = wm;
++		height = canvas.getHeight();
++		width = canvas.getWidth();
++
++		columns = wm.getColumns();
++		rows = wm.getRows();
++
++		column_drawing_marker = columns;
++		row_drawing_marker = rows;
++		row_drawing_marker -= column_drawing_marker / 2;
++		sideLength = 30;
++
++		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
++				+ (sideLength / 2);
++		y_position_marker = (((double) height / 2)
++				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
++				+ (Math.sqrt(3) * (sideLength / 2));
++
++		initializeImages();
++	}
++
++	/**
++	 * Reads the images needed to display world objects and stores them in a
++	 * hashmap.
++	 */
++	private void initializeImages() {
++		pictures = new HashMap<String, Image>();
++		InputStream is1 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_0.png");
++		InputStream is2 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_60.png");
++		InputStream is3 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_120.png");
++		InputStream is4 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_180.png");
++		InputStream is5 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_240.png");
++		InputStream is6 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_300.png");
++		InputStream is7 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/rock.png");
++		InputStream is8 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/apple.png");
++		// TODO add general critter image
++
++		Image i1 = new Image(is1);
++		Image i2 = new Image(is2);
++		Image i3 = new Image(is3);
++		Image i4 = new Image(is4);
++		Image i5 = new Image(is5);
++		Image i6 = new Image(is6);
++		Image i7 = new Image(is7);
++		Image i8 = new Image(is8);
++
++		pictures.put("CRITTER_NORTH", i1);
++		pictures.put("CRITTER_NORTHEAST", i2);
++		pictures.put("CRITTER_SOUTHEAST", i3);
++		pictures.put("CRITTER_SOUTH", i4);
++		pictures.put("CRITTER_SOUTHWEST", i5);
++		pictures.put("CRITTER_NORTHWEST", i6);
++		pictures.put("ROCK", i7);
++		pictures.put("FOOD", i8);
++	}
++
++	/**
++	 * Determines whether or not a hex with column index {@code c} and row index
++	 * {@code r} is on the world grid.
++	 */
++	private boolean isValidHex(int c, int r) {
++		if (c < 0 || r < 0)
++			return false;
++		else if (c >= columns || r >= rows)
++			return false;
++		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
++			return false;
++		return true;
++	}
++
++	/** Redraws the world grid. */
++	public void draw() {
++		// resets the world grid
++		height = canvas.getHeight();
++		width = canvas.getWidth();
++		gc.clearRect(0, 0, width, height);
++		gc.setFill(BACKGROUND_COLOR);
++		gc.fillRect(0, 0, width, height);
++
++		// draws the hexagons and sets the origin
++		double hexMarkerX = x_position_marker;
++		double hexMarkerY = y_position_marker;
++		for (int i = 0; i < column_drawing_marker; i++) {
++			if (i % 2 == 0 && column_drawing_marker % 2 == 0) {
++				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
++			}
++			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
++				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
++				row_drawing_marker--;
++			}
++
++			for (int j = 0; j < row_drawing_marker; j++) {
++				drawHex(hexMarkerX, hexMarkerY);
++				hexMarkerY += (Math.sqrt(3) * (sideLength));
++			}
++
++			hexMarkerX += sideLength + (sideLength / 2);
++			hexMarkerY = y_position_marker;
++			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
++				row_drawing_marker++;
++			}
++		}
++		hexMarkerX = x_position_marker;
++		origin_x = hexMarkerX;
++		origin_y = hexMarkerY + (sideLength * (Math.sqrt(3)) * row_drawing_marker) - (Math.sqrt(3) * (sideLength / 2));
++		if (column_drawing_marker % 2 == 0)
++			origin_y += (sideLength / 2) * (Math.sqrt(3));
++		origin_y -= sideLength / 2 * Math.sqrt(3); // manual override of sujith's calculations
++
++		// draws the world objects in
++		drawObjects();
++
++		if (selectedHex != null) {
++			double[] highlightCoordinates = hexToCartesian(selectedHex);
++			highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
++		}
++	}
++
++	/** Used to update the grid and draw updates after each time step. */
++	public void updateGrid() {
++
++	}
++
++	/** Draws the world objects onto the grid. */
++	private void drawObjects() {
++		for (Map.Entry<SimpleCritter, Hex> entry : model.getCritterMap()) {
++			int c = entry.getValue().getColumnIndex();
++			int r = entry.getValue().getRowIndex();
++			drawCritter(entry.getKey(), c, r);
++		}
++
++		for (Map.Entry<WorldObject, Hex> entry : model.getObjectMap()) {
++			int c = entry.getValue().getColumnIndex();
++			int r = entry.getValue().getRowIndex();
++			drawWorldObject(entry.getKey(), c, r);
++		}
++	}
++
++	/**
++	 * Draws one critter onto the world grid.
++	 * 
++	 * @param sc
++	 * @param c
++	 * @param r
++	 */
++	private void drawCritter(SimpleCritter sc, int c, int r) {
++		if (!isValidHex(c, r))
++			return;
++
++		// convert to Cartesian coordinates
++		int hexCoordinates[] = new int[] { c, r };
++		double cartX = hexToCartesian(hexCoordinates)[0];
++		double cartY = hexToCartesian(hexCoordinates)[1];
++
++		if (sc == null) {
++			return;
++		}
++
++		int critterSize = sc.size();
++		double size = 0.9 * sideLength * (50 + critterSize / 2) / 100; // TODO this should vary based on critterSize
++
++		double[] xPoints = new double[3];
++		double[] yPoints = new double[3];
++
++		// determine critter orientation
++		int dir = sc.getOrientation();
++		switch (dir) {
++		case 0:
++			xPoints[0] = 0;
++			xPoints[1] = -size / 2;
++			xPoints[2] = size / 2;
++			yPoints[0] = -size / 2 * Math.sqrt(3);
++			yPoints[1] = size / 2 * Math.sqrt(3);
++			yPoints[2] = size / 2 * Math.sqrt(3);
++			break;
++		case 1:
++			xPoints[0] = 3 * size / 4;
++			xPoints[1] = -size;
++			xPoints[2] = -size / 2;
++			yPoints[0] = -size * Math.sqrt(3) / 4;
++			yPoints[1] = 0;
++			yPoints[2] = size * Math.sqrt(3) / 2;
++			break;
++		case 2:
++			xPoints[0] = 3 * size / 4;
++			xPoints[1] = -size / 2;
++			xPoints[2] = -size;
++			yPoints[0] = size * Math.sqrt(3) / 4;
++			yPoints[1] = -size * Math.sqrt(3) / 2;
++			yPoints[2] = 0;
++			break;
++		case 3:
++			xPoints[0] = 0;
++			xPoints[1] = size / 2;
++			xPoints[2] = -size / 2;
++			yPoints[0] = size / 2 * Math.sqrt(3);
++			yPoints[1] = -size / 2 * Math.sqrt(3);
++			yPoints[2] = -size / 2 * Math.sqrt(3);
++			break;
++		case 4:
++			xPoints[0] = -3 * size / 4;
++			xPoints[1] = size;
++			xPoints[2] = size / 2;
++			yPoints[0] = size * Math.sqrt(3) / 4;
++			yPoints[1] = 0;
++			yPoints[2] = -size * Math.sqrt(3) / 2;
++			break;
++		case 5:
++			xPoints[0] = -3 * size / 4;
++			xPoints[1] = size / 2;
++			xPoints[2] = size;
++			yPoints[0] = -size * Math.sqrt(3) / 4;
++			yPoints[1] = size * Math.sqrt(3) / 2;
++			yPoints[2] = 0;
++			break;
++		default:
++			return;
++		}
++
++		// translate points to current hex
++		for (int i = 0; i < 3; i++) {
++			xPoints[i] += cartX;
++		}
++		for (int i = 0; i < 3; i++) {
++			yPoints[i] += cartY;
++		}
++
++		// get critter color
++		String species = sc.getName();
++		int hash = species.hashCode();
++		Color color = new Color(0, 1, 0, 1);
++		System.out.println(hash);
++		
++		// draw critter
++		gc.setStroke(Color.LIME);
++		gc.strokePolygon(xPoints, yPoints, 3);
++	}
++
++	/**
++	 * Draws one non-critter object onto the world grid.
++	 * 
++	 * @param wo
++	 * @param c
++	 * @param r
++	 */
++	private void drawWorldObject(WorldObject wo, int c, int r) {
++		if (!isValidHex(c, r))
++			return;
++
++		int hexCoordinates[] = new int[] { c, r };
++		double cartX = hexToCartesian(hexCoordinates)[0];
++		double cartY = hexToCartesian(hexCoordinates)[1];
++
++		if (wo instanceof Rock) {
++			double size = 0.9 * sideLength;
++			gc.setFill(Color.BROWN);
++			gc.strokeRect(cartX - size / 2, cartY - size / 2, size, size);
++		}
++
++		else if (wo instanceof Food) {
++			int calories = ((Food) wo).getCalories();
++			double size = 0.9 * sideLength;
++			gc.setStroke(Color.RED);
++			gc.strokeOval(cartX - size / 2, cartY - size / 2, size, size);
++			gc.setTextAlign(TextAlignment.CENTER);
++			gc.setFont(new Font(8));
++			gc.strokeText(String.valueOf(calories), cartX, cartY);
++		}
++	}
++
++	/**
++	 * 
++	 * @param centerX
++	 * @param centerY
++	 */
++	private void drawHex(double centerX, double centerY) {
++		gc.setStroke(HEX_COLOR);
++		gc.strokePolygon(
++				new double[] { centerX + sideLength, centerX + (sideLength / 2), centerX - (sideLength / 2),
++						centerX - sideLength, centerX - (sideLength / 2), centerX + (sideLength / 2) },
++				new double[] { centerY, centerY - (Math.sqrt(3) * (sideLength / 2)),
++						centerY - (Math.sqrt(3) * (sideLength / 2)), centerY,
++						centerY + (Math.sqrt(3) * (sideLength / 2)), centerY + (Math.sqrt(3) * (sideLength / 2)) },
++				6);
++	}
++
++	/**
++	 * 
++	 * @param zoomIn
++	 */
++	public void zoom(boolean zoomIn) {
++		if (zoomIn) {
++			sideLength += ZOOM_FACTOR;
++			if (sideLength >= MAX_SIDELENGTH)
++				sideLength = MAX_SIDELENGTH;
++		} else {
++			sideLength -= ZOOM_FACTOR;
++			if (sideLength <= MIN_SIDELENGTH)
++				sideLength = MIN_SIDELENGTH;
++		}
++		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
++				+ (sideLength / 2);
++		y_position_marker = (((double) height / 2)
++				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
++				+ (Math.sqrt(3) * (sideLength / 2));
++		draw();
++	}
++
++	/**
++	 * highlightHex highlights the hex that is currently selected 
++	 * @param x xCoordinate of the spot that the user clicks
++	 * @param y yCooridnate of the spot that the user clicks
++	 */
++	public void highlightHex(double x, double y) {
++		int[] hexCoordinates = closestHex(x, y);
++		if (!isValidHex(hexCoordinates[0], hexCoordinates[1])) {
++			return;
++		}
++		double a = (double) sideLength; // for visual clarity in the calculations
++		double m = a * Math.sqrt(3) / 2.0; // for visual clarity in the calculations
++
++		double[] xPoints = { x + a, x + a / 2, x - a / 2, x - a, x - a / 2, x + a / 2 };
++		double[] yPoints = { y, y - m, y - m, y, y + m, y + m };
++
++		gc.setFill(HIGHLIGHT_COLOR);
++		gc.fillPolygon(xPoints, yPoints, 6);
++	}
++
++	/**
++	 * drag implements panning
++	 * @param deltaX 
++	 * @param deltaY
++	 */
++	public void drag(double deltaX, double deltaY) {
++		x_position_marker += deltaX * 0.05;
++		y_position_marker += deltaY * 0.05;
++		if (x_position_marker - sideLength > width)
++			x_position_marker = width - sideLength;
++		if ((((3 * sideLength) / 2) * column_drawing_marker + x_position_marker)< 0){
++			x_position_marker = (2*sideLength) - (((3 * sideLength) / 2) * column_drawing_marker);
++		}
++		if (y_position_marker > height)
++			y_position_marker = height - Math.sqrt(3)*sideLength;
++		if ((y_position_marker + Math.sqrt(3)*sideLength*row_drawing_marker) < 0)
++			y_position_marker = Math.sqrt(3)*sideLength-Math.sqrt(3)*sideLength*row_drawing_marker;
++		gc.clearRect(0, 0, width, height);
++		draw();
++	}
++
++	public boolean select(double xCoordinate, double yCoordinate) {
++		boolean returnValue;
++		int[] closestHexCoordinates = closestHex(xCoordinate, yCoordinate);
++		if (selectedHex != null && Arrays.equals(selectedHex, closestHexCoordinates)) {
++			selectedHex = null;
++			returnValue = false;
++		} else {
++			selectedHex = closestHexCoordinates;
++			returnValue = true;
++		}
++		double[] highlightCoordinates = hexToCartesian(closestHexCoordinates);
++		highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
++
++		draw();
++		return returnValue;
++	}
++
++	/**
++	 * A method that, given a set of rectangular canvas coordinates, returns the
++	 * coordinates of the hex it is located in.
++	 * 
++	 * @param xCoordinate
++	 * @param yCoordinate
++	 * @return An {@code int} array containing the (r, c) coordinates of the closest
++	 *         hex.
++	 */
++	public int[] closestHex(double xCoordinate, double yCoordinate) {
++		// determines the possible hexes that the point could be in
++		int possibleColumnOne = (int) Math.ceil(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
++		int possibleColumnTwo = (int) Math.floor(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
++		int possibleRowOne = (int) Math.ceil((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
++				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
++		int possibleRowTwo = (int) Math.floor((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
++				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
++
++		int[][] possibleCoordinates = new int[4][2];
++		possibleCoordinates[0] = new int[] { possibleColumnOne, possibleRowOne };
++		possibleCoordinates[1] = new int[] { possibleColumnOne, possibleRowTwo };
++		possibleCoordinates[2] = new int[] { possibleColumnTwo, possibleRowOne };
++		possibleCoordinates[3] = new int[] { possibleColumnTwo, possibleRowTwo };
++
++		double distanceSquared = Integer.MAX_VALUE;
++		int returnIndex = 0;
++		for (int i = 0; i < 4; i++) {
++			//System.out.println("Option #" + i + ": " + possibleCoordinates[i][0] + " " + possibleCoordinates[i][1]);
++			double tempArray[] = hexToCartesian(possibleCoordinates[i]);
++			double tempDistanceSquared = Math.pow(xCoordinate - tempArray[0], 2)
++					+ Math.pow(yCoordinate - tempArray[1], 2);
++			if (tempDistanceSquared < distanceSquared) {
++				distanceSquared = tempDistanceSquared;
++				returnIndex = i;
++			}
++		}
++		//System.out.println(possibleCoordinates[returnIndex][0] + " " + possibleCoordinates[returnIndex][1]);
++		//System.out.println("\n");
++		return possibleCoordinates[returnIndex];
++	}
++
++	/**
++	 * A method that converts a hex coordinate pair and gives the hex coordinates of
++	 * 
++	 * @param hexCoordinates
++	 * @return
++	 */
++	private double[] hexToCartesian(int[] hexCoordinates) {
++		double x_coordinate = ((3 * sideLength) / 2) * hexCoordinates[0] + origin_x;
++		double y_coordinate = ((Math.sqrt(3) * sideLength) / 2) * hexCoordinates[0]
++				- sideLength * Math.sqrt(3) * hexCoordinates[1] + origin_y;
++		return new double[] { x_coordinate, y_coordinate };
++	}
++
++	public int[] getSelectedHex() {
++		return selectedHex;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/gui/WorldModel.java b/src/main/java/gui/WorldModel.java
+new file mode 100644
+index 0000000..ce05af3
+--- /dev/null
++++ b/src/main/java/gui/WorldModel.java
+@@ -0,0 +1,90 @@
++package gui;
++
++import java.io.File;
++import java.io.FileNotFoundException;
++import java.util.Map;
++import java.util.Set;
++
++import simulation.SimpleCritter;
++import simulation.SimpleWorld;
++import simulation.World;
++import simulation.WorldObject;
++import simulation.Hex;
++
++public class WorldModel {
++	private SimpleWorld world;
++	int numCritters;
++	int time;
++
++	/** Creates a new blank world model. */
++	public WorldModel() {
++		numCritters = 0;
++		time = 0;
++	}
++
++	/** Creates a new random world. */
++	public void createNewWorld() {
++		world = new World();
++	}
++
++	/**
++	 * Loads in a world file.
++	 * 
++	 * @param worldfile
++	 * @throws FileNotFoundException
++	 *             if the file could not be found or is somehow invalid
++	 * @throws IllegalArgumentException
++	 *             if the constants.txt file could not be read
++	 */
++	public void loadWorld(File worldfile) throws FileNotFoundException, IllegalArgumentException {
++		world = new World(worldfile);
++	}
++
++	public boolean isReady() {
++		return world != null;
++	}
++
++	/** Returns the number of columns in the world. */
++	public int getColumns() {
++		return world.getColumns();
++	}
++
++	/** Returns the number of rows in the world. */
++	public int getRows() {
++		return world.getRows();
++	}
++
++	public synchronized int hexContent(int c, int r) {
++		return world.analyzeHex(c, r);
++	}
++
++	public synchronized SimpleCritter getCritter(int c, int r) {
++		return world.analyzeCritter(c, r);
++	}
++
++	public synchronized Set<Map.Entry<SimpleCritter, Hex>> getCritterMap() {
++		return world.getCritterMap();
++	}
++
++	public synchronized Set<Map.Entry<WorldObject, Hex>> getObjectMap() {
++		return world.getObjectMap();
++	}
++
++	/** Advances one time step. */
++	public synchronized void advanceTime() {
++		world.advanceOneTimeStep();
++		time++;
++		numCritters = world.numRemainingCritters();
++		//System.out.println(world.printGrid());
++	}
++
++	public synchronized void loadRandomCritters(File f, int n) {
++		world.loadCritters(f, n, -1);
++		numCritters = world.numRemainingCritters();
++	}
++	
++	public synchronized void loadCritterAtLocation(File f, int c, int r) {
++		world.loadCritterAtLocation(f, c, r);
++		numCritters = world.numRemainingCritters();
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/gui/gui.fxml b/src/main/java/gui/gui.fxml
+new file mode 100644
+index 0000000..9937ccf
+--- /dev/null
++++ b/src/main/java/gui/gui.fxml
+@@ -0,0 +1,143 @@
++<?xml version="1.0" encoding="UTF-8"?>
++
++<?import javafx.scene.canvas.Canvas?>
++<?import javafx.scene.control.Button?>
++<?import javafx.scene.control.Label?>
++<?import javafx.scene.control.Menu?>
++<?import javafx.scene.control.MenuBar?>
++<?import javafx.scene.control.MenuItem?>
++<?import javafx.scene.control.RadioButton?>
++<?import javafx.scene.control.ScrollPane?>
++<?import javafx.scene.control.Slider?>
++<?import javafx.scene.control.SplitPane?>
++<?import javafx.scene.control.TextArea?>
++<?import javafx.scene.control.TextField?>
++<?import javafx.scene.control.TitledPane?>
++<?import javafx.scene.control.ToggleGroup?>
++<?import javafx.scene.layout.AnchorPane?>
++<?import javafx.scene.layout.HBox?>
++<?import javafx.scene.text.Font?>
++<?import javafx.scene.text.Text?>
++
++<AnchorPane prefHeight="900.0" prefWidth="1600.0" xmlns="http://javafx.com/javafx/9.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="gui.Controller">
++   <children>
++      <MenuBar fx:id="Menu" prefHeight="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
++         <menus>
++            <Menu mnemonicParsing="false" text="File">
++               <items>
++                  <MenuItem fx:id="help" mnemonicParsing="false" text="Help" />
++                  <MenuItem fx:id="close" mnemonicParsing="false" onAction="#close" text="Close" />
++               </items>
++            </Menu>
++         </menus>
++      </MenuBar>
++      <HBox alignment="BOTTOM_LEFT" layoutY="774.0" prefHeight="25.0" AnchorPane.bottomAnchor="2.1316282072803006E-14" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0">
++         <children>
++            <SplitPane dividerPositions="0.5" prefHeight="26.0" style="-fx-background-color: lightgray;" HBox.hgrow="ALWAYS">
++              <items>
++                  <HBox alignment="CENTER" prefHeight="25.0" prefWidth="200.0">
++                     <children>
++                        <Label fx:id="crittersAlive" alignment="CENTER" text="Critters Alive: 0" />
++                     </children>
++                  </HBox>
++                  <HBox alignment="CENTER" prefHeight="100.0" prefWidth="200.0">
++                     <children>
++                        <Label fx:id="stepsTaken" text="Time: 0" />
++                     </children>
++                  </HBox>
++              </items>
++            </SplitPane>
++         </children></HBox>
++      <AnchorPane layoutX="749.0" layoutY="25.0" prefHeight="775.0" prefWidth="250.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="25.0">
++         <children>
++            <TitledPane animated="false" layoutY="-3.0" minHeight="274.0" prefHeight="274.0" prefWidth="250.0" text="World Info" AnchorPane.bottomAnchor="510.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
++               <content>
++                  <ScrollPane fitToWidth="true" hbarPolicy="NEVER" prefWidth="248.0">
++                    <content>
++                      <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="333.0" prefWidth="248.0">
++                           <children>
++                              <Label layoutX="10.0" layoutY="16.0" prefHeight="10.0" text="Column" />
++                              <Label layoutX="110.0" layoutY="16.0" prefHeight="10.0" prefWidth="39.0" text="Row" />
++                              <Label layoutX="10.0" layoutY="37.0" prefHeight="21.0" prefWidth="69.0" text="Mem Size" />
++                              <Label layoutX="10.0" layoutY="59.0" prefHeight="10.0" prefWidth="60.0" text="Defense" />
++                              <Label layoutX="110.0" layoutY="59.0" prefHeight="10.0" prefWidth="57.0" text="Offense" />
++                              <Label layoutX="10.0" layoutY="80.0" prefHeight="10.0" prefWidth="55.0" text="Energy" />
++                              <Label layoutX="110.0" layoutY="80.0" prefHeight="10.0" prefWidth="35.0" text="Pass" />
++                              <Label layoutX="10.0" layoutY="99.0" prefHeight="10.0" prefWidth="35.0" text="Tag" />
++                              <Label layoutX="110.0" layoutY="99.0" prefHeight="10.0" prefWidth="54.0" text="Posture" />
++                              <Label layoutX="110.0" layoutY="37.0" text="Species" />
++                              <TextArea fx:id="lastRuleDisplay" layoutX="41.0" layoutY="120.0" prefHeight="150.0" prefWidth="167.0" />
++                              <Button fx:id="displayProgram" layoutX="60.0" layoutY="277.0" mnemonicParsing="false" onMouseClicked="#handleDisplayProgram" text="Display Program" />
++                              <Text fx:id="columnText" layoutX="70.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
++                              <Text fx:id="rowText" layoutX="147.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="27.0" />
++                              <Text fx:id="memSizeText" layoutX="81.0" layoutY="53.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="28.0" />
++                              <Text fx:id="speciesText" layoutX="170.0" layoutY="52.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="76.0" />
++                              <Text fx:id="defenseText" layoutX="70.0" layoutY="75.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
++                              <Text fx:id="offenseText" layoutX="179.0" layoutY="74.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
++                              <Text fx:id="energyText" layoutX="65.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
++                              <Text fx:id="passText" layoutX="146.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
++                              <Text fx:id="tagText" layoutX="39.0" layoutY="115.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
++                              <Text fx:id="postureText" layoutX="164.0" layoutY="114.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
++                              <Label layoutX="176.0" layoutY="16.0" text="Size" />
++                              <Text fx:id="sizeText" layoutX="208.0" layoutY="29.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="40.0" />
++                           </children></AnchorPane>
++                    </content>
++                  </ScrollPane>
++               </content>
++            </TitledPane>
++            <TitledPane animated="false" layoutY="300.0" minHeight="100.0" prefHeight="100.0" prefWidth="250.0" text="Create World" AnchorPane.bottomAnchor="410.0">
++               <content>
++                  <AnchorPane minHeight="0.0" minWidth="0.0" prefWidth="239.0">
++                     <children>
++                        <Button fx:id="newWorld" layoutX="33.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleNewWorldPressed" text="New World" />
++                        <Button fx:id="loadWorld" layoutX="136.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleLoadWorldPressed" text="Load World" />
++                     </children>
++                  </AnchorPane>
++               </content>
++            </TitledPane>
++            <TitledPane animated="false" layoutY="400.0" minHeight="260.0" prefHeight="260.0" prefWidth="250.0" text="World Controls" AnchorPane.bottomAnchor="150.0">
++               <content>
++                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="0.0" prefWidth="249.0">
++                     <children>
++                        <Button fx:id="loadCritterFile" layoutX="14.0" layoutY="14.0" mnemonicParsing="false" onMousePressed="#handleLoadCritters" text="Load Critter File" />
++                        <RadioButton fx:id="chkRand" layoutX="24.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkRandom" text="Random hex">
++                           <toggleGroup>
++                              <ToggleGroup fx:id="LoadChoice" />
++                           </toggleGroup>
++                        </RadioButton>
++                        <RadioButton fx:id="chkSpecify" layoutX="143.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkSpecify" text="Specify hex">
++                           <toggleGroup>
++                              <ToggleGroup fx:id="HexChoice" />
++                           </toggleGroup></RadioButton>
++                        <TextField fx:id="numCritters" layoutX="201.0" layoutY="15.0" prefHeight="23.0" prefWidth="30.0">
++                           <font>
++                              <Font size="10.0" />
++                           </font>
++                        </TextField>
++                        <Label layoutX="144.0" layoutY="18.0" text="Number" />
++                        <Button fx:id="stepForward" layoutX="83.0" layoutY="102.0" mnemonicParsing="false" onMousePressed="#handleStep" text="Step Forward" />
++                        <Button fx:id="run" layoutX="42.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handleRunPressed" text=" Run " />
++                        <Button fx:id="pause" layoutX="166.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handlePauseClicked" text="Pause" />
++                        <Button fx:id="reset" layoutX="104.0" layoutY="190.0" mnemonicParsing="false" onMousePressed="#handleResetClicked" text="Reset" />
++                     </children>
++                  </AnchorPane>
++               </content>
++            </TitledPane>
++            <TitledPane animated="false" layoutY="660.0" minHeight="150.0" prefHeight="150.0" prefWidth="250.0" text="Simulation Controls" AnchorPane.bottomAnchor="0.0">
++               <content>
++                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="250.0" prefWidth="250.0">
++                     <children>
++                        <Slider fx:id="simulationSpeed" layoutX="24.0" layoutY="22.0" prefHeight="80.0" prefWidth="200.0" showTickLabels="true" showTickMarks="true" value="30.0" />
++                     </children>
++                  </AnchorPane>
++               </content>
++            </TitledPane>
++         </children>
++      </AnchorPane>
++      <ScrollPane fx:id="scroll" fitToHeight="true" fitToWidth="true" hbarPolicy="NEVER" layoutY="25.0" prefHeight="775.0" prefWidth="750.0" vbarPolicy="NEVER" AnchorPane.bottomAnchor="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0" AnchorPane.topAnchor="25.0">
++         <content>
++            <Canvas fx:id="c" height="775.0" onMouseDragged="#handleMapDrag" onMousePressed="#handleMapClicked" onScroll="#handleMapScroll" width="750.0" />
++         </content>
++      </ScrollPane>
++   </children>
++</AnchorPane>
+diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
+index 18973a1..bd7e371 100644
+--- a/src/main/java/interpret/InterpreterImpl.java
++++ b/src/main/java/interpret/InterpreterImpl.java
+@@ -28,6 +28,7 @@ public class InterpreterImpl implements Interpreter
+ 	{
+ 		Action a = interpret(c.getProgram());
+ 		executeAction(a);
++		//System.out.println("AS");
+ 	}
+ 	
+ 	/**
+diff --git a/src/main/java/main/ParseAndMutateApp.java b/src/main/java/main/ParseAndMutateApp.java
+index e522bf9..474024a 100644
+--- a/src/main/java/main/ParseAndMutateApp.java
++++ b/src/main/java/main/ParseAndMutateApp.java
+@@ -4,64 +4,53 @@ import java.io.*;
+ import ast.*;
+ import parse.*;
+ 
+-public class ParseAndMutateApp
+-{
+-
+-	public static void main(String[] args) throws Exception
+-	{
++public class ParseAndMutateApp {
++	public static void main(String[] args) throws Exception {
+ 		int n = 0;
+ 		String file;
+-		try
+-		{
+-			if (args.length == 1)
+-			{
++		try {
++			if (args.length == 1) {
+ 				file = args[0];
+ 				InputStream in = new FileInputStream(file);
+-		        Reader r = new BufferedReader(new InputStreamReader(in));
+-		        Parser p = ParserFactory.getParser();
+-		        Program critter = p.parse(r);
+-		        System.out.println(critter.toString());
+-		        
+-			}
+-			else if (args.length == 3 && args[0].equals("--mutate"))
+-			{
++				Reader r = new BufferedReader(new InputStreamReader(in));
++				Parser p = ParserFactory.getParser();
++				Program critter = p.parse(r);
++				System.out.println(critter.toString());
++
++			} else if (args.length == 3 && args[0].equals("--mutate")) {
+ 				n = parsePositive(args[1]);
+ 				file = args[2];
+ 				InputStream in = new FileInputStream(file);
+-		        Reader r = new BufferedReader(new InputStreamReader(in));
+-		        Parser p = ParserFactory.getParser();
+-		        Program critter = p.parse(r);
+-		        
+-		        for(int i = 0; i < n; i++)
+-		        	critter = critter.mutate();
+-		        
+-		        System.out.println(critter.toString());
+-			}
+-			else
+-			{
++				Reader r = new BufferedReader(new InputStreamReader(in));
++				Parser p = ParserFactory.getParser();
++				Program critter = p.parse(r);
++
++				for (int i = 0; i < n; i++)
++					critter = critter.mutate();
++
++				System.out.println(critter.toString());
++			} else {
+ 				throw new IllegalArgumentException();
+ 			}
+-			// TODO print program and mutations
+-		}
+-		catch (IllegalArgumentException | ArrayIndexOutOfBoundsException e)
+-		{
++		} catch (IllegalArgumentException | ArrayIndexOutOfBoundsException e) {
+ 			System.out.println("Usage:\n" + "  <input_file>\n" + "  --mutate <n> <input_file");
+-		}
+-		catch (FileNotFoundException f)
+-		{
++		} catch (FileNotFoundException f) {
+ 			System.out.println("File not found.");
+ 		}
+ 	}
+ 
+ 	/**
+ 	 * Parses {@code str} to an integer.
+-	 * @param str - the string to parse
++	 * 
++	 * @param str
++	 *            - the string to parse
+ 	 * @return the integer represented by {@code str}
+-	 * @throws NumberFormatException if {@code str} does not contain a parsable integer
+-	 * @throws IllegalArgumentException if {@code str} represents a negative integer
++	 * @throws NumberFormatException
++	 *             if {@code str} does not contain a parsable integer
++	 * @throws IllegalArgumentException
++	 *             if {@code str} represents a negative integer
+ 	 */
+-	public static int parsePositive(String str)
+-	{
++	public static int parsePositive(String str) {
+ 		int n = Integer.parseInt(str);
+ 		if (n < 0)
+ 			throw new IllegalArgumentException();
+diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
+index 0d04293..a0cf4e4 100644
+--- a/src/main/java/parse/ParserImpl.java
++++ b/src/main/java/parse/ParserImpl.java
+@@ -341,8 +341,6 @@ class ParserImpl implements Parser {
+ 		return expression;
+ 	}
+ 
+-	// TODO
+-	// add more as necessary...
+ 
+ 	/**
+ 	 * Consumes a token of the expected type.
+diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
+index a58087f..067a9c8 100644
+--- a/src/main/java/simulation/AbstractWorld.java
++++ b/src/main/java/simulation/AbstractWorld.java
+@@ -44,18 +44,20 @@ public abstract class AbstractWorld implements SimpleWorld
+ 	public void advanceOneTimeStep()
+ 	{
+ 		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
++		System.out.println(clone.toString());
+ 		for(int i = 0; i < clone.size(); i++)
+ 		{
+ 			SimpleCritter sc = clone.get(i);
+ 			Interpreter im = new InterpreterImpl(sc, this);
+ 			im.simulateCritterTurn();
++			//System.out.println("AH");
+ 		}
+ 		
+ 		for(int i = 0; i < clone.size(); i++)
+ 		{
+ 			SimpleCritter sc = clone.get(i);
+ 			sc.toggleMatingPheromones(false);
+-}
++		}
+ 		
+ 		timePassed++;
+ 	}
+diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
+index ac97405..d551c22 100644
+--- a/src/main/java/simulation/SimpleWorld.java
++++ b/src/main/java/simulation/SimpleWorld.java
+@@ -1,8 +1,18 @@
+ package simulation;
+ 
++import java.io.File;
++import java.util.Map;
++import java.util.Set;
++
+ /** An interface containing the basic functions of the world. */
+ public interface SimpleWorld
+ {
++	/** Returns the number of columns in this world. */
++	int getColumns();
++	
++	/** Returns the number of rows in this world. */
++	int getRows();
++	
+ 	/** Returns the minimum critter memory size for this world. Cannot be less than 8. */
+ 	int getMinMemory();
+ 	
+@@ -24,14 +34,31 @@ public interface SimpleWorld
+ 	 */
+ 	void loadCritters(String filename, int n, int direction);
+ 	
++	/**
++	 * Loads critters of following a set pattern into this world.
++	 * @param file the file containing the critter information
++	 * @param n the number of critters to load
++	 * @param direction the orientation of the critter. If this value is less than 0, a critter orientation
++	 * 					will be chosen at random.
++	 */
++	void loadCritters(File file, int n, int direction);
++	
++	void loadCritterAtLocation(File file, int c, int r);
++	
+ 	/** Advances the world state by a single time step. */
+ 	void advanceOneTimeStep();
+ 	
+ 	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
+ 	boolean isValidHex(int c, int r);
+ 	
++	/** Returns an entry set mapping the world critters to hex locations. */
++	Set<Map.Entry<SimpleCritter, Hex>> getCritterMap();
++	
++	/** Returns an entry set mapping the world objects to hex locations. */
++	Set<Map.Entry<WorldObject, Hex>> getObjectMap();
++	
+ 	/**
+-	 * Returns information about a hex. Assumes that the 
++	 * Returns information about a hex.
+ 	 * @param c
+ 	 * @param r
+ 	 * @return
+@@ -39,7 +66,7 @@ public interface SimpleWorld
+ 	int analyzeHex(int c, int r);
+ 	
+ 	/**
+-	 * 
++	 * Returns the critter on a hex, for analysis.
+ 	 * @param c
+ 	 * @param r
+ 	 * @return
+diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
+index ae9bd56..ee3704d 100644
+--- a/src/main/java/simulation/World.java
++++ b/src/main/java/simulation/World.java
+@@ -1,13 +1,16 @@
+ package simulation;
+ 
+ import java.io.BufferedReader;
++import java.io.File;
+ import java.io.FileNotFoundException;
+ import java.io.FileReader;
+ import java.io.InputStream;
+ import java.io.InputStreamReader;
+ import java.util.HashMap;
+ import java.util.LinkedList;
++import java.util.Map;
+ import java.util.Random;
++import java.util.Set;
+ 
+ import ast.Program;
+ import ast.ProgramImpl;
+@@ -20,8 +23,10 @@ public class World extends AbstractWorld
+ 	private String worldname;
+ 	/** Contains the hex grid of the world. */
+ 	private Hex[][] grid;
+-	/** Maps each critter to a location in the world */
++	/** Maps each critter to a location in the world. */
+ 	private HashMap<SimpleCritter, Hex> critterMap;
++	/** Maps each non critter object to a location in the world. */
++	private HashMap<WorldObject, Hex> nonCritterObjectMap;
+ 	/** The number of columns in the world grid. */
+ 	private int columns;
+ 	/** The number of rows in the world grid. */
+@@ -42,6 +47,7 @@ public class World extends AbstractWorld
+ 		super();
+ 		setConstants();
+ 		critterMap = new HashMap<SimpleCritter, Hex>();
++		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+ 		super.critterList = new LinkedList<SimpleCritter>();
+ 		super.timePassed = 0;
+ 
+@@ -121,6 +127,98 @@ public class World extends AbstractWorld
+ 		}
+ 	}
+ 
++	/**
++	 * Loads a world from a world description file, in the form of a pre-determined file.
++	 * 
++	 * @param filename The name of the file that contains world information.
++	 * @throws FileNotFoundException if the world file could not be found
++	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
++	 */
++	public World(File file) throws FileNotFoundException, IllegalArgumentException
++	{
++		// sets constants and initializes instance fields
++		super();
++		setConstants();
++		critterMap = new HashMap<SimpleCritter, Hex>();
++		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
++		super.critterList = new LinkedList<SimpleCritter>();
++		super.timePassed = 0;
++
++		BufferedReader bf = new BufferedReader(new FileReader(file));
++
++		// parses the world name, and if no valid one is parsed, supplies a default one
++		worldname = FileParser.parseAttributeFromLine(bf, "name ");
++		if (worldname.equals(""))
++			worldname = "Arrakis";
++
++		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
++		try
++		{
++			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
++			String[] dim = worldDimensions.split(" ");
++			columns = Integer.parseInt(dim[0]);
++			rows = Integer.parseInt(dim[1]);
++
++			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
++			{
++				columns = CONSTANTS.get("COLUMNS").intValue();
++				rows = CONSTANTS.get("ROWS").intValue();
++			}
++		}
++		catch (Exception e)
++		{
++			columns = CONSTANTS.get("COLUMNS").intValue();
++			rows = CONSTANTS.get("ROWS").intValue();
++		}
++		numValidHexes = 0;
++
++		// initializes world grid
++		grid = new Hex[columns][rows];
++		for (int i = 0; i < grid.length; i++)
++			for (int j = 0; j < grid[0].length; j++)
++				if (isValidHex(i, j))
++				{
++					grid[i][j] = new Hex(i, j);
++					numValidHexes++;
++				}
++
++		try
++		{
++			// loads in world objects from file
++			String line = bf.readLine();
++			while (line != null)
++			{
++				String[] info = line.split(" ");
++				switch (info[0])
++				{
++					case "rock":
++						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
++						break;
++					case "food":
++						Food f = new Food(Integer.parseInt(info[3]));
++						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
++						break;
++					case "critter":
++						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
++						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
++								Integer.parseInt(info[4]));
++						if(sc == null)
++						{
++							System.err.println("The critter file " + file.toString() + " does not have the right syntax, so it was not loaded.");
++							break;
++						}
++							
++						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
++						break;
++				}
++				line = bf.readLine();
++			}
++		}
++		catch (Exception e)
++		{
++			return;
++		}
++	}
+ 	/**
+ 	 * Generates a default size world containing nothing but randomly placed rocks.
+ 	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
+@@ -132,6 +230,7 @@ public class World extends AbstractWorld
+ 		worldname = "Arrakis";
+ 		setConstants();
+ 		critterMap = new HashMap<SimpleCritter, Hex>();
++		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+ 		critterList = new LinkedList<SimpleCritter>();
+ 		timePassed = 0;
+ 
+@@ -163,7 +262,7 @@ public class World extends AbstractWorld
+ 			r = (int) (Math.random() * rows);
+ 			if (isValidHex(c, r))
+ 			{
+-				grid[c][r].addContent(new Rock());
++				addNonCritterObject(new Rock(), c, r);
+ 				n++;
+ 			}
+ 		}
+@@ -175,17 +274,28 @@ public class World extends AbstractWorld
+ 	 */
+ 	private void setConstants() throws IllegalArgumentException
+ 	{
+-		InputStream in = World.class.getResourceAsStream("constants.txt");
++		InputStream in = World.class.getClassLoader().getResourceAsStream("simulation/constants.txt");
+ 		if(in == null)
+ 		{ 
+-			System.err.println("The constants.txt file could not be found in bin/simulation.");
+-			System.exit(0);
++			throw new IllegalArgumentException();
+ 		}
+ 		
+ 		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
+ 		CONSTANTS = FileParser.parseConstants(bf);
+ 	}
+ 
++	@Override
++	public int getColumns()
++	{
++		return columns;
++	}
++	
++	@Override
++	public int getRows()
++	{
++		return rows;
++	}
++	
+ 	@Override
+ 	public boolean isValidHex(int c, int r)
+ 	{
+@@ -199,7 +309,7 @@ public class World extends AbstractWorld
+ 	}
+ 
+ 	@Override
+-	public void loadCritters(String filename, int n, int direction)
++	public synchronized void loadCritters(String filename, int n, int direction)
+ 	{
+ 		try
+ 		{
+@@ -228,6 +338,53 @@ public class World extends AbstractWorld
+ 		}
+ 	}
+ 
++	@Override
++	public void loadCritters(File file, int n, int direction)
++	{
++		try
++		{
++			BufferedReader br = new BufferedReader(new FileReader(file));
++			//SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
++
++			for (int i = 0; i < n; i++)
++			{
++				SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
++				int randc = (int) (Math.random() * columns);
++				int randr = (int) (Math.random() * rows);
++				while (!isValidHex(randc, randr))
++				{
++					randc = (int) (Math.random() * columns);
++					randr = (int) (Math.random() * rows);
++				}
++
++				if (isValidHex(randc, randr))
++					loadOneCritter(sc, randc, randr);
++			}
++		}
++		catch (FileNotFoundException e)
++		{
++			System.err.println("Critter file not found.");
++			return;
++		}
++	}
++	
++	@Override
++	public void loadCritterAtLocation(File file, int c, int r)
++	{
++		try
++		{
++			BufferedReader br = new BufferedReader(new FileReader(file));
++			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), -1);
++			if(isValidHex(c, r))
++				loadOneCritter(sc, c, r);
++		}
++		catch (FileNotFoundException e)
++		{
++			System.err.println("Critter file not found.");
++			return;
++		}
++	}
++	
+ 	/**
+ 	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
+ 	 * the hex is not within the world boundaries, or if there is something already present at the hex.
+@@ -264,6 +421,7 @@ public class World extends AbstractWorld
+ 			return;
+ 		if (!isValidHex(c, r))
+ 			return;
++		nonCritterObjectMap.put(wo, grid[c][r]);
+ 		grid[c][r].addContent(wo);
+ 	}
+ 
+@@ -401,6 +559,7 @@ public class World extends AbstractWorld
+ 		{
+ 			Food nourishment = (Food) directlyInFront.getContent();
+ 			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++			nonCritterObjectMap.remove(nourishment);
+ 			directlyInFront.removeContent();
+ 		}
+ 		if (sc.getEnergy() == 0)
+@@ -783,6 +942,7 @@ public class World extends AbstractWorld
+ 		if (directlyInFront.isEmpty())
+ 		{
+ 			Food f = new Food(index);
++			nonCritterObjectMap.put(f, directlyInFront);
+ 			directlyInFront.addContent(f);
+ 		}
+ 		if (donator.getEnergy() == 0)
+@@ -804,6 +964,7 @@ public class World extends AbstractWorld
+ 		critterList.remove(sc);
+ 
+ 		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
++		nonCritterObjectMap.put(remnant, location);
+ 		location.addContent(remnant);
+ 	}
+ 
+@@ -827,6 +988,18 @@ public class World extends AbstractWorld
+ 		return result;
+ 	}
+ 	
++	@Override
++	public Set<Map.Entry<SimpleCritter, Hex>> getCritterMap()
++	{
++		return critterMap.entrySet();
++	}
++	
++	@Override
++	public Set<Map.Entry<WorldObject, Hex>> getObjectMap()
++	{
++		return nonCritterObjectMap.entrySet();
++	}
++	
+ 	@Override
+ 	public int analyzeHex(int c, int r)
+ 	{
+diff --git a/src/main/resources/simulation/constants.txt b/src/main/resources/simulation/constants.txt
+new file mode 100644
+index 0000000..52649f0
+--- /dev/null
++++ b/src/main/resources/simulation/constants.txt
+@@ -0,0 +1,19 @@
++BASE_DAMAGE 100 {The multiplier for all damage done by attacking}
++DAMAGE_INC 0.2 {Controls how quickly increased offensive or defensive ability affects damage}
++ENERGY_PER_SIZE 500 {How much energy a critter can have per point of size}
++FOOD_PER_SIZE 200 {How much food is created per point of size when a critter dies}
++MAX_SMELL_DISTANCE 10 {Maximum distance at which food can be sensed}
++ROCK_VALUE -1 {The value reported when a rock is sensed}
++COLUMNS 50 {Default number of columns in the world map}
++ROWS 68 {Default number of rows in the world map}
++MAX_RULES_PER_TURN 999 {The maximum number of rules that can be run per critter turn}
++SOLAR_FLUX 1 {Energy gained from sun by doing nothing}
++MOVE_COST 3 {Energy cost of moving (per unit size)}
++ATTACK_COST 5 {Energy cost of attacking (per unit size)}
++GROW_COST 1 {Energy cost of growing (per size and complexity)}
++BUD_COST 9 {Energy cost of budding (per unit complexity)}
++MATE_COST 5 {Energy cost of successful mating (per unit complexity)}
++RULE_COST 2 {Complexity cost of having a rule}
++ABILITY_COST 25 {Complexity cost of having an ability point}
++INITIAL_ENERGY 250 {Energy of a newly birthed critter}
++MIN_MEMORY 8 {Minimum number of memory entries in a critter}
+\ No newline at end of file
+diff --git a/src/test/java/mutationtests/TestMutateDuplicate.java b/src/test/java/mutationtests/TestMutateDuplicate.java
+index 5d75a27..08c2045 100644
+--- a/src/test/java/mutationtests/TestMutateDuplicate.java
++++ b/src/test/java/mutationtests/TestMutateDuplicate.java
+@@ -9,7 +9,6 @@ import org.junit.Before;
+ import org.junit.Test;
+ 
+ import ast.MutationDuplicate;
+-import ast.MutationReplace;
+ import ast.Program;
+ import parse.Parser;
+ import parse.ParserFactory;
+diff --git a/src/test/java/mutationtests/TestMutateInsert.java b/src/test/java/mutationtests/TestMutateInsert.java
+index e1a07bd..3e0c2e6 100644
+--- a/src/test/java/mutationtests/TestMutateInsert.java
++++ b/src/test/java/mutationtests/TestMutateInsert.java
+@@ -8,15 +8,7 @@ import java.io.Reader;
+ import org.junit.Before;
+ import org.junit.Test;
+ 
+-import ast.BinaryExpr;
+-import ast.Condition;
+-import ast.MutationInsert;
+-import ast.MutationRemove;
+-import ast.Node;
+-import ast.Program;
+-import ast.Relation;
+-import ast.Sensor;
+-import ast.UnaryExpr;
++import ast.*;
+ import parse.Parser;
+ import parse.ParserFactory;
+ import parsertests.ASTParserTest;
+diff --git a/src/test/java/mutationtests/TestMutateRemove.java b/src/test/java/mutationtests/TestMutateRemove.java
+index f20e9c7..3daa497 100644
+--- a/src/test/java/mutationtests/TestMutateRemove.java
++++ b/src/test/java/mutationtests/TestMutateRemove.java
+@@ -129,7 +129,6 @@ public class TestMutateRemove
+ 		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+ 		
+ 		int previousSize = be.size();
+-		String before = be.toString();
+ 		ue.acceptMutation(new MutationRemove(true));
+ 		assertTrue(previousSize > be.size());
+ 		assertTrue("3 + 2".equals(be.toString()));
+diff --git a/src/test/java/mutationtests/TestMutateReplace.java b/src/test/java/mutationtests/TestMutateReplace.java
+index 5f70bb3..8d7b7c8 100644
+--- a/src/test/java/mutationtests/TestMutateReplace.java
++++ b/src/test/java/mutationtests/TestMutateReplace.java
+@@ -9,7 +9,6 @@ import org.junit.Before;
+ import org.junit.Test;
+ 
+ import ast.MutationReplace;
+-import ast.MutationTransform;
+ import ast.Program;
+ import parse.Parser;
+ import parse.ParserFactory;
+diff --git a/src/test/java/mutationtests/TestMutateSwap.java b/src/test/java/mutationtests/TestMutateSwap.java
+index d5b046b..ed4310f 100644
+--- a/src/test/java/mutationtests/TestMutateSwap.java
++++ b/src/test/java/mutationtests/TestMutateSwap.java
+@@ -1,27 +1,18 @@
+ package mutationtests;
+ 
+-import static org.junit.Assert.*;
+-
+ import java.io.BufferedReader;
+ import java.io.InputStream;
+ import java.io.InputStreamReader;
+ import java.io.Reader;
+-import java.util.LinkedList;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+ 
+-import ast.BinaryExpr;
+-import ast.Command;
+-import ast.MutationInsert;
+-import ast.BinaryExpr.*;
+ import parse.Parser;
+ import parse.ParserFactory;
+ import parsertests.ASTParserTest;
+ import ast.MutationSwap;
+ import ast.Program;
+-import ast.UnaryExpr;
+-import ast.Update;
+ 
+ /**
+  * 
+diff --git a/src/test/java/mutationtests/TestMutateTransform.java b/src/test/java/mutationtests/TestMutateTransform.java
+index 4011203..64a4d81 100644
+--- a/src/test/java/mutationtests/TestMutateTransform.java
++++ b/src/test/java/mutationtests/TestMutateTransform.java
+@@ -4,23 +4,11 @@ import java.io.BufferedReader;
+ import java.io.InputStream;
+ import java.io.InputStreamReader;
+ import java.io.Reader;
+-import java.util.LinkedList;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+ 
+-import ast.Action;
+-import ast.BinaryCondition;
+-import ast.BinaryExpr;
+-import ast.Command;
+-import ast.Condition;
+-import ast.MutationRemove;
+-import ast.MutationTransform;
+-import ast.Program;
+-import ast.Relation;
+-import ast.Sensor;
+-import ast.UnaryExpr;
+-import ast.Update;
++import ast.*;
+ import parse.Parser;
+ import parse.ParserFactory;
+ import parsertests.ASTParserTest;
+diff --git a/src/test/java/parsertests/ASTParserTest.java b/src/test/java/parsertests/ASTParserTest.java
+index 2789d73..68bb998 100644
+--- a/src/test/java/parsertests/ASTParserTest.java
++++ b/src/test/java/parsertests/ASTParserTest.java
+@@ -12,7 +12,6 @@ import org.junit.Test;
+ import ast.Program;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parse.Tokenizer;
+ 
+ /** This class contains tests for the Critter parser. */
+ public class ASTParserTest
+diff --git a/src/test/java/parsertests/FileParserTest.java b/src/test/java/parsertests/FileParserTest.java
+index 52571a2..bbf97a5 100644
+--- a/src/test/java/parsertests/FileParserTest.java
++++ b/src/test/java/parsertests/FileParserTest.java
+@@ -59,7 +59,7 @@ public class FileParserTest
+ 	}
+ 	
+ 	@Test
+-	public void testConsoleLoad() //TODO remove when done testing
++	public void testConsoleLoad()
+ 	{
+ 		try
+ 		{
+@@ -72,6 +72,7 @@ public class FileParserTest
+ 			Program prog = p.parse(br);
+ 			
+ 			SimpleCritter sc = new Critter(prog, critAttr, name, -1);
++			sc.getEnergy();
+ 		}
+ 		catch (FileNotFoundException e)
+ 		{
+diff --git a/src/test/java/simulationTests/BudTest.java b/src/test/java/simulationTests/BudTest.java
+deleted file mode 100644
+index e24891d..0000000
+--- a/src/test/java/simulationTests/BudTest.java
++++ /dev/null
+@@ -1,67 +0,0 @@
+-package simulationTests;
+-
+-import static org.junit.Assert.*;
+-
+-import org.junit.Before;
+-import org.junit.Test;
+-
+-import console.Console;
+-
+-public class BudTest {
+-
+-	Console console1 = null;
+-	Console console2 = null;
+-	Console console3 = null;
+-
+-	@Before
+-	public void setup() {
+-		console1 = new Console();
+-		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
+-		console2 = new Console();
+-		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
+-		console3 = new Console();
+-		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
+-	}
+-
+-	/**
+-	 * testBasicBud checks to see if a critter can bud under normal circumstances.
+-	 */
+-	@Test
+-	public void testBasicBud() {
+-		System.out.println("testBasicBud");
+-		int initialNumCritters = console1.crittersAlive();
+-		console1.worldInfo();
+-		console1.advanceTime(1);
+-		console1.worldInfo();
+-		assertEquals(initialNumCritters + 1, console1.crittersAlive());
+-	}
+-
+-	/**
+-	 * testBudWithRock checks to see that a critter does not bud when there is a
+-	 * rock behind it.
+-	 */
+-	@Test
+-	public void testBudWithRock() {
+-		System.out.println("testBudWithRock");
+-		int initialNumCritters = console2.crittersAlive();
+-		console2.worldInfo();
+-		console2.advanceTime(1);
+-		console2.worldInfo();
+-		assertEquals(initialNumCritters, console2.crittersAlive());
+-	}
+-
+-	/**
+-	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
+-	 * It also tests to see if critter death properly adds a food object onto the site of death.
+-	 */
+-	@Test
+-	public void testBudNoEnergy() {
+-		System.out.println("testBudNoEnergy");
+-		int initialNumCritters = console3.crittersAlive();
+-		console3.worldInfo();
+-		console3.advanceTime(1);
+-		console3.worldInfo();
+-		assertEquals(initialNumCritters - 1, console3.crittersAlive());
+-	}
+-
+-}
+diff --git a/src/test/java/simulationTests/AttackTests.java b/src/test/java/simulationtests/AttackTests.java
+similarity index 95%
+rename from src/test/java/simulationTests/AttackTests.java
+rename to src/test/java/simulationtests/AttackTests.java
+index 2859cb7..510b215 100644
+--- a/src/test/java/simulationTests/AttackTests.java
++++ b/src/test/java/simulationtests/AttackTests.java
+@@ -1,4 +1,4 @@
+-package simulationTests;
++package simulationtests;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+diff --git a/src/test/java/simulationtests/BudTest.java b/src/test/java/simulationtests/BudTest.java
+new file mode 100644
+index 0000000..ef8bf90
+--- /dev/null
++++ b/src/test/java/simulationtests/BudTest.java
+@@ -0,0 +1,67 @@
++package simulationtests;
++
++import static org.junit.Assert.*;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class BudTest {
++
++	Console console1 = null;
++	Console console2 = null;
++	Console console3 = null;
++
++	@Before
++	public void setup() {
++		console1 = new Console();
++		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
++		console2 = new Console();
++		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
++		console3 = new Console();
++		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
++	}
++
++	/**
++	 * testBasicBud checks to see if a critter can bud under normal circumstances.
++	 */
++	@Test
++	public void testBasicBud() {
++		System.out.println("testBasicBud");
++		int initialNumCritters = console1.crittersAlive();
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++		assertEquals(initialNumCritters + 1, console1.crittersAlive());
++	}
++
++//	/**
++//	 * testBudWithRock checks to see that a critter does not bud when there is a
++//	 * rock behind it.
++//	 */
++//	@Test
++//	public void testBudWithRock() {
++//		System.out.println("testBudWithRock");
++//		int initialNumCritters = console2.crittersAlive();
++//		console2.worldInfo();
++//		console2.advanceTime(1);
++//		console2.worldInfo();
++//		assertEquals(initialNumCritters, console2.crittersAlive());
++//	}
++//
++//	/**
++//	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
++//	 * It also tests to see if critter death properly adds a food object onto the site of death.
++//	 */
++//	@Test
++//	public void testBudNoEnergy() {
++//		System.out.println("testBudNoEnergy");
++//		int initialNumCritters = console3.crittersAlive();
++//		console3.worldInfo();
++//		console3.advanceTime(1);
++//		console3.worldInfo();
++//		assertEquals(initialNumCritters - 1, console3.crittersAlive());
++//	}
++
++}
+diff --git a/src/test/java/simulationTests/MateTest.java b/src/test/java/simulationtests/MateTest.java
+similarity index 98%
+rename from src/test/java/simulationTests/MateTest.java
+rename to src/test/java/simulationtests/MateTest.java
+index 7c6efad..70c2089 100644
+--- a/src/test/java/simulationTests/MateTest.java
++++ b/src/test/java/simulationtests/MateTest.java
+@@ -1,4 +1,4 @@
+-package simulationTests;
++package simulationtests;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+diff --git a/src/test/java/simulationTests/MovingTest.java b/src/test/java/simulationtests/MovingTest.java
+similarity index 96%
+rename from src/test/java/simulationTests/MovingTest.java
+rename to src/test/java/simulationtests/MovingTest.java
+index 18ff962..56178ff 100644
+--- a/src/test/java/simulationTests/MovingTest.java
++++ b/src/test/java/simulationtests/MovingTest.java
+@@ -1,6 +1,4 @@
+-package simulationTests;
+-
+-import static org.junit.Assert.*;
++package simulationtests;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+diff --git a/src/test/java/simulationTests/SpiralCritterTest.java b/src/test/java/simulationtests/SpiralCritterTest.java
+similarity index 95%
+rename from src/test/java/simulationTests/SpiralCritterTest.java
+rename to src/test/java/simulationtests/SpiralCritterTest.java
+index 18af1b3..c292b32 100644
+--- a/src/test/java/simulationTests/SpiralCritterTest.java
++++ b/src/test/java/simulationtests/SpiralCritterTest.java
+@@ -1,4 +1,4 @@
+-package simulationTests;
++package simulationtests;
+ 
+ import org.junit.Test;
+ 
+diff --git a/src/test/java/simulationTests/TurnAndNearbyTests.java b/src/test/java/simulationtests/TurnAndNearbyTests.java
+similarity index 97%
+rename from src/test/java/simulationTests/TurnAndNearbyTests.java
+rename to src/test/java/simulationtests/TurnAndNearbyTests.java
+index a1aa66a..39aee78 100644
+--- a/src/test/java/simulationTests/TurnAndNearbyTests.java
++++ b/src/test/java/simulationtests/TurnAndNearbyTests.java
+@@ -1,4 +1,4 @@
+-package simulationTests;
++package simulationtests;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
+index 5abacf0..040f068 100644
+--- a/src/test/resources/simulationTests/SensingWorld.txt
++++ b/src/test/resources/simulationTests/SensingWorld.txt
+@@ -1,4 +1,4 @@
+ name Sensing World 1
+ size 5 10
+ 
+-critter SensingCritter.txt 4 9 0
+\ No newline at end of file
++critter src/test/resources/simulationTests/SensingCritter.txt 4 9 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
+index 7102f96..ca69671 100644
+--- a/src/test/resources/simulationTests/SpiralCritterWorld.txt
++++ b/src/test/resources/simulationTests/SpiralCritterWorld.txt
+@@ -1,3 +1,4 @@
+ name Spiral World
+ size 11 13
+-critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
+\ No newline at end of file
++critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
++food 5 7 10000
+\ No newline at end of file
diff --git a/build.gradle b/build.gradle
index 74f0170..62638b1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,7 +17,10 @@ dependencies {
     compile 'com.sparkjava:spark-core:2.3'
     // GSON, for parsing and generating JSON
     compile group: 'com.google.code.gson', name: 'gson', version: '2.4'
-
+	// https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple
+	
+compile group: 'com.googlecode.json-simple', name: 'json-simple', version: '1.1'
+	
     // Specifies that you want to run your tests with junit
     testCompile 'junit:junit:4.12'
 }
diff --git a/draw_critter.txt b/draw_critter.txt
deleted file mode 100644
index 2c3990d..0000000
--- a/draw_critter.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-POSTURE != 17 --> POSTURE := 17;
-nearby[3] = 0 and ENERGY > 2500 --> bud;
-{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
-ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
-(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
-1 = 1 --> wait;
-POSTURE != 17 --> POSTURE := 17;
-nearby[3] = 0 and ENERGY > 2500 --> bud;
-{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
-ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
-(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
-1 = 1 --> wait;
-POSTURE != 17 --> POSTURE := 17;
-nearby[3] = 0 and ENERGY > 2500 --> bud;
-{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
-ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
-(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
-1 = 1 --> wait;
-POSTURE != 17 --> POSTURE := 17;
-nearby[3] = 0 and ENERGY > 2500 --> bud;
-{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
-ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
-(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
-1 = 1 --> wait;
\ No newline at end of file
diff --git a/instructions.txt b/instructions.txt
new file mode 100644
index 0000000..a33a8d9
--- /dev/null
+++ b/instructions.txt
@@ -0,0 +1,18 @@
+Welcome to CRITTERWORLD! A world of love and adventure and beauty and daring... majestic critters battling it out till the death, fighting to preserve their species and live on through the timestep. This GUI is your window into the world of the critters -- instructions on how to use it are given below:
+
+Controls:
+Click on a hex to display info about the hex.
+Drag or use arrow keys to move the map.
+Scroll or use +- to zoom in and out.
+
+Buttons:
+Display Program -- if selected hex has a critter, display that critter's program.
+New World -- create new randomly generated world.
+Load World -- load a world from a text file.
+Load Critters -- load critters from a text file onto random hexes or specified hexes.
+Step Forward -- move the simulation ahead one timestep.
+Run -- run simulation.
+Pause -- pause simulation.
+Simulation Controls -- adjust the speed of the simulation when running.
+
+Made by Andy Zhu, Rishi Advani, and Sujith Naapa Ramesh.
\ No newline at end of file
diff --git a/log.txt b/log.txt
index c324f63..8ce7f0b 100644
--- a/log.txt
+++ b/log.txt
@@ -1,3 +1,2106 @@
+commit 1d7740e5cbc753342c469cc829a0970a0692d9df
+Merge: 01787ea c6213f7
+Author: Andy <az389@cornell.edu>
+Date:   Mon Dec 4 00:00:33 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 01787ea8143888855004c2cce14badef4cbe5db3
+Merge: 8c26867 c3cd790
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 23:59:18 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit c6213f729701d0170d823f05cf5a429bcb103686
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 23:59:02 2017 -0500
+
+    tiny change
+
+commit 372bf4d0af6bd2b43e39e265b3fcc95a4a8a818f
+Merge: 6d4279a c3cd790
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 23:53:44 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 8c268675b55d75d3388b643198d657908b75983e
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 23:53:21 2017 -0500
+
+    Final changes
+
+commit 6d4279a6ff6396e65fbcc229881733da51bce000
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 23:52:59 2017 -0500
+
+    pushing
+
+commit c3cd790ba8ed1f862203848d2166be296bcedef2
+Merge: 6673122 e012507
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 23:02:03 2017 -0500
+
+    Merge of Server
+
+commit 6673122e35a86785f4baf312fc2296df1b175f7c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 23:00:39 2017 -0500
+
+    Server should be finished
+
+commit e0125077e9955b04cc21333462ae0cd9329388f4
+Merge: c828227 d5228f7
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 22:59:29 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit c8282278f36f2b40e4785d92ab819681ec7fe611
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 22:59:21 2017 -0500
+
+    finished drawing written problem #3 and uploaded new file as a pdf
+
+commit d5228f7618ad111f511235a8b5610d513908ce3a
+Merge: 2f01114 fa5312c
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 22:20:53 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 2f0111410c3bb738c51f236100864045ed9a1ed8
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 22:16:40 2017 -0500
+
+    Creating a world object from json
+
+commit fa5312cec880d49f430082b54b6f2aa96431501d
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 21:53:51 2017 -0500
+
+    removing outdated TODOs; various updates
+
+commit c86c7e1102afc9bf19cd706676268e7b4ab0ed4d
+Merge: d094f31 d8e3e66
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 21:38:44 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit d094f310da8335564ec6a2e084b07961282f2bcf
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 21:37:47 2017 -0500
+
+    changes to file organization, removing old testing print statements, various other updates
+
+commit d8e3e66d5cff25025ff3a4e0ee78a09da1c3e5d8
+Merge: 3b8a9ba 81b8e77
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 21:36:33 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3b8a9bacbaef4d327d75d23a6daf0fda1ace2850
+Merge: d8d70d9 a9d8adb
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 21:26:00 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit d8d70d9bde68aadbe4045f1174fbbfa04f9a96f2
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 21:24:14 2017 -0500
+
+    More changes to server
+
+commit 81b8e77b2b022c2db89e6fb10c490a1efc795b3b
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 21:24:08 2017 -0500
+
+    Deleting now works
+
+commit a9d8adbfa39bec09c6ab287ce905205d435bfe4d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 16:51:26 2017 -0500
+
+    Merge of Server
+
+commit ebbe7a797fb2b644216de8713ffca888b560282c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 16:49:12 2017 -0500
+
+    Initial Subsection of the World
+
+commit 79b81e394afcc8580226db6ebfe612c09972244e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 16:45:42 2017 -0500
+
+    Revert "Drawing stuff"
+    
+    This reverts commit 1851c68a09ad254ddd4dc6188c343677be4662be.
+
+commit 1851c68a09ad254ddd4dc6188c343677be4662be
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 16:43:38 2017 -0500
+
+    Drawing stuff
+
+commit fe1db7f33173965c59bf00c47337bf43915e1a42
+Merge: a70e080 eb1b04b
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 15:29:19 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit a70e0801981b5d8b4f881b71fc1cff8d5e9e4d2c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 15:29:10 2017 -0500
+
+    Step should work
+
+commit eb1b04b430540d47f7e41949243259789babe48f
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 15:28:52 2017 -0500
+
+    Fix
+
+commit 73aa6b43df6fea35e4b902252b604adf5a69653a
+Merge: 8f1f6f8 12ddebe
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 15:22:01 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 8f1f6f88e0ed9db4627f339f7348452ced15b24e
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 15:21:59 2017 -0500
+
+    Minor changes
+
+commit 12ddebee09302f0425175fb01e696b4df718bf24
+Merge: c369af8 42ed9be
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 15:10:17 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit c369af8968361b8962aca456aa0098165bae9ab2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 15:10:05 2017 -0500
+
+    Stepping of the World
+
+commit 42ed9be5342ee5d298e417f16fa70551d80131cd
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 15:09:54 2017 -0500
+
+    Drawing changes
+
+commit aba239448c17b394596d52ad1f566b8729fe3258
+Merge: 13fb438 8cf16ae
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 14:47:58 2017 -0500
+
+    Merging of Server Changes
+
+commit 8cf16ae44d64e328f246dc50bb4f8c8fe49bd61e
+Merge: cbde6c0 de393ad
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 14:44:59 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit cbde6c026d44917ec5fb02286a1e53d5d9fa96b5
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 14:44:57 2017 -0500
+
+    World drawing
+
+commit 13fb4380f2ae9725d245c68646372e95c0590fc9
+Merge: 8079d46 de393ad
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 14:43:26 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit 8079d465fb8005ab912c787dd1ba519ed158adb7
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 14:43:19 2017 -0500
+
+    Stepping For Server Now Works
+
+commit de393ad1f9307dfbaa2fd1d7c980a46416c005be
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 07:23:44 2017 -0500
+
+    small but VERY important fix to smell
+
+commit 70748d93a94e938e674ec95f7ee78da30bbde9c0
+Merge: 3abd6ec 665ded3
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 06:46:51 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3abd6ec40f694cc7e3db9bb92a28d248fd516456
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Dec 3 06:46:44 2017 -0500
+
+    FINISHED SMELL
+    
+    has not been tested yet -- will test soon
+
+commit 665ded3f51040e4b2597ac0f913108fd2cf88b6a
+Merge: 6e9ce99 e7908b6
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 02:57:25 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6e9ce99c6a8ca111d79da0871098e51ca5d01c18
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 02:57:23 2017 -0500
+
+    Temporary stuff
+
+commit ffd2a514db481f3a0441815b9af1b3928ac7d162
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 02:56:44 2017 -0500
+
+    Fixes and refactoring
+
+commit e7908b62045945f2bf67573cb608d9bbd5c51b76
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 02:55:21 2017 -0500
+
+    World State Was Fixed
+
+commit cbd770efbfe1472d60c201fb48ff86b720d82ed9
+Merge: cdaae7d b4e2ae5
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 00:31:49 2017 -0500
+
+    Small merge
+
+commit cdaae7d7b212ffcafd361e5db2cb50577926cdab
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Dec 3 00:29:40 2017 -0500
+
+    Start of work on get critters
+
+commit b4e2ae56ff5dae6bfc2b1eeeeb123a9ef5b1d50e
+Merge: ce08bca fa1873b
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 00:26:42 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit ce08bca6dbcc82a9ddfb1fb28d2776d58d7dc685
+Author: Andy <az389@cornell.edu>
+Date:   Sun Dec 3 00:25:29 2017 -0500
+
+    Work on new controller
+
+commit fa1873b7c2c4c51cc0f6f80b0efbfbcdb4a00746
+Merge: 8cadd6a e13cf02
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 23:11:04 2017 -0500
+
+    C:/Program Files/Git/critters modification
+
+commit 8cadd6a77b134d9f30e980ec0820cff9ea741758
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 23:08:24 2017 -0500
+
+    Server Changes For Get World
+
+commit e13cf02133ab955fee35243955f9367439b75b80
+Merge: a92dc7f 883cafc
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 23:01:57 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a92dc7f8253124bcdacd33fbef5f60170c891a69
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 22:59:12 2017 -0500
+
+    Fixing up world state stuff
+
+commit 883cafc9ca415489f78f3e48f4bdd41ced79b7d7
+Merge: eaec6dc 03cc15e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 22:09:52 2017 -0500
+
+    ServerWorldModel Merge
+
+commit eaec6dc43c003933be9d2e7a996a8660cef4fa9b
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 22:08:13 2017 -0500
+
+    More Minor Changes
+
+commit 03cc15eba9827477585d53ab80502b2fc6b4d230
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 19:43:01 2017 -0500
+
+    Fixing merge conflict bugs
+
+commit 09ecb921e2d99479cfed63df34761215e5dda3e0
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 19:11:26 2017 -0500
+
+    Updated server world model
+
+commit f72042515f74eade22db2ecdb8f380a974fd756e
+Merge: 95dc967 82f2018
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 19:04:45 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 95dc9677586fe864dfb47111cd444a5ead6c3300
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 19:04:44 2017 -0500
+
+    Starting work on client view
+
+commit 82f2018ccf8a39ffa6199e853fb71bf14165fde8
+Merge: c69422f 9c237f8
+Author: ra534 <ra534@cornell.edu>
+Date:   Sat Dec 2 18:58:11 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit c69422f261212ef285d4c813db896270d3e3705a
+Author: ra534 <ra534@cornell.edu>
+Date:   Sat Dec 2 18:58:02 2017 -0500
+
+    added help functionality!
+
+commit 9c237f8d3396dd9a7e017da3966cbc05b194e548
+Merge: 7153cdb d17f69d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 18:22:36 2017 -0500
+
+    World can get information from both local and demo servers
+
+commit 7153cdb03ce2880af751cb9ef7f6d602b17d6989
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 17:40:28 2017 -0500
+
+    Minor Changes to Get Rows and Columns
+
+commit d17f69d0c8f42b5a84d4fd8805ae9fd007acc77e
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 17:37:07 2017 -0500
+
+    Finished work on server/client side update_since
+    
+    Still need to do drawing
+
+commit 873e55a7549b2e50afbd4ebc6c979ba42dba9d29
+Merge: baae19d 9e40b2d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 16:28:40 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit baae19dda00a68b1fbb4b1391b280a7973b0a931
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 16:28:34 2017 -0500
+
+    Load Critter and Connecting to the Demo Server
+
+commit 9e40b2db60695456b9fefdcc73f798cd9d33b1df
+Merge: fce8455 1dd4f36
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 04:20:19 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit fce8455e8ffacea305044aecb7c1aa248cdf0698
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 04:20:17 2017 -0500
+
+    JSONs for diff
+
+commit 1dd4f36fe426785e1c1297f31858f195eaf7548e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 04:14:35 2017 -0500
+
+    Load Critter at Random Hexes Works
+
+commit 222ca65994c37d4be0591f5b62b8a3c25f51268d
+Merge: 28d5d89 14706a3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 03:23:13 2017 -0500
+
+    Andy and Sujith merge
+
+commit 28d5d8956f87c09ac6ab906280ce16b98a9cba11
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Dec 2 03:17:44 2017 -0500
+
+    Basic Load Critter
+
+commit 14706a3559a3a46ce79ac742f27e18e7e7241779
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 03:14:37 2017 -0500
+
+    Commented out drawing of objects
+
+commit 2d63da11bbcf8735ffb4b4f21b23d9f96527bab0
+Merge: da23509 382d093
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 03:13:50 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit da235094f3b9443ea4b3c0b3e7d6fc9609bcb72d
+Author: Andy <az389@cornell.edu>
+Date:   Sat Dec 2 03:13:48 2017 -0500
+
+    World Model stuff
+
+commit 382d0931e93941e9039f3b6d4e84e22ca56fcf96
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Dec 1 23:40:54 2017 -0500
+
+    completed some GUI related TODOs!
+
+commit f50f395090cc649941ba96cc8666bd9d55332fd6
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Dec 1 22:26:22 2017 -0500
+
+    more work on smell; written problems completed!
+    
+    (graph for written problem #3 still needs to be pretty-printed)
+
+commit 7899616b0f34cf199258692d7caf7d4666288dc8
+Merge: 140e375 c6a38af
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Dec 1 16:37:53 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit 140e3751bea819d035ec0f5748124eb34e4564e4
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Dec 1 16:37:43 2017 -0500
+
+    Can connect correctly to the demo server
+
+commit c6a38af43dc5395d160dd37f19bc9d8b6f93da5c
+Author: Andy <az389@cornell.edu>
+Date:   Fri Dec 1 16:35:54 2017 -0500
+
+    Finishing up model functions
+
+commit 310709bd56cee37ac9dbeeb2323f8fdbc519ab32
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Dec 1 03:56:02 2017 -0500
+
+    updated TODOs
+
+commit cc9a8be735de4991097da6569ccc299cd269762b
+Merge: a71d7fb cdf56f6
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Dec 1 03:50:15 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a71d7fbab5ebaff2940fa3c1430db6f7736849d3
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Dec 1 03:50:11 2017 -0500
+
+    currently working on smell
+    
+    not complete yet
+
+commit cdf56f6dc309ce839db509831a7deb32a375da8b
+Author: Andy <az389@cornell.edu>
+Date:   Fri Dec 1 03:09:34 2017 -0500
+
+    Fixing dead critters
+
+commit e64a42becfff51cafbfbf7632c699fed0ecc24d7
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 30 12:05:08 2017 -0500
+
+    Minor refactoring and closing a reader
+
+commit 4f24f97f874e9ce24fb8a8b7b792b238252c7094
+Merge: 3947fa3 86ed38f
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 30 11:57:25 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3947fa3a30a149db7d9265150e61cf3e973ea12d
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 30 11:57:22 2017 -0500
+
+    Javadocs + deadcritter list stuff
+
+commit 86ed38fb57a34fe2a42e4a1630719f9dc888323d
+Merge: dfbb830 2168385
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 30 11:15:52 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit dfbb830f722420c37c014f91fcaec68e0a3aea55
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 30 11:15:36 2017 -0500
+
+    New World is Up To Spec
+
+commit 2168385dcddd0b0490c1c3398c373ca8aaf56357
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 30 01:13:30 2017 -0500
+
+    Re-added locks - seems to not cause any problems
+    
+    Will ask about the locks tomorrow.
+
+commit d8511108e995077fbe07e16c7a562e5b2b19cc2d
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 30 00:31:00 2017 -0500
+
+    Fixed major bug (no more stuttering)
+
+commit dba123c584f1a78c6fc87b85409c2f6c53ec96da
+Merge: 4a6f1ff b36736c
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 22:20:07 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 4a6f1ffba844149db8e8cabf0b369aad86b2ecfb
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 22:14:54 2017 -0500
+
+    Fixes???
+
+commit b36736ccc8d73b3821fe2ef0f6931d123ccb1b3d
+Merge: 5446771 03e48b6
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 29 21:02:27 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 5446771085549b36e202cebcac2e8934b8b0257b
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 29 21:00:22 2017 -0500
+
+    starting smell
+
+commit 03e48b618a3822cd28549360b5d279a6f2eabd40
+Merge: 02eed19 89a49d9
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 18:30:45 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit 02eed19fb15a24a363fed470bddbc5dd3c628a5a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 18:30:17 2017 -0500
+
+    Load World Kind Of Works Now
+
+commit 89a49d9ad7d2f22af44dd8df4c5534ed872057b1
+Merge: a84f317 87e7e29
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 18:28:10 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a84f317aa412f8fb35a1b29435bc3b9c999f3114
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 18:28:08 2017 -0500
+
+    Minor fix
+
+commit e7ee7fcfdd3ecce23eda62b565923642d4c90c8e
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 18:27:54 2017 -0500
+
+    Smell
+
+commit 87e7e29fd741672805f384e03d7e2ead06ec78a8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 16:41:17 2017 -0500
+
+    Spacing from SpiralCritter was removed
+
+commit 0c3bea4a5f11834b9c7d553d41b50f54a58fe557
+Merge: bcf06dd 941ae91
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 16:36:35 2017 -0500
+
+    Controller was merged.
+
+commit bcf06dd2f1f1e7fb5542900442b380ea14254c45
+Merge: 3b50475 3de6f4a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 16:35:26 2017 -0500
+
+    Merge of Andy and Sujith Load WOrld stuff
+
+commit 941ae915e7ad017782f6c0fc40c2d5ca05ab8558
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 29 15:58:35 2017 -0500
+
+    Generate world from string description
+
+commit 3b5047551c33e6c076d79604ea431bd8b20f5196
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 29 15:54:29 2017 -0500
+
+    Load World
+
+commit 3de6f4a9df7a177d95c4ec0e26471e55e6ef0f02
+Merge: 36a12d4 353b589
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 28 10:55:45 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 36a12d4951da6afbee183d5a1f815495e7da4445
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 28 10:55:43 2017 -0500
+
+    Formatting GUI and trying to debug concurrency bugs
+
+commit 353b589447015b7af62921bc287518a098fcd48f
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 28 01:33:13 2017 -0500
+
+    reverted back to previous art style
+    
+    using outlines rather than fill for critters is probably more efficient as it is less drawing for the program to do. might help when having to draw 100s of critters.
+
+commit 7eece06d072345375989f9f98073ecc22b0f06c8
+Merge: 0c7343e 59e7a0f
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 28 01:06:18 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 0c7343e684bcbc33e4a7c1121eb7474c6eaa21df
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 28 00:51:08 2017 -0500
+
+    more work on controller
+
+commit 59e7a0fd0590dfbe71be5a952f67a3f87da824b5
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 28 00:50:06 2017 -0500
+
+    Initial work on diff log
+    
+    It's untested and probably doesn't work
+
+commit 324a83e926927f94156b6b696cb670b878180e20
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 28 00:47:30 2017 -0500
+
+    optimized controller
+    
+    modularized much of the code in the Controller class, and removed code from places where it was redundant
+
+commit c38b428c44ae3bad762cd6fa01fcc06fd1e29618
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 27 17:26:29 2017 -0500
+
+    Minor fix
+
+commit 645e883f63dcc29574ff56bd41ff843d1bb2fd08
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 27 14:09:31 2017 -0500
+
+    Improving error messages
+
+commit 57dd3ef24d08670b892ee35fc5e48b042cf2c008
+Merge: 6147409 3132c33
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 27 14:05:02 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 614740932e93a35927e629feb5d232aa2692d506
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 27 14:05:01 2017 -0500
+
+    Starting to adapt WorldModel for the server
+
+commit 3132c33aae050722e654b292613d56e333d3d65d
+Author: ra534 <ra534@cornell.edu>
+Date:   Mon Nov 27 01:26:12 2017 -0500
+
+    some TODOs
+
+commit ce2936a74ec99f0c57dc661a1f87d04f59202110
+Merge: a19da69 4dfd495
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 23:03:40 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a19da69a5ead5df594f5f9db575af1e922a19955
+Merge: 184bc73 0e69a19
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 23:03:35 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 4dfd4956be755b71d25bb413ef9283d6238422e6
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 26 23:02:52 2017 -0500
+
+    Fix for Login
+
+commit 184bc73656a91494a3d57a3f0b0dfdd251c61788
+Merge: 4a1f5cf 95c81b3
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 22:55:32 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 0e69a19e0ff8fdf05349d412e692125d66c860bd
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 26 22:52:52 2017 -0500
+
+    Psych I didn't merge correctly just fixed it.
+
+commit 4a1f5cf57bce5bd43937e8ac86fae9dbe5cd6f88
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 22:52:10 2017 -0500
+
+    Locks
+
+commit 95c81b3709534055b49cf958cec06f644b1c6d60
+Merge: 25b3b1f 081225e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 26 22:44:57 2017 -0500
+
+    I merged correctly for the first time
+
+commit 25b3b1f0b5cf6c099df7ba6d56710ac0eed3656c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 26 22:37:05 2017 -0500
+
+    Fixes for New World/Generic
+
+commit 081225ecce34de282eba29a7ef01e49fa1339a3c
+Merge: d9f969c bb7712d
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 26 19:28:40 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit d9f969ca28d120addcbe10e73c261cdcec191c70
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 26 19:28:24 2017 -0500
+
+    minor edits
+
+commit bb7712d661f92e7c0b35db345ef7ec67068aa583
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 17:30:23 2017 -0500
+
+    A5 fixes + GUI reformatting
+
+commit 7eef4a373b794b055c309c325174a4f6715c3645
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 26 17:11:00 2017 -0500
+
+    some more merge-related changes and formatting
+
+commit 873d52fd86c70cc585cb45188fc93b375a8f282d
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 26 17:01:04 2017 -0500
+
+    Revert "Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch""
+    
+    This reverts commit 7fc22702c636c0b00d7632c591633f2883f544ef.
+
+commit e0a4df73e2d56d23efcfc0e58371cfce189153f5
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 26 16:28:03 2017 -0500
+
+    Small fixes
+
+commit e30bab467d392bae2dfeb4a52e968b075b00d6ac
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 26 16:17:00 2017 -0500
+
+    resolved merge nightmare
+    
+    fixed out-of-date and incorrect TODOs and reverted deletions of code in GUI
+
+commit 85ec645da45e4955002c030a2436c72e74a18b6f
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Nov 25 21:50:42 2017 -0500
+
+    Merging Done Correctly Now
+
+commit b6c72ddf7f38f2febce504deced700b919d925c3
+Merge: 0c4c95b 10604fa
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Nov 25 21:43:50 2017 -0500
+
+    New World Stuff
+
+commit 0c4c95b43eab097a629c783c7a0cb3de267e9209
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Nov 25 21:40:06 2017 -0500
+
+    New World Sort Of Works
+
+commit 10604fa8471e6d55b798c05768ee7599a68fc5a3
+Author: Andy <az389@cornell.edu>
+Date:   Sat Nov 25 21:39:09 2017 -0500
+
+    Fixed an A5 bug
+
+commit 6301c5ee4285a6d36b8cce3f3629760740266bb1
+Merge: 1edbadc d6bd678
+Author: Andy <az389@cornell.edu>
+Date:   Sat Nov 25 21:28:54 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 1edbadc400f9dc121a62f5c79ad920e625a580a3
+Author: Andy <az389@cornell.edu>
+Date:   Sat Nov 25 21:24:04 2017 -0500
+
+    Critter info box now becomes blank after hex is unselected
+
+commit d6bd67892a7ff90b3cbf8dbbb5dd0f3066cae94f
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Nov 25 14:17:25 2017 -0500
+
+    Initial World Stuff on Server
+
+commit e561377f828d0180ab4c4f30561dd927145c1e99
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 22:12:53 2017 -0500
+
+    Login Now Error Handles
+
+commit 55c900193eef4a8d3a2fd35b2e6a45bd5f0ffa97
+Merge: 7a844ae 6ba4688
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:26:08 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit 6ba468890137f29d727a1d875b204c1dd6d5f00f
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:24:37 2017 -0500
+
+    Revert "Server Initial Changes"
+    
+    This reverts commit c235f7ff689c806ac72360cd10351c7d1116b050.
+
+commit 7a844ae8c07fee0c0a3c2dba2e217b8d7c4ef9f1
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:24:13 2017 -0500
+
+    Revert "Server Initial Changes"
+    
+    This reverts commit c235f7ff689c806ac72360cd10351c7d1116b050.
+
+commit 9acce39949d803a33c48b69720f7927caba658be
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:21:35 2017 -0500
+
+    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch"
+    
+    This reverts commit fd28a2a7011b73f61bce84c5f4c14be28c909b64, reversing
+    changes made to c235f7ff689c806ac72360cd10351c7d1116b050.
+
+commit 7fc22702c636c0b00d7632c591633f2883f544ef
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:20:40 2017 -0500
+
+    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch"
+    
+    This reverts commit fd28a2a7011b73f61bce84c5f4c14be28c909b64, reversing
+    changes made to c235f7ff689c806ac72360cd10351c7d1116b050.
+
+commit fd28a2a7011b73f61bce84c5f4c14be28c909b64
+Merge: c235f7f 53197a3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:01:39 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit c235f7ff689c806ac72360cd10351c7d1116b050
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 23 21:01:21 2017 -0500
+
+    Server Initial Changes
+
+commit 53197a34fdcc1edf4b6a3efd9ac5073094d82b29
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 21 18:02:56 2017 -0500
+
+    updated TODOs
+
+commit 6c924539ab374ad212280bc21df275196e94a054
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 21 17:55:43 2017 -0500
+
+    new reset functionality works!
+
+commit cc20cff6ab3bc5314ebc75cd0e79358e44e21ce6
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 21 17:35:10 2017 -0500
+
+    restructuring reset functionality
+
+commit c2d81045be2ad29e932819e99269606207ea3edf
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 21 16:22:16 2017 -0500
+
+    attempted to resolve icon issues (unsure if successful)
+
+commit ac63d1e5ed4e5f51bf6e3ec7d6a4f851d3bac1cd
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 22:17:14 2017 -0500
+
+    uploading updated favicon (did not upload last time)
+
+commit fafba02498de2ba578383d64fb92b4f3c4bc04d9
+Merge: 6915501 a777224
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 18:09:01 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 69155015d38fccf60d001a788d5b192b79b7738e
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 18:08:59 2017 -0500
+
+    fancy TODOs if we have time/motivation
+
+commit a777224a0e57582a60965e3edf42570fc3400b62
+Merge: 06ea395 ab070e8
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 18:03:51 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 06ea39509231678c38d79c9b15f2d79c529be9cc
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 18:03:50 2017 -0500
+
+    Stuff
+
+commit ab070e84425c4ee79d2a20f60d0fc0d4488939f8
+Merge: 299e373 5a8dae4
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 17:47:21 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 299e3734771c16b0757af886468c48a335cf503c
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 17:45:59 2017 -0500
+
+    some changes to gui
+
+commit 5a8dae433d42fb2f997825c562ba25b3d70152ee
+Merge: 1df02cb b34ea62
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 16:53:08 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 1df02cbe90fc5eb09293cc7adb3ee5e1083d35ab
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 16:53:05 2017 -0500
+
+    Icons!
+
+commit b34ea6202f81851354183f0a1892d6c85ebd7463
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 16:52:40 2017 -0500
+
+    icon updated
+
+commit 33bb331efcd31946ba3ba05a2fb554b5c39f577e
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 16:32:07 2017 -0500
+
+    favicon converted to png format
+
+commit b7fba3333f0bf5fdf4892065e030c869b3feb4e8
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 16:29:30 2017 -0500
+
+    uploaded favicon
+
+commit 11cd6881227afb2e461bf9436f86424f114189c3
+Merge: a45e4e9 9af4288
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 19 16:05:40 2017 -0500
+
+    Merge of Rishi and Master
+
+commit a45e4e9e518513f631c5a2bc9a557b329a58a57a
+Merge: 0cb28a2 28e8042
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 19 16:02:16 2017 -0500
+
+    Merge Of All Our Work
+
+commit 9af428841e328a5d1a588044d8aecffa3bcf2223
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 16:01:41 2017 -0500
+
+    working on hex selection mood
+
+commit 6f1328e4fbb5185713ee058ca9932b973356486f
+Merge: 16c257a c66ead8
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 15:51:56 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 16c257ada927a841d19696c5f41ccb8e7cd5ed17
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 19 15:51:52 2017 -0500
+
+    deleting deprecated method
+
+commit c66ead8ed49e7a54940013ad413d15ac037a8cfb
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 15:51:15 2017 -0500
+
+    Formatting fixes
+
+commit 0cb28a2413af821e517ff92abd69921b9a7b044e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 19 15:49:20 2017 -0500
+
+    Minor Change To Login
+
+commit 28e80427d75dee362e088c2258f280d54eb12d83
+Author: Andy <az389@cornell.edu>
+Date:   Sun Nov 19 02:58:41 2017 -0500
+
+    Fixes on controller
+
+commit 1e635066aad6c8fcf4ea1a2b6c7fddcccdf217ce
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 17 19:33:37 2017 -0500
+
+    some more TODO updates
+
+commit 033b94ce20e41f87ad9d243ed26a5b40a67100a3
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 17 19:32:43 2017 -0500
+
+    critter info works better now
+
+commit 508efd1ea893ca84978df3efb1a078a499159a89
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 17 18:48:06 2017 -0500
+
+    formatting of critter info box improved
+
+commit 9bef759c91082201741d905f8297eb55f55de255
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 17 17:13:22 2017 -0500
+
+    TODOs
+
+commit 410cba0501df71219b6effb9fd8cd2a9bb0cc63f
+Author: ra534 <ra534@cornell.edu>
+Date:   Thu Nov 16 04:56:32 2017 -0500
+
+    ZOOM WORKS NOW
+
+commit 821a32ef2ef6397b4a93bf683dcf89275b0e82ba
+Author: ra534 <ra534@cornell.edu>
+Date:   Thu Nov 16 04:32:09 2017 -0500
+
+    drag works now!!
+
+commit 73f2dc4ba6fa500f9804924ffed8ac2843900706
+Merge: 1b54385 d7c6e8a
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 20:57:27 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 1b543854583c963b803f164716b49127ff7c240f
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 20:57:21 2017 -0500
+
+    working on the dragging
+
+commit d7c6e8a81bacad70baed9c8f97aa09b8a39db8a9
+Merge: bad9b62 e9fae21
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:55:49 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit bad9b62799de0d50180c21ae23ea51a5f6f669a0
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:55:48 2017 -0500
+
+    Temp fixes
+
+commit e9fae219b28442e323f853088c68c93bda2f4543
+Merge: be90507 ec848e2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 20:48:15 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit be9050755e14529124bfd86917e28e7b4069676b
+Merge: 82d0d71 7273ded
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 20:46:34 2017 -0500
+
+    Login Merge Work
+
+commit ec848e286fa42d8c4aad0112a89710689839de74
+Merge: 848d7f6 b9567a6
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:46:05 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 848d7f6eeecdbf73882ba1178383fc02a176c014
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:46:03 2017 -0500
+
+    Miscellaneous fixes
+
+commit b9567a6ddb3c214b467c1eca02edc09ab8c53d72
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 20:42:25 2017 -0500
+
+    made it not broke
+
+commit 82d0d71a02216147ebb6e4e6e4beb1f8ce471e5e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 20:41:48 2017 -0500
+
+    Login Work is Mostly Done
+
+commit 7273ded110d96dde87eb1a537a9f9bb3397d4d70
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 20:32:14 2017 -0500
+
+    added todos, formatting, continued work on drag
+
+commit 827d390a09bf8d243b188fc6e5b61734fd120e28
+Merge: 7b3d96e 6aff4ab
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:10:47 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 7b3d96ecf39ca9e6e16ad7bebb7371673ccd2541
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 20:09:37 2017 -0500
+
+    Hex Selection fixed!
+
+commit 6aff4ab0a705a2249d63f3744a42b810bd817dd8
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 20:01:39 2017 -0500
+
+    fixed hex selection, worked on drag
+
+commit e60cf3efa5d26104929dcb0418e98652c6e99bbe
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 05:33:05 2017 -0500
+
+    critter color + todo's
+
+commit 5c0d61e615e8747effff295bfd17035fab8dd2d9
+Merge: 6b55a11 72b85ee
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 04:12:42 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6b55a11d8b69f2aa94e8da1c1b1b21502c929776
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 04:08:26 2017 -0500
+
+    working on stuff
+
+commit 72b85ee1e05258a31d44058c2cbd6f38a966ad5a
+Merge: b4c7bb2 f6968ee
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 00:30:40 2017 -0500
+
+    Merge remote-tracking branch 'origin' into SujithBranch
+
+commit b4c7bb299f4c962b4582c815afb2a5001255c4f0
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 00:24:31 2017 -0500
+
+    More Login Stuff
+
+commit 923a224d54026b3a78279eb1c5fdaf1f2c6c2b7c
+Merge: f238157 1b3d343
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 15 00:16:35 2017 -0500
+
+    Merge remote-tracking branch 'origin' into SujithBranch
+
+commit f6968ee7089c34525bfe40a66bc7a5b09b547590
+Merge: 196eb87 c7f4b4a
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 00:10:44 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 196eb879b9f46ca303af382289b18bbb10411948
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 15 00:07:11 2017 -0500
+
+    Minor fixes
+
+commit c7f4b4a003b50104ad5f5c7b4e82e60e89f71153
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 15 00:05:21 2017 -0500
+
+    ctrl + shift + f
+
+commit 1b3d34319d61e1f0ced34bc68789724a814d51ab
+Merge: 370e32f 57987a9
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 14 23:42:08 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit f238157389a2e46b01f42b1396b665202b1a0bf5
+Merge: 370e32f 57987a9
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 14 23:38:59 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw into SujithBranch
+
+commit 57987a93d7a5071c15464278fc7787dd8d03f1d2
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 14 23:37:09 2017 -0500
+
+    Minor comment
+
+commit 65fba1b5b9eb8474fb4289df67d759d016435fa8
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 14 23:02:00 2017 -0500
+
+    Important A5 fixes
+
+commit 733b73304dac6317c198e966ed50123e93d8b5c9
+Merge: 6af49ab 398e7f8
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 14 22:34:26 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6af49abed67e3caa8e9a4163ff7440150808d878
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 14 22:34:24 2017 -0500
+
+    Stroke width
+
+commit 370e32f9fdff001224615c9c040f9eed1ea9e756
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 14 22:02:15 2017 -0500
+
+    Login Work
+
+commit 398e7f8ffa7e91fa38643769762b2fbc001dc6c5
+Merge: f593366 7c9af1e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 13 16:46:17 2017 -0500
+
+    Merge remote-tracking branch 'origin' into SujithBranch
+
+commit f593366a9aa0c76f9cdc0f1e0ede08495d181f5d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 13 16:45:53 2017 -0500
+
+    Initial Zoom Testing
+
+commit 7c9af1e3822644d6cd2b45c7c5e018c56686d7dd
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 13 12:36:20 2017 -0500
+
+    Rocks are now colored properly
+
+commit 1f2e312efa95405d4f0de64d4abaa26aea63bf1d
+Merge: 44e1f73 9cdb057
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 13 12:01:41 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 44e1f73f301c6721c50268234195cb898636c1e0
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 13 12:00:46 2017 -0500
+
+    Fixed some major bugs with A5
+
+commit 9cdb057379dad6987ea11a8fdc99eab66c8508db
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Nov 11 12:21:47 2017 -0500
+
+    test commit
+
+commit ee57f891df89150a73c0aa24c1d1210156ad35b7
+Author: ra534 <ra534@cornell.edu>
+Date:   Sat Nov 11 00:02:27 2017 -0500
+
+    finalizing
+
+commit 8def5183f63f17bc1f6ce45b8ad2bfe0a9dda2a8
+Merge: decf2c7 ebda8c4
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 23:52:04 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit decf2c7ebc32298343c9c55c82672c12b1a76abd
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 23:51:55 2017 -0500
+
+    moreeee
+
+commit ebda8c4e6c697f662fee6175ad1fbb5d3f8efb63
+Merge: cbcf1c1 771991f
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 23:51:26 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit cbcf1c1298d39b1e672faf59ed6bbd8464960c8b
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 23:49:09 2017 -0500
+
+    Slider works now
+
+commit 771991fac086f2580ac06d19b9f549cb7f05a3c7
+Merge: 8732e7b f129b49
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 23:42:12 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 8732e7bcd86282c4bc5f9fb70fc12cd0d33364e2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 23:42:00 2017 -0500
+
+    Commenting
+
+commit f129b496d17829128efa08506c1457febd1ec599
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 23:41:28 2017 -0500
+
+    more
+
+commit a8f4e36c4161ee50489da6b2c5ed0325e353397b
+Merge: 5283340 fb20669
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 23:36:22 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 52833404276cdae52b3ffe5616ca112bf6d636c0
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 23:35:52 2017 -0500
+
+    more work on critters and stuff
+
+commit fb20669509656c9f5eca2e7fb89bbe7b3b001e82
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 23:06:50 2017 -0500
+
+    Panning Works So That The User Can't Roll Of The Edge Now
+
+commit 4e2c2fcc9f3ffc03e2bbe3f1c05620f826906581
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 22:41:41 2017 -0500
+
+    temp
+
+commit a8d13662f5b25d181678c0e3ea088d0b0ecedb0b
+Merge: 8a44215 01ae954
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 22:41:05 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 8a44215811ce738f31087a21764df17f5fe8e21d
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 22:36:59 2017 -0500
+
+    more
+
+commit 01ae954fdd25a1a5899acc14ab547a4c05b8f796
+Merge: 9c4208f 4a9dcc6
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 22:36:30 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 86e6cc37936da1806c51610b036158a4e36f5c8d
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 22:33:19 2017 -0500
+
+    drawing objects on map, and more!
+
+commit 9c4208f450a3ccab9ba5792310978a403e6a00d2
+Merge: 030050f e2fff8f
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 22:32:46 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 4a9dcc69e16b0ac6564251aa9bd3c278e5e155e6
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 22:04:56 2017 -0500
+
+    Implementation of the Critter Information
+
+commit 030050f704d0651e9d2b51f53fd586a694c425f0
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 21:34:39 2017 -0500
+
+    Loading critters
+
+commit e2fff8f3346d1f1947578b2ba8a071f161d0309c
+Merge: 02bffb6 84f8eb7
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 20:38:47 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 02bffb65a391b7f4ed5de9c05a8d346e69e07b77
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 20:25:10 2017 -0500
+
+    Display Critter Info
+
+commit 84f8eb7ffe84781b2ce8fdd0c22ac46a33a331dc
+Merge: 8336472 c5e845c
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 19:24:57 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 83364729d9eec0afc284f901f3ec342cd8637f75
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 19:24:56 2017 -0500
+
+    Highlighting works well now
+
+commit c5e845c5704c24353deabf2714e5d2da46cdf5e5
+Merge: adb4e41 a8cf7a7
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 18:53:45 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit adb4e4146fe5f1fbb7ff50f4278c569011040f98
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 18:53:40 2017 -0500
+
+    GUI Push
+
+commit a8cf7a745d42870ae914af98e4b9468bd0fd061b
+Merge: 58d9bd6 af152b8
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 18:42:56 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 58d9bd6b4c5bffe05d8cba36808fff25112fffef
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 18:42:54 2017 -0500
+
+    Formatting
+
+commit af152b80f0b7667791b5dccdbb7ef8c26f455a42
+Merge: 92419c8 f4c4e82
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 18:25:18 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 92419c85ecf092a015c575f162f5b7201814b49c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 18:22:33 2017 -0500
+
+    Gui Changes
+
+commit f4c4e827a8ccede87fef4bb37c107c2be6c5d6b7
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 17:59:56 2017 -0500
+
+    Merge conflicts
+
+commit 5b4a73381e9c1b1c4e2b1e4a89f7ab048c1519dc
+Merge: 2fa6d98 f06bd7d
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 17:57:33 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 2fa6d98fc0def9c408e82c048797460873450e1d
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 17:56:55 2017 -0500
+
+    Minor fixes
+
+commit f06bd7d21b842453539d61fc91e8d8a58ffb62ce
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 17:54:58 2017 -0500
+
+    working
+
+commit f3dcfb07f28651742115cbe6425bc33bf8dcad23
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 17:08:26 2017 -0500
+
+    working on stuff
+
+commit 5c7eeb7f26bb624a78abaa7b9a19ea649cba9ba1
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 16:47:15 2017 -0500
+
+    canvas refreshes now
+
+commit f252da4c74776ba4e4ac46fc04ef72debb57c5ae
+Merge: fed542e d452478
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 15:56:42 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit fed542e3daf09b572fb59ebeca155ea3c552e1bd
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 15:56:40 2017 -0500
+
+    Controller stuff
+
+commit d452478c4b0aeba8656d6f8f500480c62f1cf2e5
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 15:56:02 2017 -0500
+
+    GUI Changes
+
+commit 0ff84e7671637ba058c7af50d8099e3f18d911d6
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Nov 10 13:53:09 2017 -0500
+
+    Selecting Only One Hex
+
+commit 5798bdf4c7ec08b2cee869910530d0bde8d63586
+Author: ra534 <ra534@cornell.edu>
+Date:   Fri Nov 10 03:33:38 2017 -0500
+
+    todo
+
+commit 470f9c25d356648018f6fd185ec40353d4bf1473
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 03:31:55 2017 -0500
+
+    Some documentation
+
+commit 12d065b587532a23317566ac229bcb0615ed389e
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 03:26:08 2017 -0500
+
+    Fixed no rocks appearing with random world
+
+commit 0335fa0cf0678f2294ec2dbcceded45b0e2f2162
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 02:58:11 2017 -0500
+
+    Optimization of drawing
+
+commit 52b72e82c0e76e5253b78456403f3612524ece00
+Merge: 3f94836 2d47b40
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 01:40:11 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3f948365eb02ad6e94f2c7cd9c77223872df2307
+Author: Andy <az389@cornell.edu>
+Date:   Fri Nov 10 01:40:09 2017 -0500
+
+    Actually loading in the world
+
+commit 2d47b403ddd6056a9703510026c5753b2199cbfd
+Merge: e20b36c 43320d0
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 9 21:54:38 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit e20b36cd5a42c57e179a4fda1dd69a1bd1d117ed
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 9 21:54:35 2017 -0500
+
+    Panning Dashing Into Walls
+
+commit 43320d0955a0051afe768d015b8a42f957a77568
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 19:43:40 2017 -0500
+
+    added images and added run functionality
+
+commit 319403b50e695a071af7dc1d08a84c66cd8dd475
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 17:09:02 2017 -0500
+
+    More fixes!
+
+commit a1a8c9ed6cbf096c8d72e303b0387b2222d080b0
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 16:59:02 2017 -0500
+
+    Fixes
+
+commit b36ca66901778332bc731b5986e1e261fa722a61
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 16:42:28 2017 -0500
+
+    Minor fix
+
+commit 5df59fb073d312aa940927e3c68928b36cafcd32
+Merge: 5c89a83 10682dc
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 16:41:19 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 5c89a832aec323e4b0a7ded59fa767913053cbec
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 16:38:24 2017 -0500
+
+    Canvas is now resizable
+
+commit 10682dc2944a446805f6ad2430e68d181dc5f21e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Nov 9 16:02:06 2017 -0500
+
+    Picture Placement
+
+commit d30012d444a43a14ce3bb30e5f588cd7fe7b5848
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 13:33:04 2017 -0500
+
+    Changes to controller
+
+commit 13d40b812cef4cd7cec7de145c32d974a2ccc8c0
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 12:37:36 2017 -0500
+
+    Revert "New world drawing method?"
+    
+    This reverts commit 4cbedc19aacffd74ab9cd71d0cbe5698525abdbd.
+
+commit 4cbedc19aacffd74ab9cd71d0cbe5698525abdbd
+Author: Andy <az389@cornell.edu>
+Date:   Thu Nov 9 10:24:04 2017 -0500
+
+    New world drawing method?
+
+commit 2181d50f820fa21dc2922568c8c6532942824979
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 8 23:32:54 2017 -0500
+
+    Comment Explanation
+
+commit 2065ef116c4e87203c9909f78b7c967a98792d5e
+Merge: 824dbfd ee55728
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 22:56:48 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 824dbfded25efdb97ddd7a15a2c63211391ad3ed
+Merge: 662370f 8ea2441
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 22:56:42 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit ee55728f6a908dfd54bee6bea0dd06464979ca59
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 22:52:21 2017 -0500
+
+    fixed hex selection!!! somehow... i think
+
+commit 662370f48f7c1bcc6706c562d839465e505aa619
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 22:52:19 2017 -0500
+
+    Controller fixes
+
+commit 8ea2441b862b591cd54ade267261a1829580e3d7
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 21:59:30 2017 -0500
+
+    mostly formatting
+
+commit 201e441db10c362c2022d7324a4b57635d9ebc30
+Merge: 92a374f 3a7ad95
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 21:35:53 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 92a374f474ea02c44fded23bd9abe87f8b709ca8
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 21:35:43 2017 -0500
+
+    in progress hex selection
+
+commit 3a7ad95c0401bdf0e0693a4530b8e9d6ab800546
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 21:25:15 2017 -0500
+
+    Fix to resources and controller
+
+commit 867c604af95d0ef305385fbd8b2d5073ccf4fc22
+Merge: 6b39a80 2d65d09
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 07:37:18 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6b39a80310e99d2a9a2260fc4a90c5bea4cf41e9
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 07:37:17 2017 -0500
+
+    Minor fix
+
+commit 2d65d090a6e35672506839c1738cdac8fa4d18c8
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 04:50:21 2017 -0500
+
+    unable to fix
+
+commit c9a0fe228881fc72e793b2211ed8ebd99cc21581
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 04:42:51 2017 -0500
+
+    hex selection fixing in progress
+
+commit 320e7a2350757f18cc472c3439581d20febf272e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 8 01:54:26 2017 -0500
+
+    Testing of Hex Selection
+
+commit e78bb64332259bdb4fd9c5ccdf573ea29ed44e68
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Nov 8 01:41:01 2017 -0500
+
+    Coordinate Changes
+
+commit ca02d735470f51f4449a837c988d95d3ed0249f8
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 01:21:43 2017 -0500
+
+    TODOs done
+
+commit 2d785dfabb91c448523caed21508489a6d62fd69
+Merge: de4c364 c2e2d6f
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 01:00:34 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit de4c364315639c9c5691e16a5307dd0195546618
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 01:00:19 2017 -0500
+
+    pokemon
+
+commit c2e2d6ff08b4f7773123dac9c3f1ba481d51daa5
+Merge: 553bec0 b2017b3
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 00:57:37 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 553bec03695e78c6956940cfcfc1fcd2c97fd08e
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 8 00:57:36 2017 -0500
+
+    Work on controller
+
+commit b2017b36c50603f6c60464ffbb5c571e84b5e2ad
+Author: ra534 <ra534@cornell.edu>
+Date:   Wed Nov 8 00:37:07 2017 -0500
+
+    some testing stuff
+
+commit dfb0bb94e8e823062be7ef9cdff31b775d0262b9
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 7 23:30:19 2017 -0500
+
+    Controller cleanup and zoom fixing
+
+commit afb6865da2348cb2dd23a1a0fdef6544a4c1d769
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 18:24:42 2017 -0500
+
+    some more merge conflicting
+
+commit ca00033453c18600c0b719c8245d199129153860
+Merge: 31f1201 467e2cb
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 18:23:08 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 31f1201fe0d6c105180f913c9f6b69446749eb87
+Merge: ec94161 afc08f1
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 18:21:36 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 467e2cb77f7d1f4e28576e6c4aa3fa7a6bb2638c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 18:15:33 2017 -0500
+
+    Revert "Revert "Hex Selection""
+    
+    This reverts commit afc08f199bf530f4e18b1d8f8a3091cff0ae62b3.
+
+commit ec94161de0696237a6226ebb2bdb3ee169037a21
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 18:15:19 2017 -0500
+
+    FIXED HIDDEN WORLD
+
+commit afc08f199bf530f4e18b1d8f8a3091cff0ae62b3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 18:01:05 2017 -0500
+
+    Revert "Hex Selection"
+    
+    This reverts commit 7539542b3218fec0407530b71eda89c9e4a8477b.
+
+commit 461fbb33e041ebdc29e128209c153f4a7cdc352b
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:56:43 2017 -0500
+
+    Revert "Revert "test""
+    
+    This reverts commit 1dc48f6c4729c363a87cf88477c06b0d1701f8ca.
+
+commit 1dc48f6c4729c363a87cf88477c06b0d1701f8ca
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:56:26 2017 -0500
+
+    Revert "test"
+    
+    This reverts commit e6fe8f6d4905d543e23b69861b568c7051ba3387.
+
+commit e6fe8f6d4905d543e23b69861b568c7051ba3387
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:56:11 2017 -0500
+
+    test
+
+commit 713724328d238723b43bce66e609534f424f9221
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:54:27 2017 -0500
+
+    merging
+
+commit 8a751ee54d3688515790171b4d882c770c8bcfed
+Merge: 6977d43 173474e
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:45:21 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6977d4345691e72953d8986227940e436604fb61
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 17:45:13 2017 -0500
+
+    working on written
+
+commit 173474e8c4125a02be730517cd2c4318bb5c1f2b
+Merge: 7539542 3b16306
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 17:21:01 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 7539542b3218fec0407530b71eda89c9e4a8477b
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 17:20:38 2017 -0500
+
+    Hex Selection
+
+commit 3b16306b2a0697c45aefaaaa6cdee1ab21278cf5
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 7 12:04:55 2017 -0500
+
+    More work on controller
+
+commit 962a58e1b4464d25d1ff803160cea550bcca4dac
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 10:01:08 2017 -0500
+
+    Zoom Function Updated
+
+commit dd5f92920d28e38e7b2e4ea85ba01536c4a7605a
+Merge: 57ea430 0c9773e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 09:51:05 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 57ea4309658077af10883fc3c394ed155cf5a34e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 09:51:02 2017 -0500
+
+    Panning Now Works
+
+commit 0c9773e8d8db715e539adc86dd88fcd5dc7b2c39
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 05:05:49 2017 -0500
+
+    written problems
+
+commit 9d33b67f2fa254372b2f85a1c8ef5a99a7fda608
+Merge: dd3cd39 0b4eca9
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 01:22:15 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit dd3cd3920e5eb8fe90acaf9fefe4f11f11e62962
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Nov 7 01:19:12 2017 -0500
+
+    Zoom Commit
+
+commit 0b4eca94c9bd988d146f2947796c237b9b3d40f1
+Author: Andy <az389@cornell.edu>
+Date:   Tue Nov 7 01:14:31 2017 -0500
+
+    Controller stuff
+
+commit eae032792e72ac33b8226d36a1a0d3fba4d7d411
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 00:03:01 2017 -0500
+
+    removed testing file
+
+commit 0b648aa0e5cc4b0ffd8c8eb2e25078335ea0908e
+Merge: a259fce 6d7e9f5
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 00:02:41 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a259fce108e1341ec09f10af50e5b8c66b1f4fb4
+Author: ra534 <ra534@cornell.edu>
+Date:   Tue Nov 7 00:02:39 2017 -0500
+
+    todo
+
+commit 6d7e9f565964c2db7a6575abd31610c35b51ca41
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 6 20:39:28 2017 -0500
+
+    GUI fixes
+
+commit 54b749881722a4a8f52172a3ac5708f0b26153fd
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 6 18:54:10 2017 -0500
+
+    Hexes Show Up On GUI
+
+commit b8d879af27c0001c5e78ac8f6b384ea3837cefb1
+Merge: 4e7375c 7706b8b
+Author: ra534 <ra534@cornell.edu>
+Date:   Mon Nov 6 18:27:56 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 4e7375c7d7cea7f02d0e915b3b50a448d4c8ea95
+Author: ra534 <ra534@cornell.edu>
+Date:   Mon Nov 6 18:27:48 2017 -0500
+
+    added image files
+
+commit 7706b8b202513b56d75791d908cb60b4448b3dc0
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 6 18:18:19 2017 -0500
+
+    hexes repush
+
+commit de5d87ea9d51e82a865b355108205596d8fead7f
+Merge: 0d86f2c b890e45
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 6 18:16:22 2017 -0500
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 0d86f2c34308c33fb809043eb9b5f21421dadfa3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Nov 6 18:16:15 2017 -0500
+
+    hexes push
+
+commit b890e454c5a9a4d43d2f39a6109381f284c6959f
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 6 18:12:08 2017 -0500
+
+    More class structures + controller work
+
+commit da39488c91dd5c6d0e6c81fd04a158d9b5cac1df
+Author: Andy <az389@cornell.edu>
+Date:   Mon Nov 6 00:21:44 2017 -0500
+
+    Class Structure
+
+commit 928ea59e0b3c324f32c3220011b156e62c7a37a9
+Author: ra534 <ra534@cornell.edu>
+Date:   Sun Nov 5 21:49:09 2017 -0500
+
+    testing
+
+commit 4a9d8d948cf203c9626879d6dc290678854440f2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Nov 5 12:47:59 2017 -0500
+
+    Hexes for GUI
+
+commit 6ac8ef49a537f8eac904303c361ecad69bafc4e4
+Author: Andy <az389@cornell.edu>
+Date:   Wed Nov 1 21:11:32 2017 -0400
+
+    Fixes and A6 start
+
 commit 06cb727814873d6888a15d8da8ad12d94cb8e408
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 23:26:00 2017 -0400
diff --git a/src/main/java/ast/BinaryExpr.java b/src/main/java/ast/BinaryExpr.java
index dac5008..6e825a7 100644
--- a/src/main/java/ast/BinaryExpr.java
+++ b/src/main/java/ast/BinaryExpr.java
@@ -104,7 +104,6 @@ public class BinaryExpr extends AbstractNode implements Expr
 			right.setParent(this);
 			return true;
 		}
-		System.out.println("You messed up RCW in BinaryExpr."); //TODO remove when done testing
 		return false;
 	}
 	
diff --git a/src/main/java/ast/MutationReplace.java b/src/main/java/ast/MutationReplace.java
index 9869f7e..4aae1a2 100644
--- a/src/main/java/ast/MutationReplace.java
+++ b/src/main/java/ast/MutationReplace.java
@@ -135,7 +135,6 @@ public class MutationReplace extends AbstractMutation
 		for(int i = 0; i < size; i++)
 		{
 			index = i + rand < size ? i + rand : i + rand - size;
-			//System.out.println(index + " " + rand + " " + i); //TODO remove when done testing
 			if(root.nodeAt(index).getType() == a.getType())
 			{
 				copy = (Action) (root.nodeAt(index)).clone();
@@ -266,7 +265,6 @@ public class MutationReplace extends AbstractMutation
 	@Override
 	public boolean mutate(ProgramImpl p)
 	{
-		// TODO Auto-generated method stub
 		return false;
 	}
 }
\ No newline at end of file
diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
index 73c14b8..69cb548 100644
--- a/src/main/java/ast/ProgramImpl.java
+++ b/src/main/java/ast/ProgramImpl.java
@@ -68,6 +68,9 @@ public class ProgramImpl extends AbstractNode implements Program
 	public boolean replaceChild(Node child, Node replacement)
 	{
 		for(int i = 0; i < RulesList.size(); i++)
+		{
+			if(RulesList.size() == 1)
+				return false;
 			if(child == RulesList.get(i))
 			{
 				if(replacement == null)
@@ -79,6 +82,7 @@ public class ProgramImpl extends AbstractNode implements Program
 				}
 				return true;
 			}
+		}
 		return false;
 	}
 	
@@ -92,11 +96,11 @@ public class ProgramImpl extends AbstractNode implements Program
 	@Override
 	public Program mutate()
 	{
-		int randIndex = (int) (Math.random() * this.size());
 		Mutation m = null;
 		Program valid = null;
 		while(valid == null)
 		{
+			int randIndex = (int) (Math.random() * (this.size() - 1)) + 1;
 			int rand = (int) (Math.random() * 6);
 			switch(rand)
 			{
diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
index 3275487..36b541d 100644
--- a/src/main/java/ast/Rule.java
+++ b/src/main/java/ast/Rule.java
@@ -90,7 +90,7 @@ public class Rule extends AbstractNode
 	@Override
 	public StringBuilder prettyPrint(StringBuilder sb)
 	{
-		sb.append(cond.toString() + " --> " + comm.toString() + ";\n\n");
+		sb.append(cond.toString() + " --> " + comm.toString() + ";\n");
 		return sb;
 	}
 
diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
index ca92071..860c968 100644
--- a/src/main/java/console/Console.java
+++ b/src/main/java/console/Console.java
@@ -29,7 +29,7 @@ public class Console
 		{
 			world = new World();
 		}
-		catch (IllegalArgumentException i)
+		catch (UnsupportedOperationException i)
 		{
 			System.err.println("The constants.txt file could not be read. Please check if it exists or is formatted properly.");
 		}
@@ -39,18 +39,18 @@ public class Console
 	 * Starts new simulation with world specified in filename.
 	 * @param filename
 	 */
-	public void loadWorld(String filename)
+	public void loadWorld(String worlddesc)
 	{
 		try
 		{
-			world = new World(filename);
+			world = new World(worlddesc);
 		}
-		catch (FileNotFoundException f)
+		catch (IllegalArgumentException f)
 		{
-			System.err.println("World file not found. Loading defaultly generated world...");
+			System.err.println("World description invalid. Loading defaultly generated world...");
 			world = new World();
 		}
-		catch (IllegalArgumentException i)
+		catch (UnsupportedOperationException i)
 		{
 			System.err.println("The constants.txt file could not be read. Please check if it is formatted properly.");
 			System.exit(0);
@@ -88,7 +88,7 @@ public class Console
 		//This method can't do anything if no world has been created yet.
 		if(world == null)
 		{
-			System.err.println("You must first create a world before you advance time in it.");
+			System.err.println("You must first create a world before you advance time in it.\n");
 			printHelp();
 			return;
 		}
@@ -102,7 +102,7 @@ public class Console
 		//This method can't do anything if no world has been created yet.
 		if(world == null)
 		{
-			System.err.println("You must first create a world before you can view its information.");
+			System.err.println("You must first create a world before you can view its information\n");
 			printHelp();
 			return;
 		}
@@ -130,7 +130,7 @@ public class Console
 		//This method can't do anything if no world has been created yet.
 		if(world == null)
 		{
-			System.err.println("You must first create a world before you can view its information.");
+			System.err.println("You must first create a world before you can view its information.\n");
 			printHelp();
 			return;
 		}
@@ -150,7 +150,7 @@ public class Console
 		if(sc == null)
 			return;
 		
-		critterInfo(sc.getName(), sc.getMemoryCopy(), sc.getProgram().toString(), sc.getLastRule());
+		//critterInfo(sc.getName(), sc.getMemoryCopy(), sc.getProgram().toString(), sc.getLastRuleIndex());
 	}
 
 	/* =========================== */
diff --git a/src/main/java/distributed/CachedWorld.java b/src/main/java/distributed/CachedWorld.java
new file mode 100644
index 0000000..60d6c45
--- /dev/null
+++ b/src/main/java/distributed/CachedWorld.java
@@ -0,0 +1,13 @@
+package distributed;
+
+public class CachedWorld {
+	
+	private int columns;
+	private int rows;
+	
+	
+	public CachedWorld(WorldStateJSON state) {
+		columns = state.getCols();
+		rows = state.getRows();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/ClientRequestHandler.java b/src/main/java/distributed/ClientRequestHandler.java
new file mode 100644
index 0000000..7519f45
--- /dev/null
+++ b/src/main/java/distributed/ClientRequestHandler.java
@@ -0,0 +1,391 @@
+package distributed;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import com.google.gson.Gson;
+
+import javafx.scene.control.Alert;
+import javafx.scene.control.Alert.AlertType;
+
+import simulation.FileParser;
+import simulation.SimpleCritter;
+
+/** A class to handle client requests to the server. */
+public class ClientRequestHandler {
+	/** Stores the most recently retrieved version of the world. */
+	private int mostRecentVersion;
+	private String url;
+
+	public ClientRequestHandler(String url) {
+		this.url = url;
+	}
+
+	/**
+	 *
+	 * @param sessionId
+	 * @return
+	 */
+	public boolean createNewWorld(int sessionId) {
+		Gson gson = new Gson();
+		String description = "name Arrakis\r\nsize 50 68\r\n";
+		boolean[][] isNotValidSpace = new boolean[50][68];
+
+		// randomly fills about 1/40 of the hexes in the world with rocks
+		int c = (int) (Math.random() * 50);
+		int r = (int) (Math.random() * 68);
+		int n = 0;
+		while (n < 2150 / 40) {
+			c = (int) (Math.random() * 50);
+			r = (int) (Math.random() * 68);
+			if (isValidHex(c, r, 50, 68) && isNotValidSpace[c][r] == false) {
+				isNotValidSpace[c][r] = true;
+				description += "rock " + c + " " + r + "\r\n";
+				n++;
+			}
+		}
+		LoadWorldInfoJSON loadWorldInfo = new LoadWorldInfoJSON(description);
+		URL url = null;
+		try {
+			url = new URL(this.url + "/world?session_id=" + sessionId);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.setDoOutput(true); // send a POST message
+			connection.setRequestMethod("POST");
+			connection.setRequestProperty("Content-Type", "application/json");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(loadWorldInfo, LoadWorldInfoJSON.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("You do not have permission to create a new world.");
+				return false;
+			}
+			BufferedReader r1 = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			System.out.println(r1.readLine());
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			e.printStackTrace(); // TODO remove
+			System.out.println("Could not connect to the server");
+		}
+		return true;
+
+	}
+
+	/**
+	 *
+	 * @param worldfile
+	 * @param sessionId
+	 * @return
+	 * @throws IllegalArgumentException
+	 * @throws IOException
+	 */
+	public boolean loadWorld(File worldfile, int sessionId) throws IllegalArgumentException, IOException {
+		Gson gson = new Gson();
+		BufferedReader br = new BufferedReader(new FileReader(worldfile));
+		String description = "";
+		String currentLine = br.readLine();
+		while (currentLine != null) {
+			if (currentLine.indexOf("critter") == -1) {
+				description += currentLine;
+				description += "\r\n";
+				currentLine = br.readLine();
+			} else {
+				currentLine = br.readLine();
+			}
+		}
+		LoadWorldInfoJSON loadWorldInfo = new LoadWorldInfoJSON(description);
+		URL url = null;
+		try {
+			url = new URL(this.url + "/world?session_id=" + sessionId);
+			// url = new URL("http://localhost:" + 8080 + "/world?session_id=" + sessionId);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.setDoOutput(true); // send a POST message
+			connection.setRequestMethod("POST");
+			connection.setRequestProperty("Content-Type", "application/json");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(loadWorldInfo, LoadWorldInfoJSON.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("You do not have permission to create a new world.");
+				return false;
+			}
+			BufferedReader r1 = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			if (!r1.readLine().equals("Ok")) {
+				return false;
+			}
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			e.printStackTrace(); // TODO remove
+			System.out.println("Could not connect to the server");
+		} finally {
+			br.close();
+		}
+		return true;
+
+	}
+
+	/**
+	 * Returns the number of columns in the world.
+	 * 
+	 * @return The number of columns, or -1 if the user does not have permission
+	 */
+	public int getColumns(int sessionId) {
+		Gson gson = new Gson();
+		URL url = null;
+		int returnValue = 0;
+		try {
+			url = new URL(this.url + "/world?session_id=" + sessionId + "&update_since=" + this.mostRecentVersion);
+			System.out.println(url);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.connect();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("User is not an admin so a New World cannot be created.");
+				return -1;
+			}
+			BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			WorldStateJSON worldState = gson.fromJson(r, WorldStateJSON.class);
+			returnValue = worldState.getCols();
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			System.out.println("Could not connect to the server");
+		}
+		return returnValue;
+	}
+
+	public int getRows(int sessionId) {
+		Gson gson = new Gson();
+		URL url = null;
+		int returnValue = 0;
+		try {
+			url = new URL(this.url + "/world?session_id=" + sessionId + "&update_since=" + this.mostRecentVersion);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.connect();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("User is not an admin so a New World cannot be created.");
+				return -1;
+			}
+			BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			WorldStateJSON worldState = gson.fromJson(r, WorldStateJSON.class);
+			returnValue = worldState.getRows();
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			System.out.println("Could not connect to the server");
+		}
+		return returnValue;
+	}
+
+	public void advanceTime() {
+		// TODO Auto-generated method stub
+
+	}
+
+	/**
+	 * 
+	 * @param f
+	 * @param n
+	 * @param sessionId
+	 * @throws FileNotFoundException
+	 * @throws IllegalArgumentException
+	 */
+	public void loadRandomCritters(File f, int n, int sessionId)
+			throws FileNotFoundException, IllegalArgumentException {
+		Gson gson = new Gson();
+		BufferedReader reader = new BufferedReader(new FileReader(f));
+		SimpleCritter critter = FileParser.parseCritter(reader, 8, 0);
+		if (critter == null)
+			throw new IllegalArgumentException();
+		CritterJSON critterJSON = null;
+		String programDescription = critter.getProgram().toString();
+		int[] mem = critter.getMemoryCopy();
+		critterJSON = new CritterJSON(critter.getName(), programDescription, mem, n);
+		URL url;
+		try {
+			url = new URL(this.url + "/critters?session_id=" + sessionId);
+			// url = new URL("http://localhost:" + 8080 + "/critters?session_id=" +
+			// sessionId);
+			System.out.println(url);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.setDoOutput(true);
+			connection.setRequestMethod("POST");
+			connection.setRequestProperty("Content-Type", "application/json");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(critterJSON, CritterJSON.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("You do not have permission to add critters.");
+			}
+			System.out.println(gson.toJson(critterJSON, CritterJSON.class));
+			BufferedReader r1 = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			String line = r1.readLine();
+			while (line != null) {
+				System.out.println(line);
+				line = r1.readLine();
+			}
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			e.printStackTrace(); // TODO remove
+			System.out.println("Could not connect to the server");
+		}
+	}
+
+	/**
+	 * 
+	 * @param f
+	 * @param c
+	 * @param r
+	 * @param sessionId
+	 * @throws FileNotFoundException
+	 * @throws IllegalArgumentException
+	 */
+	public void loadCritterAtLocation(File f, int c, int r, int sessionId)
+			throws FileNotFoundException, IllegalArgumentException {
+		Gson gson = new Gson();
+		BufferedReader reader = new BufferedReader(new FileReader(f));
+		SimpleCritter critter = FileParser.parseCritter(reader, 8, 0);
+		if (critter == null)
+			throw new IllegalArgumentException();
+		String programDescription = critter.getProgram().toString();
+		int[] mem = critter.getMemoryCopy();
+		PositionJSON[] positions = new PositionJSON[] { new PositionJSON(c, r) };
+		CritterJSON critterJSON = new CritterJSON(critter.getName(), programDescription, mem, positions);
+		URL requestURL;
+		try {
+			requestURL = new URL(this.url + "/critters?session_id=" + sessionId);
+			// url = new URL("http://localhost:" + 8080 + "/critters?session_id=" +
+			// sessionId);
+			System.out.println(requestURL);
+			HttpURLConnection connection = (HttpURLConnection) requestURL.openConnection();
+			connection.setDoOutput(true); // send a POST message
+			connection.setRequestMethod("POST");
+			connection.setRequestProperty("Content-Type", "application/json");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(critterJSON, CritterJSON.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Login Error");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("The user cannot create a new world because the user is not an admin.");
+			}
+			// System.out.println(gson.toJson(critterJSON, CritterJSON.class));
+			BufferedReader r1 = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			String line = r1.readLine();
+			while (line != null) {
+				System.out.println(line);
+				line = r1.readLine();
+			}
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			e.printStackTrace(); // TODO remove
+			System.out.println("Could not connect to the server");
+		}
+	}
+
+	/**
+	 *
+	 * @param sessionID
+	 * @param updateSince
+	 * @return
+	 */
+	public WorldStateJSON updateSince(int sessionID, int updateSince) {
+		Gson gson = new Gson();
+		URL url;
+		try {
+			url = new URL(this.url + "/world?session_id=" + sessionID + "&update_since=" + updateSince);
+			System.out.println(url);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.setDoOutput(true);
+			connection.setRequestMethod("GET");
+			connection.setRequestProperty("Content-Length", "0");
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("You do not have permission to view the world.");
+				return null;
+			} else if (connection.getResponseCode() == 403) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setContentText("A world must be loaded before you can view the world state.");
+				return null;
+			} else if (connection.getResponseCode() == 406) {
+				return null;
+			}
+			BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			WorldStateJSON state = gson.fromJson(r, WorldStateJSON.class);
+			return state;
+
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+			return null;
+		} catch (IOException e) {
+			e.printStackTrace(); // TODO remove
+			System.out.println("Could not connect to the server");
+			return null;
+		}
+	}
+
+	/**
+	 * stepWorld() steps the world by one timestep.
+	 */
+	public void advanceTime(int sessionId) {
+		URL url;
+		try {
+			url = new URL(this.url + "/step?session_id=" + sessionId);
+			System.out.println(url);
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			connection.setDoOutput(true);
+			connection.setRequestMethod("POST");
+			connection.setRequestProperty("Content-Type", "application/json");
+			if (connection.getResponseCode() == 401) {
+				Alert alert = new Alert(AlertType.ERROR);
+				alert.setTitle("Invalid Request");
+				alert.setHeaderText("Access Denied");
+				alert.setContentText("You do not have permission to view the world.");
+			}
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+		} catch (IOException e) {
+			System.out.println("Could not connect to the server");
+		}
+
+	}
+
+	private boolean isValidHex(int c, int r, int columns, int rows) {
+		if (c < 0 || r < 0)
+			return false;
+		else if (c >= columns || r >= rows)
+			return false;
+		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
+			return false;
+		return true;
+	}
+}
diff --git a/src/main/java/distributed/ClientWorldMap.java b/src/main/java/distributed/ClientWorldMap.java
new file mode 100644
index 0000000..c705cd6
--- /dev/null
+++ b/src/main/java/distributed/ClientWorldMap.java
@@ -0,0 +1,561 @@
+package distributed;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map.Entry;
+
+import javafx.scene.canvas.Canvas;
+import javafx.scene.canvas.GraphicsContext;
+import javafx.scene.paint.Color;
+import javafx.scene.text.Font;
+import javafx.scene.text.TextAlignment;
+
+/** A class that draws the hex grid for the client user interface. */
+public class ClientWorldMap {
+
+	private GraphicsContext gc;
+	private Canvas canvas;
+	private int[] selectedHex;
+
+	/** The minimum acceptable hex sidelength (zoom will not allow the user to zoom in any further). */
+	private final int MIN_SIDELENGTH = 20;
+
+	/** The maximum acceptable hex sidelength (zoom will not allow the user to zoom out any further). */
+	private final int MAX_SIDELENGTH = 60;
+
+	/** How much each scroll tick zooms the hex grid by. */
+	private final double ZOOM_FACTOR = 3.0;
+
+	/** The background color of the canvas. */
+	private final Color BACKGROUND_COLOR = Color.DIMGRAY;
+	/** The outline color of hexagons. */
+	private final Color HEX_COLOR = Color.LIGHTGRAY;
+	/** The color of a highlighted hex. */
+	private final Color HIGHLIGHT_COLOR = Color.rgb(176, 224, 230, 0.3);
+
+	private double height;
+	private double width;
+	private int rows;
+	private int columns;
+
+	/** The sideLength of a hexagon. Used as a measure of scale. */
+	private double sideLength;
+
+	// these four variables are used to help drawing methods
+	private int column_drawing_marker;
+	private int row_drawing_marker;
+	private double x_position_marker;
+	private double y_position_marker;
+
+	/** Marks the rectangular x coordinate of the origin (the (0, 0) hex coordinate). */
+	private double origin_x;
+	/** Marks the rectangular y coordinate of the origin (the (0, 0) hex coordinate). */
+	private double origin_y;
+
+	/** A local cached version of the world state. */
+	private WorldStateJSON cachedState;
+	/** A list of all objects in the world. */
+	private HashMap<JSONWorldObject, int[]> objectMap;
+	
+	/**
+	 *
+	 * @param can
+	 * @param initialCols
+	 * @param initialRows
+	 */
+	public ClientWorldMap(Canvas can, int initialCols, int initialRows) {
+		gc = can.getGraphicsContext2D();
+		canvas = can;
+		height = canvas.getHeight();
+		width = canvas.getWidth();
+
+		columns = initialCols;
+		rows = initialRows;
+		objectMap = new HashMap<JSONWorldObject, int[]>();
+
+		column_drawing_marker = columns;
+		row_drawing_marker = rows;
+		row_drawing_marker -= column_drawing_marker / 2;
+		sideLength = 30;
+
+		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
+				+ (sideLength / 2);
+		y_position_marker = (((double) height / 2)
+				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
+				+ (Math.sqrt(3) * (sideLength / 2));
+		
+		height = canvas.getHeight();
+		width = canvas.getWidth();
+		gc.clearRect(0, 0, width, height);
+		gc.setFill(BACKGROUND_COLOR);
+		gc.fillRect(0, 0, width, height);
+		
+//		// resets the world grid
+//		height = canvas.getHeight();
+//		width = canvas.getWidth();
+//		gc.clearRect(0, 0, width, height);
+//		gc.setFill(BACKGROUND_COLOR);
+//		gc.fillRect(0, 0, width, height);
+//			
+//		// draws grid and sets the origin
+//		gc.setLineWidth(1);
+//		double hexMarkerX = x_position_marker;
+//		double hexMarkerY = y_position_marker;
+//		for (int i = 0; i < column_drawing_marker; i++) {
+//			if (i % 2 == 0 && column_drawing_marker % 2 == 0) {
+//				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+//			}
+//			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+//				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+//				row_drawing_marker--;
+//			}
+//			for (int j = 0; j < row_drawing_marker; j++) {
+//				drawHex(hexMarkerX, hexMarkerY);
+//				hexMarkerY += (Math.sqrt(3) * (sideLength));
+//			}
+//
+//			hexMarkerX += sideLength + (sideLength / 2);
+//			hexMarkerY = y_position_marker;
+//			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+//				row_drawing_marker++;
+//			}
+//		}
+//		hexMarkerX = x_position_marker;
+//		origin_x = hexMarkerX;
+//		origin_y = hexMarkerY + (sideLength * (Math.sqrt(3)) * row_drawing_marker) - (Math.sqrt(3) * (sideLength / 2));
+//		if (column_drawing_marker % 2 == 0)
+//			origin_y += (sideLength / 2) * (Math.sqrt(3));
+//		origin_y -= sideLength / 2 * Math.sqrt(3);
+	}
+
+	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
+	private boolean isValidHex(int c, int r) {
+		if (c < 0 || r < 0)
+			return false;
+		else if (c >= columns || r >= rows)
+			return false;
+		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
+			return false;
+		return true;
+	}
+
+	/** Draws the parts of the world grid that have changed from the last version. */
+	public void draw(WorldStateJSON wsj) {
+		System.out.println("Draw has been reached");
+		cachedState = wsj;
+		
+		columns = wsj.getCols();
+		rows = wsj.getRows();
+
+		// draws world objects
+		gc.setLineWidth(3);
+//		for(JSONWorldObject obj : cachedState.getWorldObjects()) {
+//			int[] location = new int[2];
+//			location[0] = obj.getCol();
+//			location[1] = obj.getRow();
+//			objectMap.put(obj, location);
+//		}
+
+		drawObjects(cachedState.getWorldObjects());
+
+		if (selectedHex != null) {
+			double[] highlightCoordinates = hexToCartesian(selectedHex);
+			highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
+		}
+	}
+	
+	/** Redraws the entire world grid. Used for zooming and panning purposes. */
+	private void redrawGrid() {
+		// resets the world grid
+		height = canvas.getHeight();
+		width = canvas.getWidth();
+		gc.clearRect(0, 0, width, height);
+		gc.setFill(BACKGROUND_COLOR);
+		gc.fillRect(0, 0, width, height);
+		
+		// draws grid and sets the origin
+		gc.setLineWidth(1);
+		double hexMarkerX = x_position_marker;
+		double hexMarkerY = y_position_marker;
+		for (int i = 0; i < column_drawing_marker; i++) {
+			if (i % 2 == 0 && column_drawing_marker % 2 == 0) {
+				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+			}
+			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+				row_drawing_marker--;
+			}
+			for (int j = 0; j < row_drawing_marker; j++) {
+				drawHex(hexMarkerX, hexMarkerY);
+				hexMarkerY += (Math.sqrt(3) * (sideLength));
+			}
+
+			hexMarkerX += sideLength + (sideLength / 2);
+			hexMarkerY = y_position_marker;
+			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+				row_drawing_marker++;
+			}
+		}
+		hexMarkerX = x_position_marker;
+		origin_x = hexMarkerX;
+		origin_y = hexMarkerY + (sideLength * (Math.sqrt(3)) * row_drawing_marker) - (Math.sqrt(3) * (sideLength / 2));
+		if (column_drawing_marker % 2 == 0)
+			origin_y += (sideLength / 2) * (Math.sqrt(3));
+		origin_y -= sideLength / 2 * Math.sqrt(3);
+		
+		// draws world objects
+		gc.setLineWidth(3);
+		redrawObjects();
+
+		if (selectedHex != null) {
+			double[] highlightCoordinates = hexToCartesian(selectedHex);
+			highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
+		}
+	}
+
+	/** Draws the world objects onto the grid. */
+	private void drawObjects(JSONWorldObject[] objects) {
+		for(JSONWorldObject obj : objects) {
+			if (obj.getType().equals("critter"))
+				drawCritter(obj.getMemory()[3], obj.getOrientation(), obj.getSpeciesName(), obj.getCol(), obj.getRow());
+			else {
+				drawWorldObject(obj, obj.getCol(), obj.getRow());
+				}
+		}
+	}
+
+	/** Redraws all the world objects. */
+	private void redrawObjects() {
+		for(Entry<JSONWorldObject, int[]> obj : objectMap.entrySet()) {
+			JSONWorldObject key = obj.getKey();
+			if (key.getType().equals("critter"))
+				drawCritter(key.getMemory()[3], key.getOrientation(), key.getSpeciesName(), key.getCol(), key.getRow());
+			else
+				drawWorldObject(key, key.getCol(), key.getRow());
+		}
+	}
+	
+	/**
+	 * Draws one critter onto the world grid.
+	 * @param sc
+	 * @param c
+	 * @param r
+	 */
+	private void drawCritter(int critterSize, int dir, String species, int c, int r) {
+		if (!isValidHex(c, r))
+			return;
+
+		// convert to Cartesian coordinates
+		int hexCoordinates[] = new int[] { c, r };
+		double cartX = hexToCartesian(hexCoordinates)[0];
+		double cartY = hexToCartesian(hexCoordinates)[1];
+		drawHex(cartX, cartY);
+		gc.setLineWidth(3.0);
+
+		double size = 0.9 * sideLength * (50 + critterSize / 2) / 100;
+
+		double[] xPoints = new double[3];
+		double[] yPoints = new double[3];
+
+		// determine critter orientation
+		switch (dir) {
+		case 0:
+			xPoints[0] = 0;
+			xPoints[1] = -size / 2;
+			xPoints[2] = size / 2;
+			yPoints[0] = -size / 2 * Math.sqrt(3);
+			yPoints[1] = size / 2 * Math.sqrt(3);
+			yPoints[2] = size / 2 * Math.sqrt(3);
+			break;
+		case 1:
+			xPoints[0] = 3 * size / 4;
+			xPoints[1] = -size;
+			xPoints[2] = -size / 2;
+			yPoints[0] = -size * Math.sqrt(3) / 4;
+			yPoints[1] = 0;
+			yPoints[2] = size * Math.sqrt(3) / 2;
+			break;
+		case 2:
+			xPoints[0] = 3 * size / 4;
+			xPoints[1] = -size / 2;
+			xPoints[2] = -size;
+			yPoints[0] = size * Math.sqrt(3) / 4;
+			yPoints[1] = -size * Math.sqrt(3) / 2;
+			yPoints[2] = 0;
+			break;
+		case 3:
+			xPoints[0] = 0;
+			xPoints[1] = size / 2;
+			xPoints[2] = -size / 2;
+			yPoints[0] = size / 2 * Math.sqrt(3);
+			yPoints[1] = -size / 2 * Math.sqrt(3);
+			yPoints[2] = -size / 2 * Math.sqrt(3);
+			break;
+		case 4:
+			xPoints[0] = -3 * size / 4;
+			xPoints[1] = size;
+			xPoints[2] = size / 2;
+			yPoints[0] = size * Math.sqrt(3) / 4;
+			yPoints[1] = 0;
+			yPoints[2] = -size * Math.sqrt(3) / 2;
+			break;
+		case 5:
+			xPoints[0] = -3 * size / 4;
+			xPoints[1] = size / 2;
+			xPoints[2] = size;
+			yPoints[0] = -size * Math.sqrt(3) / 4;
+			yPoints[1] = size * Math.sqrt(3) / 2;
+			yPoints[2] = 0;
+			break;
+		default:
+			return;
+		}
+
+		// translate points to current hex
+		for (int i = 0; i < 3; i++)
+			xPoints[i] += cartX;
+		for (int i = 0; i < 3; i++)
+			yPoints[i] += cartY;
+
+		// set critter color
+		int randomizer = (int) (Math.sqrt(Math.abs(species.hashCode())) * 100);
+		int blendType = randomizer % 3;
+		double blendLevel = (randomizer % 100) / 100.0;
+		// System.out.println(randomizer + " " + blendType + " " + blendLevel);
+		double red;
+		double green;
+		double blue;
+		switch (blendType) {
+		case 0:
+			red = 0;
+			green = blendLevel;
+			blue = 1 - blendLevel;
+			break;
+		case 1:
+			red = 1 - blendLevel;
+			green = 0;
+			blue = blendLevel;
+			break;
+		case 2:
+			red = blendLevel;
+			green = 1 - blendLevel;
+			blue = 0;
+			break;
+		default:
+			red = 0;
+			green = 0;
+			blue = 0;
+		}
+		Color color = new Color(red, green, blue, 1);
+
+		// draw critter (outlines only)
+		 gc.setStroke(color);
+		 gc.strokePolygon(xPoints, yPoints, 3);
+
+		// draw critter (filled in)
+		// gc.setFill(color);
+		// gc.fillPolygon(xPoints, yPoints, 3);
+	}
+
+	/**
+	 * Draws one non-critter object onto the world grid.
+	 * @param wo
+	 * @param c
+	 * @param r
+	 */
+	private void drawWorldObject(JSONWorldObject wo, int c, int r) {
+		if (!isValidHex(c, r))
+			return;
+
+		int hexCoordinates[] = new int[] { c, r };
+		double cartX = hexToCartesian(hexCoordinates)[0];
+		double cartY = hexToCartesian(hexCoordinates)[1];
+		drawHex(cartX, cartY);
+		gc.setLineWidth(3.0);
+
+		if (wo.getType().equals("rock")) {
+			
+			System.out.println("rock");
+			double size = 0.9 * sideLength;
+			gc.setStroke(Color.BROWN);// GOLDENROD
+			gc.strokeRect(cartX - size / 2, cartY - size / 2, size, size);
+		}
+		else if (wo.getType().equals("food")) {
+			System.out.println("food");
+			int calories = wo.getCalories();
+			double size = 0.9 * sideLength;
+			gc.setStroke(Color.WHITE);// RED
+			gc.strokeOval(cartX - size / 2, cartY - size / 2, size, size);
+			gc.setTextAlign(TextAlignment.CENTER);
+			gc.setFont(new Font(8 * sideLength / 30));
+			gc.setLineWidth(1);
+			gc.strokeText(String.valueOf(calories), cartX, cartY);
+			gc.setLineWidth(3);
+		} else if (wo.getType().equals("nothing")) {
+			System.out.println("nothing");
+			double a = (double) sideLength - 1.0; // for visual clarity in the calculations
+			double m = a * Math.sqrt(3) / 2.0; // for visual clarity in the calculations
+
+			double[] xPoints = { cartX + a, cartX + a / 2, cartX - a / 2, cartX - a, cartX - a / 2, cartX + a / 2 };
+			double[] yPoints = { cartY, cartY - m, cartY - m, cartY, cartY + m, cartY + m };
+			
+			gc.fillPolygon(xPoints, yPoints, 6);
+		}
+	}
+
+	/** Draws a hexagon centered at the rectangular coordinates specified by {@code centerX} and {@code centerY}. */
+	private void drawHex(double centerX, double centerY) {
+		gc.setLineWidth(1.0);
+		gc.setStroke(HEX_COLOR);
+		gc.strokePolygon(
+				new double[] { centerX + sideLength, centerX + (sideLength / 2), centerX - (sideLength / 2),
+						centerX - sideLength, centerX - (sideLength / 2), centerX + (sideLength / 2) },
+				new double[] { centerY, centerY - (Math.sqrt(3) * (sideLength / 2)),
+						centerY - (Math.sqrt(3) * (sideLength / 2)), centerY,
+						centerY + (Math.sqrt(3) * (sideLength / 2)), centerY + (Math.sqrt(3) * (sideLength / 2)) },
+				6);
+	}
+
+	/**
+	 *
+	 * @param zoomIn
+	 */
+	public void zoom(boolean zoomIn) {
+		double oldSideLength = sideLength;
+		if (zoomIn) {
+			sideLength += ZOOM_FACTOR;
+			if (sideLength >= MAX_SIDELENGTH)
+				sideLength = MAX_SIDELENGTH;
+
+		} else {
+			sideLength -= ZOOM_FACTOR;
+			if (sideLength <= MIN_SIDELENGTH)
+				sideLength = MIN_SIDELENGTH;
+		}
+		double factor = sideLength / (oldSideLength);
+
+		x_position_marker = width / 2 - (width / 2 - x_position_marker) * factor;
+		y_position_marker = height / 2 - (height / 2 - y_position_marker) * factor;
+		//redrawGrid();
+
+	}
+
+	/**
+	 * highlightHex highlights the hex that is currently selected
+	 * @param x x-coordinate of the spot that the user clicks
+	 * @param y y-coordinate of the spot that the user clicks
+	 */
+	public void highlightHex(double x, double y) {
+		int[] hexCoordinates = closestHex(x, y);
+		if (!isValidHex(hexCoordinates[0], hexCoordinates[1])) {
+			return;
+		}
+		double a = (double) sideLength; // for visual clarity in the calculations
+		double m = a * Math.sqrt(3) / 2.0; // for visual clarity in the calculations
+
+		double[] xPoints = { x + a, x + a / 2, x - a / 2, x - a, x - a / 2, x + a / 2 };
+		double[] yPoints = { y, y - m, y - m, y, y + m, y + m };
+
+		gc.setFill(HIGHLIGHT_COLOR);
+		gc.fillPolygon(xPoints, yPoints, 6);
+	}
+
+	/**
+	 * drag implements panning
+	 *
+	 * @param deltaX
+	 * @param deltaY
+	 */
+	public void drag(double deltaX, double deltaY) {
+		x_position_marker += deltaX * 0.05;
+		y_position_marker += deltaY * 0.05;
+
+		if (x_position_marker - sideLength > width)
+			x_position_marker = width - sideLength;
+		if ((((3 * sideLength) / 2) * column_drawing_marker + x_position_marker) < 0) {
+			x_position_marker = (2 * sideLength) - (((3 * sideLength) / 2) * column_drawing_marker);
+		}
+		if (y_position_marker > height)
+			y_position_marker = height - Math.sqrt(3) * sideLength;
+		if ((y_position_marker + Math.sqrt(3) * sideLength * row_drawing_marker) < 0)
+			y_position_marker = Math.sqrt(3) * sideLength - Math.sqrt(3) * sideLength * row_drawing_marker;
+
+		gc.clearRect(0, 0, width, height);
+		//redrawGrid();
+	}
+
+	public boolean select(double xCoordinate, double yCoordinate) {
+		boolean returnValue;
+		int[] closestHexCoordinates = closestHex(xCoordinate, yCoordinate);
+		if (selectedHex != null && Arrays.equals(selectedHex, closestHexCoordinates)) {
+			selectedHex = null;
+			returnValue = false;
+		} else {
+			selectedHex = closestHexCoordinates;
+			returnValue = true;
+		}
+		double[] highlightCoordinates = hexToCartesian(closestHexCoordinates);
+		highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
+		draw(cachedState);
+		return returnValue;
+	}
+
+	/**
+	 * A method that, given a set of rectangular canvas coordinates, returns the
+	 * coordinates of the hex it is located in.
+	 *
+	 * @param xCoordinate
+	 * @param yCoordinate
+	 * @return An {@code int} array containing the (c, r) coordinates of the closest
+	 *         hex.
+	 */
+	public int[] closestHex(double xCoordinate, double yCoordinate) {
+		// determines the possible hexes that the point could be in
+		int possibleColumnOne = (int) Math.ceil(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
+		int possibleColumnTwo = (int) (2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
+		int possibleRowOne = (int) Math.ceil((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
+				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
+		int possibleRowTwo = (int) ((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
+				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
+
+		int[][] possibleCoordinates = new int[4][2];
+		possibleCoordinates[0] = new int[] { possibleColumnOne, possibleRowOne };
+		possibleCoordinates[1] = new int[] { possibleColumnOne, possibleRowTwo };
+		possibleCoordinates[2] = new int[] { possibleColumnTwo, possibleRowOne };
+		possibleCoordinates[3] = new int[] { possibleColumnTwo, possibleRowTwo };
+
+		double distanceSquared = Integer.MAX_VALUE;
+		int returnIndex = 0;
+		for (int i = 0; i < 4; i++) {
+			// System.out.println("Option #" + i + ": " + possibleCoordinates[i][0] + " " +
+			// possibleCoordinates[i][1]);
+			double tempArray[] = hexToCartesian(possibleCoordinates[i]);
+			double tempDistanceSquared = Math.pow(xCoordinate - tempArray[0], 2)
+					+ Math.pow(yCoordinate - tempArray[1], 2);
+			if (tempDistanceSquared < distanceSquared) {
+				distanceSquared = tempDistanceSquared;
+				returnIndex = i;
+			}
+		}
+		// System.out.println(possibleCoordinates[returnIndex][0] + " " +
+		// possibleCoordinates[returnIndex][1]);
+		// System.out.println("\n");
+		return possibleCoordinates[returnIndex];
+	}
+
+	/**
+	 * A method that converts a hex coordinate pair to cartesian coordinates.
+	 * @param hexCoordinates
+	 * @return
+	 */
+	private double[] hexToCartesian(int[] hexCoordinates) {
+		double x_coordinate = ((3 * sideLength) / 2) * hexCoordinates[0] + origin_x;
+		double y_coordinate = ((Math.sqrt(3) * sideLength) / 2) * hexCoordinates[0]
+				- sideLength * Math.sqrt(3) * hexCoordinates[1] + origin_y;
+		return new double[] { x_coordinate, y_coordinate };
+	}
+
+	public int[] getSelectedHex() {
+		return selectedHex;
+	}
+}
diff --git a/src/main/java/distributed/CritterJSON.java b/src/main/java/distributed/CritterJSON.java
new file mode 100644
index 0000000..334f175
--- /dev/null
+++ b/src/main/java/distributed/CritterJSON.java
@@ -0,0 +1,44 @@
+package distributed;
+
+public class CritterJSON {
+
+	private String species_id;
+	private String program;
+	private int[] mem;
+	private PositionJSON[] positions;
+	private Integer num;
+
+	public CritterJSON(String species_id, String program, int[] mem, PositionJSON[] positions) {
+		this.species_id = species_id;
+		this.program = program;
+		this.mem = mem;
+		this.positions = positions;
+	}
+
+	public CritterJSON(String species_id, String program, int[] mem, int num) {
+		this.species_id = species_id;
+		this.program = program;
+		this.mem = mem;
+		this.num = num;
+	}
+
+	public String getSpeciesId() {
+		return this.species_id;
+	}
+
+	public String getProgram() {
+		return this.program;
+	}
+
+	public int[] getMem() {
+		return this.mem;
+	}
+
+	public PositionJSON[] getPositions() {
+		return this.positions;
+	}
+
+	public Integer getNum() {
+		return this.num;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/JSONWorldObject.java b/src/main/java/distributed/JSONWorldObject.java
new file mode 100644
index 0000000..d87375c
--- /dev/null
+++ b/src/main/java/distributed/JSONWorldObject.java
@@ -0,0 +1,218 @@
+package distributed;
+
+import java.util.Arrays;
+
+import simulation.Food;
+import simulation.Rock;
+import simulation.SimpleCritter;
+import simulation.WorldObject;
+
+/** A class to provide JSON representations of world objects (food, rocks, critters, nothing). */
+public class JSONWorldObject {
+	/** The column index of the object. */
+	private Integer col;
+	/** The row index of the object. */
+	private Integer row;
+	/** The type of the object, as a string. */
+	private String type;
+
+	/** Food objects only: the number of calories. */
+	private Integer value;
+	private Integer amount;
+	/** Critter objects only: the critter ID. */
+	private Integer id;
+	/** Critter objects only: the species name. */
+	private String species_id;
+	/** Critter objects only: the direction of the critter. */
+	private Integer direction;
+	/** Critter objects only: the critter memory. */
+	private int[] mem;
+	/** Critter objects only: the string representation of the memory. */
+	private String program;
+	/** Critter objects only: the index of the most recently executed rule. */
+	private Integer recently_executed_rule;
+	
+	
+	
+	
+
+
+	/**
+	 * Creates a new JSON object of type "rock" or "nothing".
+	 * @param typ The type of the object (must be either "rock" or "nothing")
+	 * @param c The column index of the object
+	 * @param r The row index of the object
+	 */
+	public JSONWorldObject(String typ, int c, int r) {
+		type = typ;
+		col = c;
+		row = r;
+	}
+
+	/**
+	 * Creates a JSON object of type food.
+	 * @param typ The type of the object (must be "food")
+	 * @param c The column index of the object
+	 * @param r The row index of the object
+	 * @param calories The number of calories in the food
+	 */
+	public JSONWorldObject(String typ, int c, int r, int calories) {
+		type = typ;
+		col = c;
+		row = r;
+		value = calories;
+	}
+
+	/**
+	 * Creates a JSON critter object for which the user has full permissions
+	 * @param typ The type of the object (must be "critter")
+	 * @param c The column index of the object
+	 * @param r The row index of the object
+	 * @param dir The direction the critter is facing
+	 * @param critterID The unique ID of the critter
+	 * @param species The species name of the critter
+	 * @param program The String representation of the critter's program
+	 * @param memory The memory of the critter
+	 * @param ruleIndex The index of the critter's last executed rule
+	 */
+	public JSONWorldObject(String typ, int c, int r, int dir, int critterID, String species, String prog, int[] memory, int ruleIndex) {
+		type = typ;
+		col = c;
+		row = r;
+		direction = dir;
+		id = critterID;
+		species_id = species;
+		program = prog;
+		mem = memory;
+		recently_executed_rule = ruleIndex;
+
+	}
+	
+	
+	public JSONWorldObject(int col, int row, String type, int amount) {
+		this.row = row;
+		this.col = col;
+		this.type = type;
+		this.amount = amount;
+	}
+	
+	/**
+	 * Creates a JSON critter object for which the user does not have full permissions
+	 * @param typ The type of the object (must be "critter")
+	 * @param c The column index of the object
+	 * @param r The row index of the object
+	 * @param dir The direction the critter is facing
+	 * @param critterID The unique ID of the critter
+	 * @param species The species name of the critter
+	 * @param memory The memory of the critter
+	 */
+	public JSONWorldObject(String typ, int c, int r, int dir, int critterID, String species, int[] memory) {
+		type = typ;
+		col = c;
+		row = r;
+		direction = dir;
+		id = critterID;
+		species_id = species;
+		mem = memory;
+	}
+
+	/**
+	 *
+	 * @param wo
+	 * @param c
+	 * @param r
+	 */
+	public JSONWorldObject(WorldObject wo, int c, int r) {
+		col = c;
+		row = r;
+
+		if(wo instanceof Rock) {
+			type = "rock";
+		} else if(wo instanceof Food) {
+			type = "food";
+			value = ((Food) wo).getCalories();
+		} else if(wo == null) {
+			type = "nothing";
+		}
+	}
+
+	/**
+	 *
+	 * @param sc
+	 * @param c
+	 * @param r
+	 * @param fullPermissions
+	 */
+	public JSONWorldObject(SimpleCritter sc, int c, int r, int critterID, boolean fullPermissions) {
+		type = "critter";
+		col = c;
+		row = r;
+		direction = sc.getOrientation();
+		id = critterID;
+		species_id = sc.getName();
+		mem = sc.getMemoryCopy();
+		if(fullPermissions) {
+			program = sc.getProgram().toString();
+			recently_executed_rule = sc.getLastRuleIndex();
+		}
+	}
+
+	/** Returns the type of this object. */
+	public String getType() {
+		return type;
+	}
+
+	/** Returns the column index of this object. */
+	public Integer getCol() {
+		return col;
+	}
+
+	/** Returns the row index of this object. */
+	public Integer getRow() {
+		return row;
+	}
+
+	/** Returns the caloric content of this object, if it is food. */
+	public Integer getCalories() {
+		return value;
+	}
+
+	public Integer getCritterID() {
+		return id;
+	}
+
+	public String getSpeciesName() {
+		return species_id;
+	}
+
+	public Integer getOrientation() {
+		return direction;
+	}
+
+	public int[] getMemory() {
+		return mem;
+	}
+
+	public String getProgram() {
+		return program;
+	}
+
+	public Integer getLastRuleIndex() {
+		return recently_executed_rule;
+	}
+	
+	public Integer getAmount() {
+		return this.amount;
+	}
+	@Override
+	public int hashCode() {
+		String s = "";
+		if(type.equals("critter"))
+			s += type + col + row + id + species_id + direction + Arrays.toString(mem) + program + recently_executed_rule;
+		else if(type.equals("food"))
+			s += type + col + row + value;
+		else
+			s += type + col + row;
+		return s.hashCode();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/LoadCritterResponseJSON.java b/src/main/java/distributed/LoadCritterResponseJSON.java
new file mode 100644
index 0000000..e89d472
--- /dev/null
+++ b/src/main/java/distributed/LoadCritterResponseJSON.java
@@ -0,0 +1,11 @@
+package distributed;
+
+public class LoadCritterResponseJSON {
+	private String species_id;
+	private int[] ids;
+	
+	public LoadCritterResponseJSON(String species, int[] IDList) {
+		species_id = species;
+		ids = IDList;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/LoadWorldInfoJSON.java b/src/main/java/distributed/LoadWorldInfoJSON.java
new file mode 100644
index 0000000..d2e0b57
--- /dev/null
+++ b/src/main/java/distributed/LoadWorldInfoJSON.java
@@ -0,0 +1,14 @@
+package distributed;
+
+public class LoadWorldInfoJSON {
+
+	private String description;
+	
+	public LoadWorldInfoJSON(String description) {
+		this.description = description;
+	}
+	
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/src/main/java/distributed/Main.java b/src/main/java/distributed/Main.java
new file mode 100644
index 0000000..e4f519f
--- /dev/null
+++ b/src/main/java/distributed/Main.java
@@ -0,0 +1,32 @@
+package distributed;
+
+import gui.GUI;
+
+public class Main {
+	private static Server server;
+
+	public static void main(String[] args) {
+		String readPassword = null;
+		String writePassword = null;
+		String adminPassword = null;
+		int portNumber = 0;
+		try {
+			if (args.length == 0) {
+				GUI.main(null);
+
+			} else if (args.length == 4) {
+				portNumber = Integer.valueOf(args[0]);
+				readPassword = args[1];
+				writePassword = args[2];
+				adminPassword = args[3];
+				server = Server.getInstance(portNumber, readPassword, writePassword, adminPassword);
+				server.run();
+			} else {
+				System.out.println("Incorrect number of arguments... initializing client.");
+				GUI.main(null);
+			}
+		} catch (Exception e) {
+			System.out.println("Server was not started. Please start server first.");
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/PositionJSON.java b/src/main/java/distributed/PositionJSON.java
new file mode 100644
index 0000000..8d73d8a
--- /dev/null
+++ b/src/main/java/distributed/PositionJSON.java
@@ -0,0 +1,21 @@
+package distributed;
+
+public class PositionJSON {
+
+	private Integer row;
+	private Integer col;
+
+	public PositionJSON(int col, int row) {
+		this.row = row;
+		this.col = col;
+	}
+
+	public Integer getRow(){
+		return this.row;
+	}
+	
+	public Integer getColumn() {
+		return this.col;
+	}
+	
+}
diff --git a/src/main/java/distributed/Server.java b/src/main/java/distributed/Server.java
new file mode 100644
index 0000000..2f01f2f
--- /dev/null
+++ b/src/main/java/distributed/Server.java
@@ -0,0 +1,535 @@
+package distributed;
+
+import static spark.Spark.get;
+import static spark.Spark.delete;
+import static spark.Spark.port;
+import static spark.Spark.post;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.Map.Entry;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.json.simple.JSONObject;
+import com.google.gson.Gson;
+
+import ast.Program;
+import distributed.SimulationControlJSON.CountJSON;
+import distributed.SimulationControlJSON.RateJSON;
+import parse.ParserImpl;
+import simulation.Critter;
+import simulation.Food;
+import simulation.Hex;
+import simulation.Rock;
+import simulation.SimpleCritter;
+import simulation.WorldObject;
+
+/** A server that responds to HTTP requests. */
+public class Server {
+	/** The single instance of the server. */
+	private static Server serverInstance;
+	/** The port on which the server is run. */
+	private static int portNumber;
+	/** The password for read access to the server. */
+	private final String readPassword;
+	/** The password for write access to the server. */
+	private final String writePassword;
+	/** The password for admin access to the server. */
+	private final String adminPassword;
+	/** The rate at which the world is run. */
+	private float simulationRate;
+	private int session_id_count;
+	private HashMap<Integer, String> sessionIdMap;
+	private ServerWorldModel model;
+	private ReentrantReadWriteLock rwl;
+
+	/**
+	 * Creates a new server.
+	 *
+	 * @param portNum
+	 * @param readPass
+	 * @param writePass
+	 * @param adminPass
+	 */
+	private Server(int portNum, String readPass, String writePass, String adminPass) {
+		portNumber = portNum;
+		readPassword = readPass;
+		writePassword = writePass;
+		adminPassword = adminPass;
+		model = new ServerWorldModel();
+		sessionIdMap = new HashMap<Integer, String>();
+		rwl = new ReentrantReadWriteLock();
+		simulationRate = 0;
+	}
+
+	public static Server getInstance(int portNum, String readPass, String writePass, String adminPass) {
+		serverInstance = new Server(portNum, readPass, writePass, adminPass);
+		return serverInstance;
+	}
+
+	@SuppressWarnings("unchecked")
+	/**
+	 * Runs the server by receiving requests from the client and responding
+	 * appropriately.
+	 */
+	public void run() {
+		Gson gson = new Gson();
+		port(portNumber);
+
+		post("/login", (request, response) -> {
+			System.out.println(request.body());
+			response.header("Content-Type", "application/json");
+			JSONObject responseValue = new JSONObject();
+			String json = request.body();
+			LoginInfo loginInfo = gson.fromJson(json, LoginInfo.class);
+			String level = loginInfo.level;
+			String password = loginInfo.password;
+			if (level.equals("read") && password.equals(readPassword)) {
+				session_id_count++;
+				responseValue.put("session_id", new Integer(session_id_count));
+				sessionIdMap.put(session_id_count, "read");
+				response.status(200);
+				return responseValue;
+			} else if (level.equals("write") && password.equals(writePassword)) {
+				session_id_count++;
+				responseValue.put("session_id", new Integer(session_id_count));
+				sessionIdMap.put(session_id_count, "write");
+				response.status(200);
+				return responseValue;
+			} else if (level.equals("admin") && password.equals(adminPassword)) {
+				session_id_count++;
+				responseValue.put("session_id", new Integer(session_id_count));
+				sessionIdMap.put(session_id_count, "admin");
+				response.status(200);
+				return responseValue;
+			} else {
+				response.status(401);
+				return "Please enter in a proper password.";
+			}
+
+		}, gson::toJson);
+
+		delete("/critter", (request, response) -> {
+			response.header("Content-Type", "text/plain");
+			String queryString = request.queryString();
+			int sessionId = -1;
+			int critterId = -1;
+			if (queryString.indexOf("&id") != -1) {
+				int indexOfSessionId = queryString.indexOf("session_id=") + "session_id=".length();
+				int indexOfCritterId = queryString.indexOf("id=", queryString.indexOf('&')) + "id=".length();
+				sessionId = Integer.parseInt(queryString.substring(indexOfSessionId, queryString.indexOf("&")));
+				critterId = Integer.parseInt(queryString.substring(indexOfCritterId));
+			} else {
+				int indexOfSessionId = queryString.indexOf("session_id=") + "session_id=".length();
+				int indexOfCritterId = queryString.indexOf("id=") + "id=".length();
+				sessionId = Integer.parseInt(queryString.substring(indexOfSessionId));
+				critterId = Integer.parseInt(queryString.substring(indexOfCritterId, queryString.indexOf("&")));
+			}
+			if ((model.hasCritterPermissions(model.retrieveCritter(critterId), sessionId) || sessionIdMap.get(sessionId).equals("admin"))&& model.retrieveCritter(critterId) != null) {
+				model.removeCritter(critterId);
+				response.status(204);
+				return "Removal was successful.";
+			}
+			else {
+				response.status(401);
+				return "Removal was unsuccessful.";
+			}
+
+		});
+		// handles a client request to load a new world
+		post("/world", (request, response) -> {
+			response.header("Content-Type", "text/plain");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=", 0) + 11;
+			int session_id = Integer.parseInt(queryString.substring(indexOfSessionId));
+			String json = request.body();
+			System.out.println(json);
+			LoadWorldInfoJSON loadWorldInfo = gson.fromJson(json, LoadWorldInfoJSON.class);
+			String description = loadWorldInfo.getDescription();
+			if (sessionIdMap.get(session_id) == null || !sessionIdMap.get(session_id).equals("admin")) {
+				response.status(401);
+				return "User does not have admin access.";
+			} else {
+				model.loadWorld(description);
+				response.status(201);
+				return "Ok";
+			}
+		});
+
+		get("/world", (request, response) -> {
+			response.header("Content-Type", "application/json");
+			String queryString = request.queryString();
+			if (queryString.indexOf("from_row") != -1) {
+			String[] parameters = queryString.split("&");
+			int[] values = new int[parameters.length];
+			int sessionID = -1;
+			int updateSince = 0;
+			int from_row = 0;
+			int to_row = 0;
+			int from_column = 0;
+			int to_column = 0;
+			for (int i = 0; i < parameters.length; i++) {
+				String holder = parameters[i];
+				values[i] = Integer.parseInt(holder.substring(holder.indexOf("=") + 1));
+			}
+			for (int i = 0; i < values.length; i++) {
+				if (parameters[i].indexOf("session_id") != -1) {
+					sessionID = values[i];
+				} else if (parameters[i].indexOf("update_since") != -1) {
+					updateSince = values[i];
+				} else if (parameters[i].indexOf("from_row") != -1) {
+					from_row = values[i];
+				} else if (parameters[i].indexOf("to_row") != -1) {
+					to_row = values[i];
+				} else if (parameters[i].indexOf("from_column") != -1) {
+					from_column = values[i];
+				} else if (parameters[i].indexOf("to_column") != -1) {
+					to_column = values[i];
+				}
+			}
+			if (from_row > to_row || from_column > to_column) {
+				response.status(406);
+				return "The from coordinates cannot be less than the two coordinates";
+			}
+			if (from_row < 0 || from_column < 0 || to_row < 0|| to_column < 0) {
+				response.status(406);
+				return "The boundary coordinates cannot be negative.";
+			}
+			if (sessionIdMap.get(sessionID) == null) {
+				response.status(401);
+				return "User does not have permission to view the world.";
+			} else if (updateSince < 0 || updateSince > model.getCurrentVersionNumber()) {
+				response.status(406);
+				return "That version number is invalid.";
+			} else if (!model.isReady()) {
+				response.status(403);
+				return "A world must be loaded before you can view the world state.";
+			} else {
+				int time = model.getCurrentTimeStep();
+				int version = model.getCurrentVersionNumber();
+				float rate = this.simulationRate;
+				String name = model.getWorldName();
+				int population = model.getNumCritters();
+				int columns = model.getColumns();
+				int rows = model.getRows();
+				int[] deadList = model.getCumulativeDeadCritters();
+				System.out.println(deadList);
+				HashMap<Hex, WorldObject> objects = model.updateSince(updateSince, from_row, to_row, from_column, to_column);
+				JSONWorldObject[] state = new JSONWorldObject[objects.size()];
+				int counter = 0;
+				for (Entry<Hex, WorldObject> entry : objects.entrySet()) {
+					int c = entry.getKey().getColumnIndex();
+					int r = entry.getKey().getRowIndex();
+					WorldObject wo = entry.getValue();
+					if (wo instanceof SimpleCritter) {
+						SimpleCritter sc = (SimpleCritter) wo;
+						int critterID = model.getID(sc);
+						boolean permissions = model.hasCritterPermissions(sc, sessionID);
+						state[counter] = new JSONWorldObject(sc, c, r, critterID, permissions);
+					} else {
+						state[counter] = new JSONWorldObject(wo, c, r);
+					}
+					counter++;
+				}
+				response.status(200);
+				return new WorldStateJSON(time, version, updateSince, rate, name, population, columns, rows, deadList,
+						state);
+			}
+			} else {
+				int indexOfSessionID = queryString.indexOf("session_id=") + "session_id=".length();
+				int sessionID = -1;
+				int updateSince = 0;
+				if (queryString.contains("&update_since")) {
+					int indexOfUpdateSince = queryString.indexOf("&update_since=") + "&update_since=".length();
+					sessionID = Integer
+							.parseInt(queryString.substring(indexOfSessionID, queryString.indexOf("&update_since")));
+					updateSince = Integer.parseInt(queryString.substring(indexOfUpdateSince));
+				} else if (queryString.contains("&session_id=")) {
+					indexOfSessionID = queryString.indexOf("&session_id=") + "&session_id=".length();
+					int indexOfUpdateSince = queryString.indexOf("update_since=") + "update_since=".length();
+					updateSince = Integer
+							.parseInt(queryString.substring(indexOfUpdateSince, queryString.indexOf("&session_id=")));
+					sessionID = Integer.parseInt(queryString.substring(indexOfSessionID));
+				} else {
+					sessionID = Integer.parseInt(queryString.substring(indexOfSessionID));
+				}
+
+				if (sessionIdMap.get(sessionID) == null) {
+					response.status(401);
+					return "User does not have permission to view the world.";
+				} else if (updateSince < 0 || updateSince > model.getCurrentVersionNumber()) {
+					response.status(406);
+					return "That version number is invalid.";
+				} else if (!model.isReady()) {
+					response.status(403);
+					return "A world must be loaded before you can view the world state.";
+				} else {
+					int time = model.getCurrentTimeStep();
+					int version = model.getCurrentVersionNumber();
+					float rate = simulationRate;
+					String name = model.getWorldName();
+					int population = model.getNumCritters();
+					int columns = model.getColumns();
+					int rows = model.getRows();
+					int[] deadList = model.getCumulativeDeadCritters();
+					System.out.println(deadList);
+					HashMap<Hex, WorldObject> objects = model.updateSince(updateSince);
+					JSONWorldObject state[] = new JSONWorldObject[objects.size()];
+					int counter = 0;
+					for (Entry<Hex, WorldObject> entry : objects.entrySet()) {
+						int c = entry.getKey().getColumnIndex();
+						int r = entry.getKey().getRowIndex();
+						WorldObject wo = entry.getValue();
+						if (wo instanceof SimpleCritter) {
+							SimpleCritter sc = (SimpleCritter) wo;
+							int critterID = model.getID(sc);
+							boolean permissions = model.hasCritterPermissions(sc, sessionID);
+							state[counter] = new JSONWorldObject(sc, c, r, critterID, permissions);
+						} else {
+							state[counter] = new JSONWorldObject(wo, c, r);
+						}
+						counter++;
+					}
+					response.status(200);
+					return new WorldStateJSON(time, version, updateSince, rate, name, population, columns, rows, deadList,
+							state);
+				}
+			}
+		}, gson::toJson);
+
+		get("/critters", (request, response) -> {
+			response.header("Content-Type", "application/json");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=", 0) + 11;
+			int sessionID = Integer.parseInt(queryString.substring(indexOfSessionId));
+			if (sessionIdMap.get(sessionID) == null) {
+				response.status(401);
+				return "User does not have permission to view the world.";
+			} else {
+				SimpleCritter[] critters = model.listCritters();
+				System.out.println(critters);
+				JSONWorldObject[] crittersJSON = new JSONWorldObject[critters.length];
+				int counter = 0;
+				for (SimpleCritter critter : critters) {
+					boolean hasFullPermission = model.hasCritterPermissions(critter, sessionID);
+					int column = model.getCritterLocation(critter)[0];
+					int row = model.getCritterLocation(critter)[0];
+					int critterId = model.getID(critter);
+					JSONWorldObject holder = new JSONWorldObject(critter, column, row, critterId, hasFullPermission);
+					crittersJSON[counter] = holder;
+					counter++;
+				}
+				response.status(200);
+				return crittersJSON;
+			}
+		}, gson::toJson);
+
+		get("/critter", (request, response) -> {
+			response.header("Content-Type", "application/json");
+			String queryString = request.queryString();
+			int sessionId = -1;
+			int critterId = -1;
+			if (queryString.indexOf("&id") != -1) {
+				int indexOfSessionId = queryString.indexOf("session_id=") + "session_id=".length();
+				int indexOfCritterId = queryString.indexOf("id=", queryString.indexOf('&')) + "id=".length();
+				sessionId = Integer.parseInt(queryString.substring(indexOfSessionId, queryString.indexOf("&")));
+				critterId = Integer.parseInt(queryString.substring(indexOfCritterId));
+			} else {
+				int indexOfSessionId = queryString.indexOf("session_id=") + "session_id=".length();
+				int indexOfCritterId = queryString.indexOf("id=") + "id=".length();
+				sessionId = Integer.parseInt(queryString.substring(indexOfSessionId));
+				critterId = Integer.parseInt(queryString.substring(indexOfCritterId, queryString.indexOf("&")));
+			}
+			if (sessionIdMap.get(sessionId) == null) {
+				response.status(401);
+				return "User does not have permission to view the world.";
+			} else if (model.retrieveCritter(critterId) == null) {
+				response.status(401);
+				return "Critter with the following id does not exist in the world.";
+			} else {
+				SimpleCritter critter = model.retrieveCritter(critterId);
+				boolean hasFullPermission = model.hasCritterPermissions(critter, sessionId);
+				int column = model.getCritterLocation(critter)[0];
+				int row = model.getCritterLocation(critter)[0];
+				JSONWorldObject holder = new JSONWorldObject(critter, column, row, critterId, hasFullPermission);
+				response.status(200);
+				return holder;
+			}
+
+		}, gson::toJson);
+
+		// handles a client request to load in critters
+		post("/critters", (request, response) -> {
+			System.out.println("We have reached critters"); // TODO remove
+			response.header("Content-Type", "application/json");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=", 0) + 10;
+			int session_id = Integer.parseInt(queryString.substring(indexOfSessionId + 1));
+			if (!(sessionIdMap.get(session_id) != null && (sessionIdMap.get(session_id).equals("admin")
+					|| sessionIdMap.get(session_id).equals("write")))) {
+				response.status(401);
+				return "User does not have write access.";
+			}
+			String json = request.body();
+			System.out.println(json);
+			CritterJSON loadCritterInfo = gson.fromJson(json, CritterJSON.class);
+			ParserImpl parser = new ParserImpl();
+			InputStream stream = new ByteArrayInputStream(
+					loadCritterInfo.getProgram().getBytes(StandardCharsets.UTF_8.name()));
+			BufferedReader reader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
+			Program program = parser.parse(reader);
+			reader.close();
+			int[] ids = null;
+			SimpleCritter critter = new Critter(program, loadCritterInfo.getMem(), loadCritterInfo.getSpeciesId());
+			if (loadCritterInfo.getPositions() == null)
+				ids = model.loadCritterRandomLocations(critter, loadCritterInfo.getNum(), session_id);
+			else {
+				PositionJSON[] positions = loadCritterInfo.getPositions();
+				int counter = 0;
+				ids = new int[positions.length];
+				for (PositionJSON positionHolder : positions) {
+					int c = positionHolder.getColumn();
+					int r = positionHolder.getRow();
+					int id = model.loadCritterAtLocation(critter, c, r, session_id);
+					ids[counter] = id;
+					counter++;
+				}
+			}
+			LoadCritterResponseJSON lcr = new LoadCritterResponseJSON(critter.getName(), ids);
+			System.out.println(model.getNumCritters());
+			response.status(200);
+			return lcr;
+		}, gson::toJson);
+
+		post("/world/create_entity", (request, response) -> {
+			System.out.println("Step has been reached");
+			response.header("Content-Type", "text/plain");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=") + 11;
+			int session_id = Integer.parseInt(queryString.substring(indexOfSessionId));
+			if (!((sessionIdMap.get(session_id) != null) && ((sessionIdMap.get(session_id).equals("admin"))|| (sessionIdMap.get(session_id).equals("write"))))) {
+				response.status(401);
+				return "User does not have write access.";
+			}
+			String json = request.body();
+			System.out.println(json);
+			JSONWorldObject entityInfo = gson.fromJson(json, JSONWorldObject.class);
+			if (entityInfo.getType().equals("rock") && entityInfo.getAmount( )!= null) {
+				response.status(406);
+				return "Rocks cannot have an amount.";
+			}
+			WorldObject object;
+			if (entityInfo.getType().equals("rock")) {
+				object = new Rock();
+			}
+			else {
+				object = new Food(entityInfo.getAmount());
+			}
+			if (!model.addWorldObject(object, entityInfo.getCol(), entityInfo.getRow())) {
+				response.status(406);
+				return "Invalid hex, location already occupied.";
+			}
+
+			response.status(200);
+			return "Ok";
+		});
+
+		post("/step", (request, response) -> {
+			response.header("Content-Type", "text/plain");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=") + 11;
+			int session_id = Integer.parseInt(queryString.substring(indexOfSessionId));
+			if (!(sessionIdMap.get(session_id) != null && (sessionIdMap.get(session_id).equals("admin")
+					|| sessionIdMap.get(session_id).equals("write")))) {
+				response.status(401);
+				return "User does not have write access.";
+			}
+			if (simulationRate != 0) {
+				response.status(406);
+				return "User cannot step because rate is not 0.";
+			}
+			String json = request.body();
+			System.out.println(json);
+			CountJSON stepInfo = gson.fromJson(json, CountJSON.class);
+			int count = 1;
+			if (stepInfo != null) {
+				if (stepInfo.getCount() < 0) {
+					response.status(406);
+					return "World cannot be stepped a negative amount of times.";
+				}
+				else
+					count = stepInfo.getCount();
+			}
+
+			for (int i = 0; i < count; i++) {
+				System.out.println("ok");
+				model.advanceTime();
+			}
+			response.status(200);
+			return "Ok";
+		});
+
+		post("/run", (request, response) -> {
+			response.header("Content-Type", "text/plain");
+			String queryString = request.queryString();
+			int indexOfSessionId = queryString.indexOf("session_id=") + 11;
+			int session_id = Integer.parseInt(queryString.substring(indexOfSessionId));
+			if (!(sessionIdMap.get(session_id) != null && (sessionIdMap.get(session_id).equals("admin")
+					|| sessionIdMap.get(session_id).equals("write")))) {
+				response.status(401);
+				return "User does not have write access.";
+			}
+			String json = request.body();
+			RateJSON info = gson.fromJson(json, RateJSON.class);
+
+			if(info.getRate() < 0 || info.getRate() > 50) {
+				response.status(406);
+				return "Invalid simulation rate.";
+			} else {
+				rwl.writeLock().lock();
+				simulationRate = info.getRate();
+				rwl.writeLock().unlock();
+			}
+			return "Ok";
+
+		});
+
+		Thread worldUpdateThread = new Thread(new Runnable() {
+			@Override
+			public void run() {
+				while(simulationRate > 0) {
+					long time = (long) (1000 / simulationRate);
+					rwl.writeLock().lock();
+					model.advanceTime();
+					rwl.writeLock().unlock();
+
+					try {
+						Thread.sleep(time);
+					} catch(InterruptedException i) {
+						System.out.println("Could not pause thread execution.");
+					}
+				}
+			}});
+		worldUpdateThread.start();
+	}
+
+	/** Returns the port number of the server. */
+	public static int getPortNum() {
+		return portNumber;
+	}
+
+	class LoginInfo {
+
+		String level;
+		String password;
+
+		private LoginInfo(String level, String password) {
+			this.level = level;
+			this.password = password;
+		}
+	}
+}
diff --git a/src/main/java/distributed/ServerWorldModel.java b/src/main/java/distributed/ServerWorldModel.java
new file mode 100644
index 0000000..010fea9
--- /dev/null
+++ b/src/main/java/distributed/ServerWorldModel.java
@@ -0,0 +1,407 @@
+package distributed;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import simulation.SimpleCritter;
+import simulation.SimpleWorld;
+import simulation.World;
+import simulation.WorldObject;
+import simulation.Hex;
+
+/**
+ * The model that stores world and critter states server-side. It also serves as
+ * an abstraction barrier between the world and the modules that interact with
+ * the world.
+ */
+public class ServerWorldModel {
+
+	/** An instance of the world. */
+	private SimpleWorld world;
+	/** The number of critters. */
+	private int numCritters;
+	/** The number of time steps taken. */
+	private int time;
+	/** The current world version number. */
+	private int versionNumber;
+	/** A running list of all critters that have died across all worlds simulated in this session. */
+	private LinkedList<Integer> cumulativeDeadCritters;
+	/** Supplies the locks for the models. */
+	private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
+	/**
+	 * A log of all the changes that have occurred to the world since version 0
+	 * (which is a blank world).
+	 */
+	private ArrayList<ArrayList<Hex>> diffLog;
+
+	/** Creates a new blank world model. */
+	public ServerWorldModel() {
+		rwl.writeLock().lock();
+		try {
+			numCritters = 0;
+			time = 0;
+			versionNumber = 0;
+			diffLog = new ArrayList<ArrayList<Hex>>();
+			cumulativeDeadCritters = new LinkedList<Integer>();
+		} finally {
+			rwl.writeLock().unlock();
+		}
+	}
+
+	/**
+	 * Loads in a world based on a description.
+	 *
+	 * @param desc
+	 * @throws IllegalArgumentException
+	 *             if the description is invalid
+	 * @throws UnsupportedOperationException
+	 *             if the constants.txt file could not be read
+	 */
+	public void loadWorld(String desc) throws IllegalArgumentException, UnsupportedOperationException {
+		rwl.writeLock().lock();
+		try {
+			// if a world already exists, adds all its dead critters to the cumulative dead
+			// critter list
+			if (world != null) {
+				for(SimpleCritter sc : world.collectCritterCorpses())
+					cumulativeDeadCritters.add(world.getCritterID(sc));
+				for(SimpleCritter sc : world.collectCritterCorpses())
+					cumulativeDeadCritters.add(world.getCritterID(sc));
+			}
+			world = new World(desc);
+			diffLog.add(world.getAndResetUpdatedHexes());
+			time = 0;
+			versionNumber++;
+			numCritters = world.numRemainingCritters();
+		} finally {
+			rwl.writeLock().unlock();
+		}
+	}
+
+	/** */
+	public boolean isReady() {
+		try {
+			rwl.readLock().lock();
+			return world != null;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the name of the world. */
+	public String getWorldName() {
+		try {
+			rwl.readLock().lock();
+			return world.getWorldName();
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the number of columns in the world. */
+	public int getColumns() {
+		rwl.readLock().lock();
+		try {
+			return world.getColumns();
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the number of rows in the world. */
+	public int getRows() {
+		rwl.readLock().lock();
+		try {
+			return world.getRows();
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the number of living critters in the world. */
+	public int getNumCritters() {
+		try {
+			rwl.readLock().lock();
+			return numCritters;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the current time step of the world. */
+	public int getCurrentTimeStep() {
+		try {
+			rwl.readLock().lock();
+			return time;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Returns the current version number. */
+	public int getCurrentVersionNumber() {
+		try {
+			rwl.readLock().lock();
+			return versionNumber;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Retrieves the running list of dead critters. */
+	public int[] getCumulativeDeadCritters() {
+		try {
+			rwl.readLock().lock();
+			int[] result = new int[cumulativeDeadCritters.size()];
+			for (int i = 0; i < cumulativeDeadCritters.size(); i++)
+				result[i] = cumulativeDeadCritters.get(i);
+			return result;
+		} finally {
+			rwl.readLock().unlock();
+		}
+
+	}
+
+	/** Returns an array of all living critters. */
+	public SimpleCritter[] listCritters() {
+		try {
+			rwl.readLock().lock();
+			SimpleCritter[] result = new SimpleCritter[world.getCritterList().size()];
+			return world.getCritterList().toArray(result);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/**
+	 * Gets a critter's ID from a pointer to that critter
+	 * @param sc
+	 * @return The critter's ID, or 0 if no critter ID exists for that critter
+	 */
+	public int getID(SimpleCritter sc) {
+		try {
+			rwl.readLock().lock();
+			return world.getCritterID(sc);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+
+	/** Determines whether a given sessionID has full permissions for a given critter. */
+	public boolean hasCritterPermissions(SimpleCritter sc, int sessionID) {
+		try {
+			rwl.readLock().lock();
+			Integer creatorID = world.getCritterCreatorID(sc);
+			assert creatorID != null;
+			return creatorID == sessionID;
+		} finally {
+			rwl.readLock().unlock();
+		}
+
+	}
+
+	/**
+	 * Returns a number giving information about a hex.
+	 * @param c
+	 * @param r
+	 * @return
+	 */
+	public int hexInfo(int c, int r) {
+		rwl.readLock().lock();
+		try {
+			return world.analyzeHex(c, r);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/**
+	 *
+	 * @param c
+	 * @param r
+	 * @return
+	 */
+	public SimpleCritter getCritter(int c, int r) {
+		rwl.readLock().lock();
+		try {
+			return world.analyzeCritter(c, r);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Advances one time step. */
+	public void advanceTime() {
+		world.advanceOneTimeStep();
+		time++;
+		versionNumber++;
+		diffLog.add(world.getAndResetUpdatedHexes());
+		numCritters = world.numRemainingCritters();
+	}
+
+	/**
+	 * Provides a map of everything that has changed in the world since the initial
+	 * version.
+	 *
+	 * @param initialVersionNumber
+	 * @return a HashMap mapping changed hexes to the objects at those hexes.
+	 */
+	public HashMap<Hex, WorldObject> updateSince(int initialVersionNumber) {
+		try {
+			rwl.readLock().lock();
+			if (initialVersionNumber < 0 || initialVersionNumber > diffLog.size())
+				return null;
+			HashMap<Hex, WorldObject> result = new HashMap<Hex, WorldObject>();
+			for (int i = initialVersionNumber; i < diffLog.size(); i++) {
+				for (Hex h : diffLog.get(i)) {
+					int c = h.getColumnIndex();
+					int r = h.getRowIndex();
+					if(isValidHex(c, r))
+						result.put(h, world.getHexContent(c, r));
+				}
+			}
+			return result;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+	
+	/**
+	 * 
+	 * @param initialVersionNumber
+	 * @param from_row
+	 * @param to_row
+	 * @param from_column
+	 * @param to_column
+	 * @return
+	 */
+	public HashMap<Hex, WorldObject> updateSince(int initialVersionNumber, int from_row, int to_row, int from_column, int to_column) {
+		try {
+			rwl.readLock().lock();
+			if (initialVersionNumber < 0 || initialVersionNumber > diffLog.size())
+				return null;
+			HashMap<Hex, WorldObject> result = new HashMap<Hex, WorldObject>();
+			for (int i = initialVersionNumber; i < diffLog.size(); i++) {
+				for (Hex h : diffLog.get(i)) {
+					int c = h.getColumnIndex();
+					int r = h.getRowIndex();
+					if(isValidHex(c, r) && c >= from_column && c <= to_column && r >= from_row && r <= to_row )
+						result.put(h, world.getHexContent(c, r));
+				}
+			}
+			return result;
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
+	private boolean isValidHex(int c, int r) {
+		if (c < 0 || r < 0)
+			return false;
+		else if (c >= world.getColumns() || r >= world.getRows())
+			return false;
+		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * world.getRows() - world.getColumns()))
+			return false;
+		return true;
+	}
+	/**
+	 * Returns a critter object based on its ID
+	 * @param id
+	 * @return The critter with the specified ID, or {@code null} if no such critter exists
+	 */
+	public SimpleCritter retrieveCritter(int id) {
+		try {
+			rwl.readLock().lock();
+			return world.getCritterFromID(id);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/** Provides the hex coordinate location of a critter. */
+	public int[] getCritterLocation(SimpleCritter sc) {
+		try {
+			rwl.readLock().lock();
+			return world.getCritterLocation(sc);
+		} finally {
+			rwl.readLock().unlock();
+		}
+	}
+
+	/**
+	 * Removes a critter from the world, if it is there.
+	 * @param id The ID of the critter to remove
+	 */
+	public void removeCritter(int id) {
+		try {
+			rwl.writeLock().lock();
+			world.removeCritter(world.getCritterFromID(id));
+		} finally {
+			diffLog.add(world.getAndResetUpdatedHexes());
+			versionNumber++;
+			numCritters = world.numRemainingCritters();
+			rwl.writeLock().unlock();
+		}
+	}
+
+	/**
+	 * Loads in critters of a certain species into the world at random locations.
+	 * @param sc The critter species
+	 * @param n The number to add
+	 * @param sessionID
+	 * @return The IDs of the added critters
+	 */
+	public int[] loadCritterRandomLocations(SimpleCritter sc, int n, int sessionID) {
+		try {
+			rwl.writeLock().lock();
+			return world.loadCritters(sc, n, sessionID);
+		} finally {
+			diffLog.add(world.getAndResetUpdatedHexes());
+			versionNumber++;
+			numCritters = world.numRemainingCritters();
+			rwl.writeLock().unlock();
+		}
+	}
+
+	/**
+	 * Loads in a critter of a certain species into the world.
+	 * @param sc The critter species
+	 * @param c The column index at which to add the critter
+	 * @param r The row index at which to add the critter
+	 * @param sessionID
+	 * @return The ID of the added critter
+	 */
+	public int loadCritterAtLocation(SimpleCritter sc, int c, int r, int sessionID) {
+		try {
+			rwl.writeLock().lock();
+			return world.loadOneCritter(sc, c, r, sessionID);
+		} finally {
+			diffLog.add(world.getAndResetUpdatedHexes());
+			versionNumber++;
+			numCritters = world.numRemainingCritters();
+			rwl.writeLock().unlock();
+		}
+	}
+
+	/**
+	 * Loads a non-critter world object into the world.
+	 * @param wo The object to load in (can be food or a rock)
+	 * @param c The column index at which to add the object
+	 * @param r The row index at which to add the object
+	 */
+	public boolean addWorldObject(WorldObject wo, int c, int r) {
+		try {
+			rwl.writeLock().lock();
+			boolean isValid = world.addNonCritterObject(wo, c, r);
+			return isValid;
+		} finally {
+			diffLog.add(world.getAndResetUpdatedHexes());
+			versionNumber++;
+			rwl.writeLock().unlock();
+		}
+	}
+}
diff --git a/src/main/java/distributed/SessionID.java b/src/main/java/distributed/SessionID.java
new file mode 100644
index 0000000..705768f
--- /dev/null
+++ b/src/main/java/distributed/SessionID.java
@@ -0,0 +1,14 @@
+package distributed;
+
+public class SessionID {
+
+	private int session_id;
+
+	public SessionID(int sessionID) {
+		this.session_id = sessionID;
+	}
+	
+	public int getSessionID() {
+		return session_id;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/distributed/SimulationControlJSON.java b/src/main/java/distributed/SimulationControlJSON.java
new file mode 100644
index 0000000..23075f0
--- /dev/null
+++ b/src/main/java/distributed/SimulationControlJSON.java
@@ -0,0 +1,29 @@
+package distributed;
+
+public class SimulationControlJSON {
+	
+	public static class RateJSON {
+		private Float rate;
+		
+		public RateJSON(float f) {
+			rate = f;
+		}
+		
+		public Float getRate() {
+			return rate;
+		}
+	}
+	
+	public static class CountJSON {
+
+		private Integer count;
+		
+		public CountJSON(int count) {
+			this.count = count;
+		}
+		
+		public Integer getCount() {
+			return this.count;
+		}
+	}
+}
diff --git a/src/main/java/distributed/WorldStateJSON.java b/src/main/java/distributed/WorldStateJSON.java
new file mode 100644
index 0000000..7ad2ea3
--- /dev/null
+++ b/src/main/java/distributed/WorldStateJSON.java
@@ -0,0 +1,75 @@
+package distributed;
+
+import java.util.Arrays;
+
+/** A JSON representation of the state of a world. */
+public class WorldStateJSON {
+	private Integer current_timestep;
+	private Integer current_version_number;
+	private Integer update_since;
+	private Float rate;
+	private String name;
+	private Integer population;
+	private Integer cols;
+	private Integer rows;
+	private int[] dead_critters;
+	private JSONWorldObject[] state;
+	
+	/** Creates a new WorldStateJSON object. */
+	public WorldStateJSON(int time, int version, int updateSince, float runrate, String worldname,
+						  int numCritters, int c, int r, int[] deadList, JSONWorldObject[] objectList) {
+		current_timestep = time;
+		current_version_number = version;
+		update_since = updateSince;
+		rate = runrate;
+		name = worldname;
+		population = numCritters;
+		cols = c;
+		rows = r;
+		dead_critters = Arrays.copyOf(deadList, deadList.length);
+		//state = new JSONWorldObject[objectList.length];
+		//System.arraycopy(objectList, 0, state, 0 , objectList.length);
+		state = objectList;
+		//System.out.println(state.length);
+	}
+	
+	public Integer getCurrentTime() {
+		return current_timestep;
+	}
+	
+	public Integer getCurrentVersion() {
+		return current_version_number;
+	}
+	
+	public Float getRate() {
+		return rate;
+	}
+	
+	public Integer getCols() {
+		return cols;
+	}
+	
+	public Integer getRows() {
+		return rows;
+	}
+	
+	public Integer getUpdateSince() {
+		return update_since;
+	}
+	
+	public Integer getPopulation() {
+		return population;
+	}
+	
+	public String getName() {
+		return name;
+	}
+	
+	public int[] getDeadCritters() {
+		return dead_critters;
+	}
+	
+	public JSONWorldObject[] getWorldObjects() {
+		return state;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/A6_written_problems.txt b/src/main/java/gui/A6_written_problems.txt
deleted file mode 100644
index 4a2f8b6..0000000
--- a/src/main/java/gui/A6_written_problems.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-1. An implementation of or() is provided below:
-
-/** Returns: disjunction of this and that (this OR that). */
-public TVBool or(TVBool that) {
-	TVBool result = new TVBool();
-	result.state = Math.max(this.state, that.state);
-	return result;
-}
-
-2. normalize() is implemented correctly because it is simply a checking method whose job is to assert that there isn't any flaws in the logic of the other methods. It never actually changes the representation of the TVBool when being accessed by different classes because if the normalize method retains the sign of the field state even if the technical value of the field is changed. not() is implemented correctly because it never actually changes the value of the field state. It creates a new object, sets the state of that object, and returns that object. It never alters the state of the original object.
-
-3. The hashCode() method is incorrect because if two TVBools are equal, they need to have the same hash code. The given implementation does not have this property. A correct implementation is provided below:
-
-@Override
-public int hashCode() {
-	return Integer.signum(state);
-}
-
-An implementation of equals() is provided below:
-
-@Override
-public boolean equals(Object o) {
-	if (Integer.signum(state) == Integer.signum(o.state)) {
-		return true;
-	} else {
-		return false;
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/gui/ClientController.java b/src/main/java/gui/ClientController.java
new file mode 100644
index 0000000..e98e177
--- /dev/null
+++ b/src/main/java/gui/ClientController.java
@@ -0,0 +1,698 @@
+package gui;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.Optional;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import com.google.gson.Gson;
+
+import distributed.ClientRequestHandler;
+import distributed.ClientWorldMap;
+import distributed.SessionID;
+import distributed.WorldStateJSON;
+import javafx.animation.Timeline;
+import javafx.application.Platform;
+import javafx.beans.value.ChangeListener;
+import javafx.beans.value.ObservableValue;
+import javafx.event.ActionEvent;
+import javafx.fxml.FXML;
+import javafx.scene.canvas.Canvas;
+import javafx.scene.control.Alert;
+import javafx.scene.control.Alert.AlertType;
+import javafx.scene.control.Button;
+import javafx.scene.control.ButtonType;
+import javafx.scene.control.Dialog;
+import javafx.scene.control.DialogPane;
+import javafx.scene.control.Label;
+import javafx.scene.control.MenuItem;
+import javafx.scene.control.ScrollPane;
+import javafx.scene.control.Slider;
+import javafx.scene.control.TextField;
+import javafx.scene.control.TextInputDialog;
+import javafx.scene.control.Toggle;
+import javafx.scene.control.ToggleButton;
+import javafx.scene.control.ToggleGroup;
+import javafx.scene.image.ImageView;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.KeyEvent;
+import javafx.scene.input.MouseButton;
+import javafx.scene.input.MouseEvent;
+import javafx.scene.input.ScrollEvent;
+import javafx.scene.layout.VBox;
+import javafx.scene.text.Text;
+import javafx.stage.FileChooser;
+import javafx.stage.Popup;
+
+/**
+ * This class handles user inputs and sends information to the world model and
+ * world view to update their states accordingly.
+ */
+public class ClientController {
+	@FXML
+	private MenuItem help;
+	@FXML
+	private MenuItem close;
+
+	@FXML
+	private Text columnText;
+	@FXML
+	private Text rowText;
+	@FXML
+	private Text memSizeText;
+	@FXML
+	private Text speciesText;
+	@FXML
+	private Text defenseText;
+	@FXML
+	private Text offenseText;
+	@FXML
+	private Text energyText;
+	@FXML
+	private Text passText;
+	@FXML
+	private Text tagText;
+	@FXML
+	private Text postureText;
+	@FXML
+	private Text sizeText;
+	@FXML
+	private Label lastRuleDisplay;
+	@FXML
+	private Button displayProgram;
+
+	@FXML
+	private Button newWorld;
+	@FXML
+	private Button loadWorld;
+	@FXML
+	private Button loadCritterFile;
+	@FXML
+	private ToggleGroup LoadChoice;
+	@FXML
+	private ToggleButton chkRandom;
+	@FXML
+	private ToggleButton chkSpecify;
+	@FXML
+	private TextField numCritters;
+	@FXML
+	private Button stepForward;
+	@FXML
+	private Button run;
+	@FXML
+	private Button pause;
+	@FXML
+	private Slider simulationSpeed;
+
+	@FXML
+	private ScrollPane scroll;
+	@FXML
+	private Canvas c;
+	@FXML
+	private Label crittersAlive;
+	@FXML
+	private Label stepsTaken;
+
+	/** A timeline that redraws the world periodically. */
+	private Timeline timeline;
+	/** Controls the hex grid. */
+	private ClientWorldMap map;
+	/** The rate at which the simulation is run. */
+	private long simulationRate;
+	/** The executor used to periodically query the world for updates. */
+	private ScheduledExecutorService executor;
+
+	private double panMarkerX;
+	private double panMarkerY;
+
+	/**
+	 * True when the user is in the process of dragging, so that upon release, hex
+	 * selection is NOT performed on the hex currently under the mouse pointer.
+	 */
+	private boolean isCurrentlyDragging = false;
+	private LoginInfo loginInfo;
+	private String urlInitial;
+	private int sessionID;
+	private ClientRequestHandler handler;
+	private int currentVersion;
+	private WorldModel localCache;
+
+	/** Logs into the server. */
+	private void login() {
+		Gson gson = new Gson();
+		Dialog<LoginInfo> dialog = new Dialog<>();
+		dialog.setTitle("Login Info");
+		dialog.setHeaderText("Please Enter In The Passwords You Have Access To");
+		DialogPane dialogPane = dialog.getDialogPane();
+		dialogPane.getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
+		TextField levelTextField = new TextField("Level");
+		TextField passwordTextField = new TextField("Password");
+		TextField urlTextField = new TextField("http://localhost:8080");
+		// TextField urlTextField = new
+		// TextField("http://hexworld.herokuapp.com:80/hexworld");
+		dialogPane.setContent(new VBox(8, levelTextField, passwordTextField, urlTextField));
+		Platform.runLater(levelTextField::requestFocus);
+		dialog.setResultConverter((ButtonType button) -> {
+			if (button == ButtonType.OK) {
+				return new LoginInfo(levelTextField.getText(), passwordTextField.getText(), urlTextField.getText());
+			}
+			return null;
+		});
+		Optional<LoginInfo> optionalResult = dialog.showAndWait();
+		optionalResult.ifPresent((LoginInfo results) -> {
+			loginInfo = new LoginInfo(results.level, results.password);
+			this.urlInitial = results.url;
+		});
+		URL url = null;
+		try {
+			url = new URL(this.urlInitial + "/login");
+			// url = new URL("http://hexworld.herokuapp.com:80/hexworld/login");
+			System.out.println(gson.toJson(loginInfo, LoginInfo.class));
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			System.out.println(url.toString());
+			connection.setDoOutput(true); // send a POST message
+			connection.setRequestMethod("POST");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(loginInfo, LoginInfo.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+
+				Alert alert = new Alert(AlertType.CONFIRMATION);
+				alert.setTitle("Login Error");
+				alert.setHeaderText("Credentials Not Recognized");
+				alert.setContentText("The login credentials you entered were invalid. Click "
+						+ "OK to continue in local mode or Cancel to exit the program.");
+				Optional<ButtonType> result = alert.showAndWait();
+
+				if (result.get() == ButtonType.OK) {
+					System.exit(0);
+				} else {
+					System.exit(0);
+				}
+			}
+
+			BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			String sessionIdString = "";
+			String holder = r.readLine();
+			while (holder != null) {
+				sessionIdString += holder;
+				holder = r.readLine();
+			}
+			SessionID sessionId = gson.fromJson(sessionIdString, SessionID.class);
+			sessionID = sessionId.getSessionID();
+			System.out.println(sessionId.getSessionID());
+
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+			Alert alert = new Alert(AlertType.CONFIRMATION);
+			alert.setTitle("Login Error");
+			alert.setHeaderText("Credentials Not Recognized");
+			alert.setContentText("The login credentials you entered were invalid. Click "
+					+ "OK to continue in local mode or Cancel to exit the program.");
+			Optional<ButtonType> result = alert.showAndWait();
+
+			if (result.get() == ButtonType.OK) {
+				System.exit(0);
+			} else {
+				System.exit(0);
+			}
+			return;
+		} catch (IOException e) {
+			System.out.println("Could not connect to the server");
+			Alert alert = new Alert(AlertType.CONFIRMATION);
+			alert.setTitle("Login Error");
+			alert.setHeaderText("Credentials Not Recognized");
+			alert.setContentText("The login credentials you entered were invalid. Click "
+					+ "OK to continue in local mode or Cancel to exit the program.");
+			Optional<ButtonType> result = alert.showAndWait();
+
+			if (result.get() == ButtonType.OK) {
+				System.exit(0);
+			} else {
+				System.exit(0);
+			}
+			return;
+		}
+
+		handler = new ClientRequestHandler(this.urlInitial);
+	}
+
+	@FXML
+	public void initialize() {
+
+		// System.out.println("Initialize has been reached");
+		login();
+
+		loadCritterFile.setDisable(true);
+		numCritters.setDisable(true);
+		pause.setDisable(true);
+
+		setupCanvas();
+		setGUIReady(true);
+
+		WorldStateJSON wsj = handler.updateSince(sessionID, 0);
+<<<<<<< HEAD
+		if(wsj != null) {
+			localCache = new WorldModel();
+			localCache.loadWorld(wsj);
+			map = new ClientWorldMap(c, wsj.getCols(), wsj.getRows());
+=======
+
+		if (wsj != null) {
+			map = new ClientWorldMap(c, wsj.getCols(), wsj.getRows());
+			// System.out.println("This is map:" + map);
+>>>>>>> c6213f729701d0170d823f05cf5a429bcb103686
+			currentVersion = wsj.getCurrentVersion();
+			setGUIReady(true);
+			map.draw(wsj);
+			crittersAlive.setText("Critters Alive: " + wsj.getPopulation());
+			stepsTaken.setText("Time: " + wsj.getCurrentTime());
+		}
+
+		LoadChoice.selectedToggleProperty().addListener(new ChangeListener<Toggle>() {
+			@Override
+			public void changed(ObservableValue<? extends Toggle> ov, Toggle oldT, Toggle newT) {
+				if (newT == null) {
+					numCritters.setDisable(true);
+					loadCritterFile.setDisable(true);
+				} else if (newT == (Toggle) chkRandom) {
+					numCritters.setDisable(false);
+					loadCritterFile.setDisable(false);
+				} else if (newT == (Toggle) chkSpecify) {
+					numCritters.setDisable(true);
+					loadCritterFile.setDisable(false);
+				}
+			}
+		});
+
+		// // adds a listener to the slider to adjust world speed as the slider is
+		// changed
+		// simulationSpeed.valueProperty().addListener(new ChangeListener<Number>() {
+		// public void changed(ObservableValue<? extends Number> ov, Number old_val,
+		// Number new_val) {
+		// simulationRate = new_val.longValue();
+		// }
+		// });
+	}
+
+	private void setupCanvas() {
+		c.addEventFilter(MouseEvent.ANY, (e) -> c.requestFocus());
+
+		c.heightProperty().bind(scroll.heightProperty());
+		c.widthProperty().bind(scroll.widthProperty());
+
+		// listeners that dynamically redraw the canvas in response to window resizing
+		c.heightProperty().addListener(update -> {
+			if (map != null)
+				// System.out.println("Updating is happening");
+				map.draw(handler.updateSince(sessionID, currentVersion));
+		});
+		c.widthProperty().addListener(update -> {
+			if (map != null)
+				// System.out.println("Updating is happening");
+				map.draw(handler.updateSince(sessionID, currentVersion));
+		});
+	}
+
+	private void setGUIReady(boolean isReady) {
+		chkRandom.setDisable(!isReady);
+		chkSpecify.setDisable(!isReady);
+		stepForward.setDisable(!isReady);
+		run.setDisable(!isReady);
+		simulationSpeed.setDisable(!isReady);
+		displayProgram.setDisable(!isReady);
+		c.setDisable(!isReady);
+		c.setVisible(isReady);
+	}
+
+	private void resetInfo() {
+		numCritters.clear();
+
+		memSizeText.setText("");
+		speciesText.setText("");
+		defenseText.setText("");
+		offenseText.setText("");
+		sizeText.setText("");
+		energyText.setText("");
+		passText.setText("");
+		tagText.setText("");
+		postureText.setText("");
+		lastRuleDisplay.setText("");
+		lastRuleDisplay.setWrapText(true);
+
+		chkRandom.setSelected(false);
+		chkSpecify.setSelected(false);
+	}
+
+	private void updateView() {
+		System.out.println("View is being updated");
+		WorldStateJSON update = handler.updateSince(sessionID, currentVersion);
+		currentVersion = update.getCurrentVersion();
+		if (map == null)
+			map = new ClientWorldMap(c, update.getCols(), update.getRows());
+		map.draw(update);
+		crittersAlive.setText("Critters Alive: " + update.getPopulation());
+		stepsTaken.setText("Time: " + update.getCurrentTime());
+	}
+
+	@FXML
+	private void handleNewWorldPressed(MouseEvent me) {
+		newWorldServer();
+	}
+
+	private void newWorldServer() {
+		if (handler.createNewWorld(sessionID)) {
+			setGUIReady(true);
+			updateView();
+		}
+	}
+
+	@FXML
+	private void handleLoadWorldPressed(MouseEvent me) {
+		FileChooser fc = new FileChooser();
+		fc.setTitle("Choose World File");
+		File initDirectory = new File("./src/test/resources/simulationtests"); // TODO remove before submitting?
+		fc.setInitialDirectory(initDirectory); // TODO remove before submitting?
+		File worldFile = fc.showOpenDialog(new Popup());
+		if (worldFile == null) {
+			return;
+		}
+
+		loadServerWorld(worldFile);
+	}
+
+	private void loadServerWorld(File worldFile) {
+		try {
+			handler.loadWorld(worldFile, sessionID);
+			setGUIReady(true);
+			updateView();
+		} catch (FileNotFoundException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		} catch (IllegalArgumentException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		} catch (IOException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		}
+	}
+
+	@FXML
+	private void handleLoadCritters(MouseEvent me) {
+		FileChooser fc = new FileChooser();
+		fc.setTitle("Choose Critter File");
+		File f = new File("./src/test/resources/simulationtests"); // TODO remove
+		fc.setInitialDirectory(f); // TODO remove
+		File critterFile = fc.showOpenDialog(new Popup());
+		if (critterFile == null)
+			return;
+
+		ToggleButton choice = (ToggleButton) LoadChoice.getSelectedToggle();
+		if (choice == chkRandom) {
+			try {
+				int n = Integer.parseInt(numCritters.getText());
+				handler.loadRandomCritters(critterFile, n, sessionID);
+			} catch (NumberFormatException e) {
+				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid number of critters to load in.");
+				a.setTitle("Invalid Number");
+				a.showAndWait();
+				return;
+			} catch (FileNotFoundException e) {
+				Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+				a.setTitle("Invalid File");
+				a.showAndWait();
+				return;
+			}
+		} else {
+			TextInputDialog dialog = new TextInputDialog();
+			dialog.setTitle("Choose Hex");
+			dialog.setHeaderText("Enter \"[columns] [rows]\".");
+			Optional<String> result = dialog.showAndWait();
+
+			try {
+				result.ifPresent(location -> {
+					String col = result.get().split(" ")[0];
+					String row = result.get().split(" ")[1];
+					int c = Integer.parseInt(col);
+					int r = Integer.parseInt(row);
+					try {
+						handler.loadCritterAtLocation(critterFile, c, r, sessionID);
+					} catch (FileNotFoundException e) {
+						Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+						a.setTitle("Invalid File");
+						a.showAndWait();
+						return;
+					}
+				});
+			} catch (Exception e) {
+				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid location");
+				a.setTitle("Invalid Location");
+				a.showAndWait();
+				return;
+			}
+		}
+		updateView();
+	}
+
+	@FXML
+	private void handleStep(MouseEvent me) {
+		// model.advanceTime();
+		// updateInfoBox();
+		// map.draw();
+		// crittersAlive.setText("Critters Alive: " + model.getNumCritters());
+		// stepsTaken.setText("Time: " + model.getCurrentTimeStep());
+		handler.advanceTime(sessionID);
+		updateView();
+	}
+
+	@FXML
+	private void handleRunPressed(MouseEvent me) {
+		Thread worldUpdateThread = new Thread(new Runnable() {
+			@Override
+			public void run() {
+				updateView();
+				// System.out.println("ASFAS");
+			}
+		});
+		worldUpdateThread.setDaemon(true);
+
+		executor = Executors.newSingleThreadScheduledExecutor();
+		executor.scheduleAtFixedRate(worldUpdateThread, 0, 1000 / simulationRate, TimeUnit.MILLISECONDS);
+		//
+		// timeline = new Timeline(new KeyFrame(Duration.millis(1000 / 30), new
+		// EventHandler<ActionEvent>() {
+		//
+		// @Override
+		// public void handle(ActionEvent ae) {
+		// updateInfoBox();
+		// map.draw();
+		// updateInfoBox();
+		// crittersAlive.setText("Critters Alive: " + model.getNumCritters());
+		// stepsTaken.setText("Time: " + model.getCurrentTimeStep());
+		// }
+		// }));
+		//
+		// timeline.setCycleCount(Timeline.INDEFINITE);
+		// timeline.play();
+
+		newWorld.setDisable(true); // TODO should we take these 4 lines out so you can create a new world even
+									// while the current one is still running?
+		loadWorld.setDisable(true); // TODO refer to above
+		loadCritterFile.setDisable(true);
+		chkRandom.setDisable(true);
+		chkSpecify.setDisable(true);
+		numCritters.setDisable(true);
+		stepForward.setDisable(true);
+		run.setDisable(true);
+		simulationSpeed.setDisable(true);
+
+		pause.setDisable(false);
+	}
+
+	@FXML
+	private void handlePauseClicked(MouseEvent me) {
+
+	}
+
+	@FXML
+	private void handleMapClicked(MouseEvent me) {
+		if (me.getButton() == MouseButton.PRIMARY && !isCurrentlyDragging) {
+			double xCoordinateSelected = me.getSceneX();
+			double yCoordinateSelected = me.getSceneY() - 25;
+			map.select(xCoordinateSelected, yCoordinateSelected);
+			updateInfoBox();
+		}
+		isCurrentlyDragging = false;
+	}
+
+	private void updateInfoBox() {
+		// if (map.getSelectedHex() != null) {
+		// int[] hexCoordinatesSelected = map.getSelectedHex();
+		// columnText.setText(String.valueOf(hexCoordinatesSelected[0]));
+		// rowText.setText(String.valueOf(hexCoordinatesSelected[1]));
+		// if (model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]) !=
+		// null) {
+		// SimpleCritter critter = model.getCritter(hexCoordinatesSelected[0],
+		// hexCoordinatesSelected[1]);
+		// memSizeText.setText(String.valueOf(critter.getMemLength()));
+		// speciesText.setText(critter.getName());
+		// int[] critterMemoryCopy = new int[critter.getMemLength()];
+		// critterMemoryCopy = critter.getMemoryCopy();
+		// defenseText.setText(String.valueOf(critterMemoryCopy[1]));
+		// offenseText.setText(String.valueOf(critterMemoryCopy[2]));
+		// sizeText.setText(String.valueOf(critterMemoryCopy[3]));
+		// energyText.setText(String.valueOf(critterMemoryCopy[4]));
+		// passText.setText(String.valueOf(critterMemoryCopy[5]));
+		// tagText.setText(String.valueOf(critterMemoryCopy[6]));
+		// postureText.setText(String.valueOf(critterMemoryCopy[7]));
+		// lastRuleDisplay.setText("Last rule: " + "\n" + critter.getLastRuleString());
+		// } else {
+		// memSizeText.setText("");
+		// speciesText.setText("");
+		// defenseText.setText("");
+		// offenseText.setText("");
+		// sizeText.setText("");
+		// energyText.setText("");
+		// passText.setText("");
+		// tagText.setText("");
+		// postureText.setText("");
+		// }
+		// } else {
+		// columnText.setText("");
+		// rowText.setText("");
+		// }
+	}
+
+	@FXML
+	private void handleMapScroll(ScrollEvent se) {
+		if (se.getDeltaY() > 0) {
+			map.zoom(true);
+		} else {
+			map.zoom(false);
+		}
+	}
+
+	@FXML
+	private void handleMapDrag(MouseEvent me) {
+		if (me.isPrimaryButtonDown()) {
+			if (!isCurrentlyDragging) {
+				// sets initial coordinates for the drag
+				panMarkerX = me.getSceneX();
+				panMarkerY = me.getSceneY();
+			}
+			isCurrentlyDragging = true;
+
+			map.drag((me.getSceneX() - panMarkerX) / 0.05, (me.getSceneY() - panMarkerY) / 0.05);
+
+			panMarkerX = me.getSceneX();
+			panMarkerY = me.getSceneY();
+		}
+	}
+
+	@FXML
+	private void handleKeyEvents(KeyEvent ke) {
+		// TODO make it possible to press multiple keys at once for panning? seems to be
+		// difficult.
+		if (ke.getCode().equals(KeyCode.UP)) {
+			map.drag(0, 400);
+		}
+		if (ke.getCode().equals(KeyCode.LEFT)) {
+			map.drag(400, 0);
+		}
+		if (ke.getCode().equals(KeyCode.DOWN)) {
+			map.drag(0, -400);
+		}
+		if (ke.getCode().equals(KeyCode.RIGHT)) {
+			map.drag(-400, 0);
+		}
+		if (ke.getCode().equals(KeyCode.EQUALS)) {
+			map.zoom(true);
+		} else if (ke.getCode().equals(KeyCode.MINUS)) {
+			map.zoom(false);
+		}
+	}
+
+	@FXML
+	private void help(ActionEvent ae) {
+		String fileName = "instructions.txt";
+		ImageView imgview = new ImageView(GUI.icon);
+		Alert alert = new Alert(AlertType.INFORMATION);
+		alert.setGraphic(imgview);
+		try {
+			String helpText = new String(Files.readAllBytes(Paths.get(fileName)));
+			alert.setContentText(helpText);
+			alert.setHeaderText("How to Use CRITTERWORLD");
+			alert.showAndWait();
+		} catch (IOException e) {
+			String errorText = "Please refer to user manual for instructions on how to use product.";
+			alert.setContentText(errorText);
+			alert.setHeaderText(null);
+			alert.showAndWait();
+		}
+	}
+
+	@FXML
+	private void close(ActionEvent ae) {
+		if (executor != null)
+			executor.shutdownNow();
+		if (timeline != null)
+			timeline.stop();
+		System.exit(0);
+	}
+
+	@FXML
+	private void handleDisplayProgram(MouseEvent me) {
+		// int[] hexCoordinates = new int[2];
+		// hexCoordinates = map.getSelectedHex();
+		// if (hexCoordinates == null) {
+		// return;
+		// }
+		// if (model.getCritter(hexCoordinates[0], hexCoordinates[1]) != null) {
+		// SimpleCritter critter = model.getCritter(hexCoordinates[0],
+		// hexCoordinates[1]);
+		// Program critterProgram = critter.getProgram();
+		// String critterProgramString = critterProgram.toString();
+		// Alert alert = new Alert(AlertType.INFORMATION, critterProgramString);
+		// ImageView imgview = new ImageView(GUI.icon);
+		// alert.setGraphic(imgview);
+		// alert.setHeaderText("Critter Program");
+		// alert.showAndWait();
+		// }
+	}
+
+	public class LoginInfo {
+
+		String level;
+		String password;
+		String url;
+
+		private LoginInfo(String level, String password) {
+			this.level = level;
+			this.password = password;
+		}
+
+		private LoginInfo(String level, String password, String url) {
+			this.level = level;
+			this.password = password;
+			this.url = url;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/Controller.java b/src/main/java/gui/Controller.java
index 5e2fb56..7f89757 100644
--- a/src/main/java/gui/Controller.java
+++ b/src/main/java/gui/Controller.java
@@ -1,15 +1,31 @@
 package gui;
 
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.Optional;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
+import com.google.gson.Gson;
+
 import ast.Program;
+import distributed.ClientRequestHandler;
+import distributed.ClientWorldMap;
+import distributed.SessionID;
+import distributed.WorldStateJSON;
 import javafx.animation.KeyFrame;
 import javafx.animation.Timeline;
+import javafx.application.Platform;
 import javafx.beans.value.ChangeListener;
 import javafx.beans.value.ObservableValue;
 import javafx.event.ActionEvent;
@@ -19,17 +35,25 @@ import javafx.scene.canvas.Canvas;
 import javafx.scene.control.Alert;
 import javafx.scene.control.Alert.AlertType;
 import javafx.scene.control.Button;
+import javafx.scene.control.ButtonType;
+import javafx.scene.control.Dialog;
+import javafx.scene.control.DialogPane;
 import javafx.scene.control.Label;
 import javafx.scene.control.MenuItem;
-import javafx.scene.control.RadioButton;
 import javafx.scene.control.ScrollPane;
 import javafx.scene.control.Slider;
-import javafx.scene.control.TextArea;
 import javafx.scene.control.TextField;
 import javafx.scene.control.TextInputDialog;
+import javafx.scene.control.Toggle;
+import javafx.scene.control.ToggleButton;
 import javafx.scene.control.ToggleGroup;
+import javafx.scene.image.ImageView;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.KeyEvent;
+import javafx.scene.input.MouseButton;
 import javafx.scene.input.MouseEvent;
 import javafx.scene.input.ScrollEvent;
+import javafx.scene.layout.VBox;
 import javafx.scene.text.Text;
 import javafx.stage.FileChooser;
 import javafx.stage.Popup;
@@ -69,10 +93,10 @@ public class Controller {
 	@FXML
 	private Text sizeText;
 	@FXML
-	private TextArea lastRuleDisplay;
+	private Label lastRuleDisplay;
 	@FXML
 	private Button displayProgram;
-	
+
 	@FXML
 	private Button newWorld;
 	@FXML
@@ -82,9 +106,9 @@ public class Controller {
 	@FXML
 	private ToggleGroup LoadChoice;
 	@FXML
-	private RadioButton chkRand;
+	private ToggleButton chkRandom;
 	@FXML
-	private RadioButton chkSpecify;
+	private ToggleButton chkSpecify;
 	@FXML
 	private TextField numCritters;
 	@FXML
@@ -94,8 +118,6 @@ public class Controller {
 	@FXML
 	private Button pause;
 	@FXML
-	private Button reset;
-	@FXML
 	private Slider simulationSpeed;
 
 	@FXML
@@ -107,305 +129,533 @@ public class Controller {
 	@FXML
 	private Label stepsTaken;
 
+	/** A timeline that redraws the world periodically. */
 	private Timeline timeline;
-	/** The model that contains the world state. */
-	private WorldModel model;
+	/** A local cached version of the world. */
+	private WorldModel localCache;
 	/** Controls the hex grid. */
 	private WorldMap map;
-
-	private double mousePanPressedX;
-	private double mousePanPressedY;
-	
 	/** The rate at which the simulation is run. */
 	private long simulationRate;
 	/** The executor that is used to step the world periodically. */
 	private ScheduledExecutorService executor;
 
+	private double panMarkerX;
+	private double panMarkerY;
+
+	/**
+	 * True when the user is in the process of dragging, so that upon release, hex
+	 * selection is NOT performed on the hex currently under the mouse pointer.
+	 */
+	private boolean isCurrentlyDragging = false;
+	private LoginInfo loginInfo;
+	private String urlInitial;
+	private int sessionID;
+	private boolean localMode;
+	private ClientRequestHandler handler;
+	private int currentVersion;
+
+	private boolean devMode = true; // TODO make false before submitting
+
 	@FXML
 	public void initialize() {
-		model = new WorldModel();
+		login();
+		loadCritterFile.setDisable(true);
+		numCritters.setDisable(true);
+		pause.setDisable(true);
+		localCache = new WorldModel();
+
+		simulationRate = 30;
+		setupCanvas();
+		setGUIReady(false);
+		if(!localMode) {
+			setGUIReady(true);
+			continuouslyRefreshView();
+		}
+	}
+
+	public void continuouslyRefreshView() {
+		Thread refresh = new Thread(new Runnable() {
+			@Override
+			public void run() {
+				while(simulationRate > 0) {
+					long time = (long) (1000 / simulationRate);
+					System.out.println("blah");
+					updateView();
+					
+					try {
+						Thread.sleep(time);
+					} catch(InterruptedException i) {
+						System.out.println("Could not pause thread execution.");
+					}
+				}
+			}
+		});
+		refresh.setDaemon(true);
+		Platform.runLater(refresh);
+	}
+	
+	private void updateView() {
+		WorldStateJSON update = handler.updateSince(sessionID, currentVersion);
+		if(update != null) {
+			System.out.println("update");
+			currentVersion = update.getCurrentVersion();
+			localCache.loadWorld(update);
+			if(map == null)
+				map = new WorldMap(c, localCache);
+			map.draw();
+			crittersAlive.setText("Critters Alive: " + update.getPopulation());
+			stepsTaken.setText("Time: " + update.getCurrentTime());
+		}
+	}
+	
+	private void doReset() {
+		if (executor != null)
+			executor.shutdownNow();
+		if (timeline != null)
+			timeline.stop();
+
 		simulationRate = 30;
-		
-		newWorld.setDisable(false);
-		loadWorld.setDisable(false);
+
 		loadCritterFile.setDisable(true);
-		chkRand.setDisable(true);
-		chkSpecify.setDisable(true);
 		numCritters.setDisable(true);
-		stepForward.setDisable(true);
-		run.setDisable(true);
 		pause.setDisable(true);
-		reset.setDisable(true);
-		simulationSpeed.setDisable(true);
+		setGUIReady(false);
+		resetInfo();
 
 		c.getGraphicsContext2D().clearRect(0, 0, c.getWidth(), c.getHeight());
-		c.setDisable(true);
-		c.setVisible(false);
+
+		LoadChoice.selectedToggleProperty().addListener(new ChangeListener<Toggle>() {
+			@Override
+			public void changed(ObservableValue<? extends Toggle> ov, Toggle oldT, Toggle newT) {
+				if (newT == null) {
+					numCritters.setDisable(true);
+					loadCritterFile.setDisable(true);
+				} else if (newT == (Toggle) chkRandom) {
+					numCritters.setDisable(false);
+					loadCritterFile.setDisable(false);
+				} else if (newT == (Toggle) chkSpecify) {
+					numCritters.setDisable(true);
+					loadCritterFile.setDisable(false);
+				}
+			}
+		});
+
+		// adds a listener to the slider to adjust world speed as the slider is changed
+		simulationSpeed.valueProperty().addListener(new ChangeListener<Number>() {
+			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
+				simulationRate = new_val.longValue();
+			}
+		});
+	}
+
+	private void setupCanvas() {
+		c.addEventFilter(MouseEvent.ANY, (e) -> c.requestFocus());
 
 		c.heightProperty().bind(scroll.heightProperty());
 		c.widthProperty().bind(scroll.widthProperty());
-		
-		simulationSpeed.valueProperty().addListener(new ChangeListener<Number>() {
-            public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
-                        simulationRate = new_val.longValue();
-                }
-            });
+
+		// listeners that dynamically redraw the canvas in response to window resizing
+		c.heightProperty().addListener(update -> {
+			if (map != null)
+				map.draw();
+		});
+		c.widthProperty().addListener(update -> {
+			if (map != null)
+				map.draw();
+		});
+	}
+
+	private void setGUIReady(boolean isReady) {
+		chkRandom.setDisable(!isReady);
+		chkSpecify.setDisable(!isReady);
+		stepForward.setDisable(!isReady);
+		run.setDisable(!isReady);
+		simulationSpeed.setDisable(!isReady);
+		displayProgram.setDisable(!isReady);
+		c.setDisable(!isReady);
+		c.setVisible(isReady);
+	}
+
+	private void resetInfo() {
+		numCritters.clear();
+
+		memSizeText.setText("");
+		speciesText.setText("");
+		defenseText.setText("");
+		offenseText.setText("");
+		sizeText.setText("");
+		energyText.setText("");
+		passText.setText("");
+		tagText.setText("");
+		postureText.setText("");
+		lastRuleDisplay.setText("");
+		lastRuleDisplay.setWrapText(true);
+
+		chkRandom.setSelected(false);
+		chkSpecify.setSelected(false);
 	}
 
 	@FXML
 	private void handleNewWorldPressed(MouseEvent me) {
-		model.createNewWorld();
-		map = new WorldMap(c, model);
-		newWorld.setDisable(true);
-		loadWorld.setDisable(true);
-		chkRand.setDisable(false);
-		chkSpecify.setDisable(false);
-		stepForward.setDisable(false);
-		run.setDisable(false);
-		reset.setDisable(false);
-		simulationSpeed.setDisable(false);
-		c.setDisable(false);
-		c.setVisible(true);
+		doReset();
+		if (localMode) {
+			newWorld();
+		} else {
+			newWorldServer();
+		}
+	}
+
+	private void newWorld() {
+		localCache.createNewWorld();
+		map = new WorldMap(c, localCache);
+		setGUIReady(true);
+		crittersAlive.setText("Critters Alive: " + localCache.getNumCritters());
+		stepsTaken.setText("Time: " + localCache.getCurrentTimeStep());
 
 		map.draw();
 	}
 
+	private void newWorldServer() {
+		if (handler.createNewWorld(sessionID)) {
+			updateView();
+		} else
+			return;
+	}
+
 	@FXML
-	private void handleLoadWorldPressed(MouseEvent me) throws FileNotFoundException, IllegalArgumentException {
+	private void handleLoadWorldPressed(MouseEvent me) {
 		FileChooser fc = new FileChooser();
 		fc.setTitle("Choose World File");
+		if (devMode) {
+			File initDirectory = new File("./src/test/resources/simulationtests/worlds");
+			fc.setInitialDirectory(initDirectory);
+		}
 		File worldFile = fc.showOpenDialog(new Popup());
+		if (worldFile == null) {
+			return;
+		}
+		doReset();
+		if (localMode)
+			loadWorld(worldFile);
+		else
+			loadServerWorld(worldFile);
+	}
+
+	private void loadServerWorld(File worldFile) {
 		try {
-			model.loadWorld(worldFile);
-		} catch (FileNotFoundException f) {
+			handler.loadWorld(worldFile, sessionID);
+			updateView();
+		} catch (FileNotFoundException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		} catch (IllegalArgumentException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		} catch (IOException e) {
 			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
 			a.setTitle("Invalid File");
 			a.showAndWait();
 			return;
 		}
-		map = new WorldMap(c, model);
-
-		newWorld.setDisable(true);
-		loadWorld.setDisable(true);
-		chkRand.setDisable(false);
+		chkRandom.setDisable(false);
 		chkSpecify.setDisable(false);
 		stepForward.setDisable(false);
 		run.setDisable(false);
-		reset.setDisable(false);
 		simulationSpeed.setDisable(false);
 		c.setDisable(false);
 		c.setVisible(true);
-
-		map.draw();
 	}
 
-	@FXML
-	private void handleChkRandom(ActionEvent ae) {
-		numCritters.setDisable(false);
-		loadCritterFile.setDisable(false);
+	private void loadWorld(File worldFile) {
+		try {
+			localCache.loadWorld(worldFile);
+			map = new WorldMap(c, localCache);
+			map.draw();
+		} catch (FileNotFoundException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		} catch (IllegalArgumentException e) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		}
+		chkRandom.setDisable(false);
+		chkSpecify.setDisable(false);
+		stepForward.setDisable(false);
+		run.setDisable(false);
+		simulationSpeed.setDisable(false);
+		c.setDisable(false);
+		c.setVisible(true);
 	}
 
 	@FXML
-	private void handleChkSpecify(ActionEvent ae) {
-		numCritters.setDisable(true);
-		loadCritterFile.setDisable(false);
+	private void handleCheckRandom(MouseEvent me) {
+		numCritters.setText(Integer.toString(1));
 	}
 
 	@FXML
 	private void handleLoadCritters(MouseEvent me) {
 		FileChooser fc = new FileChooser();
 		fc.setTitle("Choose Critter File");
+		if (devMode) {
+			File f = new File("./src/test/resources/simulationtests/critters");
+			fc.setInitialDirectory(f);
+		}
 		File critterFile = fc.showOpenDialog(new Popup());
-		
-		RadioButton choice = (RadioButton) LoadChoice.getSelectedToggle();
-		if(choice == chkRand)
-		{
-			try
-			{
+		if (critterFile == null)
+			return;
+
+		ToggleButton choice = (ToggleButton) LoadChoice.getSelectedToggle();
+		if (choice == chkRandom) {
+			try {
 				int n = Integer.parseInt(numCritters.getText());
-				model.loadRandomCritters(critterFile, n);
-			}
-			catch (NumberFormatException e)
-			{
+				if (localMode)
+					localCache.loadRandomCritters(critterFile, n);
+				else {
+					handler.loadRandomCritters(critterFile, n, sessionID);
+					updateView();
+				}
+
+			} catch (NumberFormatException e) {
 				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid number of critters to load in.");
 				a.setTitle("Invalid Number");
 				a.showAndWait();
 				return;
+			} catch (FileNotFoundException e) {
+				Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+				a.setTitle("Invalid File");
+				a.showAndWait();
+				return;
 			}
-		}
-		else
-		{	
+		} else {
 			TextInputDialog dialog = new TextInputDialog();
 			dialog.setTitle("Choose Hex");
 			dialog.setHeaderText("Enter \"[columns] [rows]\".");
 			Optional<String> result = dialog.showAndWait();
-			
-			try
-			{
-				result.ifPresent(location -> 
-				{
+
+			try {
+				result.ifPresent(location -> {
 					String col = result.get().split(" ")[0];
 					String row = result.get().split(" ")[1];
 					int c = Integer.parseInt(col);
 					int r = Integer.parseInt(row);
-					model.loadCritterAtLocation(critterFile, c, r);
+					System.out.println("c: " + c);
+					System.out.println("r: " + r);
+					if (localMode)
+						localCache.loadCritterAtLocation(critterFile, c, r);
+					else
+						try {
+							handler.loadCritterAtLocation(critterFile, c, r, sessionID);
+							updateView();
+						} catch (FileNotFoundException e) {
+							Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+							a.setTitle("Invalid File");
+							a.showAndWait();
+							return;
+						}
 				});
-			}
-			catch (Exception e)
-			{
+			} catch (Exception e) {
 				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid location");
 				a.setTitle("Invalid Location");
 				a.showAndWait();
 				return;
 			}
 		}
-		
 		map.draw();
 	}
 
 	@FXML
 	private void handleStep(MouseEvent me) {
-		model.advanceTime();
-		map.draw();
-		crittersAlive.setText("Critters Alive: " + model.numCritters);
-		stepsTaken.setText("Time: " + model.time);
+		if (localMode) {
+			localCache.advanceTime();
+			updateInfoBox();
+			map.draw();
+			crittersAlive.setText("Critters Alive: " + localCache.getNumCritters());
+			stepsTaken.setText("Time: " + localCache.getCurrentTimeStep());
+		} else {
+			handler.advanceTime();
+			updateView();
+		}
 	}
 
 	@FXML
 	private void handleRunPressed(MouseEvent me) {
-		if(simulationRate == 0)
-			return;
-		
-		Thread worldUpdateThread = new Thread(new Runnable()
-		{
-			@Override
-			public void run()
-			{
-				model.advanceTime();
-			}
-		});
-		worldUpdateThread.setDaemon(true);
-		
-		executor = Executors.newSingleThreadScheduledExecutor();
-		executor.scheduleAtFixedRate(worldUpdateThread, 0, 1000 / simulationRate, TimeUnit.MILLISECONDS);
-		
-		timeline = new Timeline(new KeyFrame(Duration.millis(1000 / 30), new EventHandler<ActionEvent>() {
-		
-			@Override
-			public void handle(ActionEvent ae)
-			{ 
-				map.draw();
-				crittersAlive.setText("Critters Alive: " + model.numCritters);
-				stepsTaken.setText("Time: " + model.time);
-			}
-		}));
-
-		timeline.setCycleCount(Timeline.INDEFINITE);
-		timeline.play();
-
-		newWorld.setDisable(true);
-		loadWorld.setDisable(true);
-		loadCritterFile.setDisable(true);
-		chkRand.setDisable(true);
-		chkSpecify.setDisable(true);
-		numCritters.setDisable(true);
-		stepForward.setDisable(true);
-		run.setDisable(true);
-		reset.setDisable(true);
-		simulationSpeed.setDisable(true);
+		if (localMode) {
+			if (simulationRate == 0)
+				return;
+			Thread worldUpdateThread = new Thread(new Runnable() {
+				@Override
+				public void run() {
+					localCache.advanceTime();
+				}
+			});
+			worldUpdateThread.setDaemon(false);
+			executor = Executors.newSingleThreadScheduledExecutor();
+			executor.scheduleAtFixedRate(worldUpdateThread, 0, 1000 / simulationRate, TimeUnit.MILLISECONDS);
+			timeline = new Timeline(new KeyFrame(Duration.millis(1000 / 30), new EventHandler<ActionEvent>() {
 
-		pause.setDisable(false);
+				@Override
+				public void handle(ActionEvent ae) {
+					updateInfoBox();
+					map.draw();
+					updateInfoBox();
+					crittersAlive.setText("Critters Alive: " + localCache.getNumCritters());
+					stepsTaken.setText("Time: " + localCache.getCurrentTimeStep());
+				}
+			}));
+			timeline.setCycleCount(Timeline.INDEFINITE);
+			timeline.play();
+			newWorld.setDisable(true);
+			loadWorld.setDisable(true);
+			loadCritterFile.setDisable(true);
+			chkRandom.setDisable(true);
+			chkSpecify.setDisable(true);
+			numCritters.setDisable(true);
+			stepForward.setDisable(true);
+			run.setDisable(true);
+			simulationSpeed.setDisable(true);
+			pause.setDisable(false);
+		}
 	}
 
 	@FXML
 	private void handlePauseClicked(MouseEvent me) {
-		executor.shutdownNow();
+		if(!localMode) {
+			executor.shutdownNow();
 
-		newWorld.setDisable(false);
-		loadWorld.setDisable(false);
-		loadCritterFile.setDisable(false);
-		chkRand.setDisable(false);
-		chkSpecify.setDisable(false);
-		numCritters.setDisable(false);
-		stepForward.setDisable(false);
-		run.setDisable(false);
-		reset.setDisable(false);
-		simulationSpeed.setDisable(false);
+			newWorld.setDisable(false);
+			loadWorld.setDisable(false);
+			loadCritterFile.setDisable(false);
+			chkRandom.setDisable(false);
+			chkSpecify.setDisable(false);
+			stepForward.setDisable(false);
+			run.setDisable(false);
+			simulationSpeed.setDisable(false);
 
-		timeline.stop();
-		pause.setDisable(true);
+			timeline.stop();
+			pause.setDisable(true);
+		}
 	}
 
 	@FXML
 	private void handleMapClicked(MouseEvent me) {
-		if (!me.isPrimaryButtonDown()) {
-			mousePanPressedX = me.getScreenX();
-			mousePanPressedY = me.getScreenY();
-		}
-		else
-		{
+		if (me.getButton() == MouseButton.PRIMARY && !isCurrentlyDragging) {
 			double xCoordinateSelected = me.getSceneX();
-			double yCoordinateSelected = me.getSceneY();
-			int[] hexCoordinatesSelected = new int[2];
-			boolean shouldUpdateRowColumn = map.select(xCoordinateSelected, yCoordinateSelected);
-			hexCoordinatesSelected = map.getSelectedHex();
-			if(shouldUpdateRowColumn)
-			{
-				rowText.setText(String.valueOf(hexCoordinatesSelected[0]));
-				columnText.setText(String.valueOf(hexCoordinatesSelected[1]));
-				if (model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]) != null)
-				{
-					SimpleCritter critter = model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]);
-					memSizeText.setText(String.valueOf(critter.getMemLength()));
-					speciesText.setText(critter.getName());
-					int[] critterMemoryCopy = new int[critter.getMemLength()];
-					critterMemoryCopy = critter.getMemoryCopy();
-					defenseText.setText(String.valueOf(critterMemoryCopy[1]));
-					offenseText.setText(String.valueOf(critterMemoryCopy[2]));
-					sizeText.setText(String.valueOf(critterMemoryCopy[3]));
-					energyText.setText(String.valueOf(critterMemoryCopy[4]));
-					passText.setText(String.valueOf(critterMemoryCopy[5]));
-					tagText.setText(String.valueOf(critterMemoryCopy[6]));
-					postureText.setText(String.valueOf(critterMemoryCopy[7]));
-					lastRuleDisplay.setText(critter.getLastRule());
-				}
-				else
-				{
-					memSizeText.setText("");
-					speciesText.setText("");
-					defenseText.setText("");
-					offenseText.setText("");
-					sizeText.setText("");
-					energyText.setText("");
-					passText.setText("");
-					tagText.setText("");
-					postureText.setText("");
-				}
-			}
+			double yCoordinateSelected = me.getSceneY() - 25;
+			map.select(xCoordinateSelected, yCoordinateSelected);
+			updateInfoBox();
 		}
+		isCurrentlyDragging = false;
 	}
 
-	@FXML
-	private void handleResetClicked(MouseEvent me) {
-		if (executor != null)
-			executor.shutdownNow();
-		if (timeline != null)
-			timeline.stop();
-		initialize();
+	/** Updates the contents of the critter information box. */
+	private void updateInfoBox() {
+		if (map.getSelectedHex() != null) {
+			int[] hexCoordinatesSelected = map.getSelectedHex();
+			columnText.setText(String.valueOf(hexCoordinatesSelected[0]));
+			rowText.setText(String.valueOf(hexCoordinatesSelected[1]));
+			if (localCache.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]) != null) {
+				SimpleCritter critter = localCache.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]);
+				memSizeText.setText(String.valueOf(critter.getMemLength()));
+				speciesText.setText(critter.getName());
+				int[] critterMemoryCopy = new int[critter.getMemLength()];
+				critterMemoryCopy = critter.getMemoryCopy();
+				defenseText.setText(String.valueOf(critterMemoryCopy[1]));
+				offenseText.setText(String.valueOf(critterMemoryCopy[2]));
+				sizeText.setText(String.valueOf(critterMemoryCopy[3]));
+				energyText.setText(String.valueOf(critterMemoryCopy[4]));
+				passText.setText(String.valueOf(critterMemoryCopy[5]));
+				tagText.setText(String.valueOf(critterMemoryCopy[6]));
+				postureText.setText(String.valueOf(critterMemoryCopy[7]));
+				lastRuleDisplay.setText("Last rule: " + "\n" + critter.getLastRuleString());
+			} else {
+				memSizeText.setText("");
+				speciesText.setText("");
+				defenseText.setText("");
+				offenseText.setText("");
+				sizeText.setText("");
+				energyText.setText("");
+				passText.setText("");
+				tagText.setText("");
+				postureText.setText("");
+			}
+		} else {
+			columnText.setText("");
+			rowText.setText("");
+		}
 	}
 
 	@FXML
 	private void handleMapScroll(ScrollEvent se) {
-		if (se.getDeltaY() > 0)
+		if (se.getDeltaY() > 0) {
 			map.zoom(true);
-		else
+		} else {
 			map.zoom(false);
+		}
 	}
 
 	@FXML
 	private void handleMapDrag(MouseEvent me) {
-		if (!me.isPrimaryButtonDown()) {
-			map.drag(me.getScreenX() - mousePanPressedX, me.getScreenY() - mousePanPressedY);
+		if (me.isPrimaryButtonDown()) {
+			if (!isCurrentlyDragging) {
+				// sets initial coordinates for the drag
+				panMarkerX = me.getSceneX();
+				panMarkerY = me.getSceneY();
+			}
+			isCurrentlyDragging = true;
+
+			map.drag((me.getSceneX() - panMarkerX) / 0.05, (me.getSceneY() - panMarkerY) / 0.05);
+
+			panMarkerX = me.getSceneX();
+			panMarkerY = me.getSceneY();
+		}
+	}
+
+	@FXML
+	private void handleKeyEvents(KeyEvent ke) {
+		if (ke.getCode().equals(KeyCode.UP)) {
+			map.drag(0, 400);
+		}
+		if (ke.getCode().equals(KeyCode.LEFT)) {
+			map.drag(400, 0);
+		}
+		if (ke.getCode().equals(KeyCode.DOWN)) {
+			map.drag(0, -400);
+		}
+		if (ke.getCode().equals(KeyCode.RIGHT)) {
+			map.drag(-400, 0);
+		}
+		if (ke.getCode().equals(KeyCode.EQUALS)) {
+			map.zoom(true);
+		} else if (ke.getCode().equals(KeyCode.MINUS)) {
+			map.zoom(false);
+		}
+	}
+
+	@FXML
+	private void help(ActionEvent ae) {
+		String fileName = "instructions.txt";
+		ImageView imgview = new ImageView(GUI.icon);
+		Alert alert = new Alert(AlertType.INFORMATION);
+		alert.setGraphic(imgview);
+		try {
+			String helpText = new String(Files.readAllBytes(Paths.get(fileName)));
+			alert.setContentText(helpText);
+			alert.setHeaderText("How to Use CRITTERWORLD");
+			alert.showAndWait();
+		} catch (IOException e) {
+			String errorText = "Please refer to user manual for instructions on how to use product.";
+			alert.setContentText(errorText);
+			alert.setHeaderText(null);
+			alert.showAndWait();
 		}
 	}
 
@@ -417,18 +667,148 @@ public class Controller {
 			timeline.stop();
 		System.exit(0);
 	}
-	
+
 	@FXML
 	private void handleDisplayProgram(MouseEvent me) {
 		int[] hexCoordinates = new int[2];
 		hexCoordinates = map.getSelectedHex();
-		if (model.getCritter(hexCoordinates[0], hexCoordinates[1]) != null) {
-			SimpleCritter critter = model.getCritter(hexCoordinates[0], hexCoordinates[1]);
+		if (hexCoordinates == null) {
+			return;
+		}
+		if (localCache.getCritter(hexCoordinates[0], hexCoordinates[1]) != null) {
+			SimpleCritter critter = localCache.getCritter(hexCoordinates[0], hexCoordinates[1]);
 			Program critterProgram = critter.getProgram();
 			String critterProgramString = critterProgram.toString();
+			
 			Alert alert = new Alert(AlertType.INFORMATION, critterProgramString);
+			ImageView imgview = new ImageView(GUI.icon);
+			alert.setGraphic(imgview);
 			alert.setHeaderText("Critter Program");
 			alert.showAndWait();
 		}
 	}
+
+	/** Logs into the server. */
+	private void login() {
+		Gson gson = new Gson();
+		Dialog<LoginInfo> dialog = new Dialog<>();
+		dialog.setTitle("Login Info");
+		dialog.setHeaderText("Please Enter In The Passwords You Have Access To");
+		DialogPane dialogPane = dialog.getDialogPane();
+		dialogPane.getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);
+		TextField levelTextField = new TextField("Level");
+		TextField passwordTextField = new TextField("Password");
+		// TextField urlTextField = new TextField("http://localhost:8080");
+		TextField urlTextField = new TextField("http://hexworld.herokuapp.com:80/hexworld");
+		dialogPane.setContent(new VBox(8, levelTextField, passwordTextField, urlTextField));
+		Platform.runLater(levelTextField::requestFocus);
+		dialog.setResultConverter((ButtonType button) -> {
+			if (button == ButtonType.OK) {
+				return new LoginInfo(levelTextField.getText(), passwordTextField.getText(), urlTextField.getText());
+			}
+			return null;
+		});
+		Optional<LoginInfo> optionalResult = dialog.showAndWait();
+		optionalResult.ifPresent((LoginInfo results) -> {
+			loginInfo = new LoginInfo(results.level, results.password);
+			this.urlInitial = results.url;
+		});
+		URL url = null;
+		try {
+			url = new URL(this.urlInitial + "/login");
+			// url = new URL("http://hexworld.herokuapp.com:80/hexworld/login");
+			System.out.println(gson.toJson(loginInfo, LoginInfo.class));
+			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+			System.out.println(url.toString());
+			connection.setDoOutput(true); // send a POST message
+			connection.setRequestMethod("POST");
+			PrintWriter w = new PrintWriter(connection.getOutputStream());
+			w.println(gson.toJson(loginInfo, LoginInfo.class));
+			w.flush();
+			if (connection.getResponseCode() == 401) {
+
+				Alert alert = new Alert(AlertType.CONFIRMATION);
+				alert.setTitle("Login Error");
+				alert.setHeaderText("Credentials Not Recognized");
+				alert.setContentText("The login credentials you entered were invalid. Click "
+						+ "OK to continue in local mode or Cancel to exit the program.");
+				Optional<ButtonType> result = alert.showAndWait();
+
+				if (result.get() == ButtonType.OK) {
+					localMode = true;
+					localCache = new WorldModel();
+					return;
+				} else {
+					System.exit(0);
+				}
+			}
+
+			BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+			String sessionIdString = "";
+			String holder = r.readLine();
+			while (holder != null) {
+				sessionIdString += holder;
+				holder = r.readLine();
+			}
+			SessionID sessionId = gson.fromJson(sessionIdString, SessionID.class);
+			System.out.println(sessionId.getSessionID());
+
+		} catch (MalformedURLException e) {
+			System.out.println("The URL entered was not correct.");
+			localMode = true;
+			Alert alert = new Alert(AlertType.CONFIRMATION);
+			alert.setTitle("Login Error");
+			alert.setHeaderText("Credentials Not Recognized");
+			alert.setContentText("The login credentials you entered were invalid. Click "
+					+ "OK to continue in local mode or Cancel to exit the program.");
+			Optional<ButtonType> result = alert.showAndWait();
+
+			if (result.get() == ButtonType.OK) {
+				localMode = true;
+				localCache = new WorldModel();
+				return;
+			} else {
+				System.exit(0);
+			}
+			return;
+		} catch (IOException e) {
+			System.out.println("Could not connect to the server");
+			localMode = true;
+			Alert alert = new Alert(AlertType.CONFIRMATION);
+			alert.setTitle("Login Error");
+			alert.setHeaderText("Credentials Not Recognized");
+			alert.setContentText("The login credentials you entered were invalid. Click "
+					+ "OK to continue in local mode or Cancel to exit the program.");
+			Optional<ButtonType> result = alert.showAndWait();
+
+			if (result.get() == ButtonType.OK) {
+				localMode = true;
+				localCache = new WorldModel();
+				return;
+			} else {
+				System.exit(0);
+			}
+			return;
+		}
+		localMode = false;
+		handler = new ClientRequestHandler(this.urlInitial);
+	}
+
+	public class LoginInfo {
+
+		String level;
+		String password;
+		String url;
+
+		private LoginInfo(String level, String password) {
+			this.level = level;
+			this.password = password;
+		}
+
+		private LoginInfo(String level, String password, String url) {
+			this.level = level;
+			this.password = password;
+			this.url = url;
+		}
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/gui/GUI.java b/src/main/java/gui/GUI.java
new file mode 100644
index 0000000..d083b9f
--- /dev/null
+++ b/src/main/java/gui/GUI.java
@@ -0,0 +1,38 @@
+package gui;
+
+import java.net.URL;
+
+import javafx.application.Application;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.image.Image;
+import javafx.stage.Stage;
+
+public class GUI extends Application {
+	public static final Image icon = new Image(
+			GUI.class.getClassLoader().getResourceAsStream("gui/critterworld_favicon.png"));
+
+	public static void main(String[] args) {
+		launch(args);
+	}
+
+	@Override
+	public void start(Stage stage) {
+		stage.setMinHeight(900);
+		stage.setMinWidth(1600);
+
+		try {
+			URL r = getClass().getResource("gui.fxml");
+			if (r == null)
+				throw new Exception("No FXML resource found.");
+			Scene scene = new Scene(FXMLLoader.load(r));
+			stage.setTitle("CRITTERWORLD");
+			stage.getIcons().add(icon);
+			stage.setScene(scene);
+			stage.sizeToScene();
+			stage.show();
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/Main.java b/src/main/java/gui/Main.java
deleted file mode 100644
index fd11749..0000000
--- a/src/main/java/gui/Main.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package gui;
-
-import java.net.URL;
-
-import javafx.application.Application;
-import javafx.fxml.FXMLLoader;
-import javafx.scene.Scene;
-import javafx.stage.Stage;
-
-public class Main extends Application {
-
-	public static void main(String[] args) {
-		launch(args);
-	}
-
-	@Override
-	public void start(Stage stage) {
-		stage.setMinHeight(800);
-		stage.setMinWidth(1000);
-
-		try {
-			URL r = getClass().getResource("gui.fxml");
-			if (r == null)
-				throw new Exception("No FXML resource found.");
-			Scene scene = new Scene(FXMLLoader.load(r));
-			stage.setTitle("CRITTERWORLD!");
-			stage.setScene(scene);
-			stage.sizeToScene();
-			stage.show();
-		} catch (Exception e) {
-			
-		}
-	}
-
-}
-
-// TODO fix zooming + panning position
-// TODO fix hex selection upon zoom
-// TODO fix weird lagginess in panning
-// TODO black universe, grey hex grid, grey fully filled hexes as rocks, neon
-// circles for food (maybe yellow), neon isosceles triangles for critters (maybe
-// green + species variation so different shades)
-// TODO tableview for hexinfo
-// TODO when unselecting a hex, kill the critter info in corner
-// TODO figure out what to do when selecting a rock or food
-// TODO change title of critter program message box
\ No newline at end of file
diff --git a/src/main/java/gui/ResizableCanvas.java b/src/main/java/gui/ResizableCanvas.java
deleted file mode 100644
index 4a29646..0000000
--- a/src/main/java/gui/ResizableCanvas.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package gui;
-
-import javafx.scene.canvas.Canvas;
-
-public class ResizableCanvas extends Canvas
-{
-	@Override
-	public boolean isResizable()
-	{
-		return true;
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/gui/WorldMap.java b/src/main/java/gui/WorldMap.java
index f575037..7de5068 100644
--- a/src/main/java/gui/WorldMap.java
+++ b/src/main/java/gui/WorldMap.java
@@ -3,9 +3,9 @@ package gui;
 import java.util.Arrays;
 import java.util.Map;
 
+import distributed.ClientRequestHandler;
 import javafx.scene.canvas.Canvas;
 import javafx.scene.canvas.GraphicsContext;
-import javafx.scene.image.Image;
 import javafx.scene.paint.Color;
 import javafx.scene.text.Font;
 import javafx.scene.text.TextAlignment;
@@ -15,6 +15,7 @@ import simulation.Rock;
 import simulation.SimpleCritter;
 import simulation.WorldObject;
 
+/** A class that draws the hex grid for the user interface. */
 public class WorldMap {
 	private WorldModel model;
 	private GraphicsContext gc;
@@ -66,6 +67,10 @@ public class WorldMap {
 	 * Marks the rectangular y coordinate of the origin (the (0, 0) hex coordinate).
 	 */
 	private double origin_y;
+	/** Holds the last drawn time step. */
+	// private int currentTimeStep;
+	// private boolean localMode;
+	// private ClientRequestHandler handler;
 
 	/**
 	 * Creates a new world map.
@@ -76,6 +81,7 @@ public class WorldMap {
 	 *            The WorldModel to work off of
 	 */
 	public WorldMap(Canvas can, WorldModel wm) {
+		// localMode = true;
 		gc = can.getGraphicsContext2D();
 		canvas = can;
 		model = wm;
@@ -95,7 +101,6 @@ public class WorldMap {
 		y_position_marker = (((double) height / 2)
 				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
 				+ (Math.sqrt(3) * (sideLength / 2));
-
 	}
 
 	/**
@@ -121,7 +126,8 @@ public class WorldMap {
 		gc.setFill(BACKGROUND_COLOR);
 		gc.fillRect(0, 0, width, height);
 
-		// draws the hexagons and sets the origin
+		// draws grid and sets the origin
+		gc.setLineWidth(1);
 		double hexMarkerX = x_position_marker;
 		double hexMarkerY = y_position_marker;
 		for (int i = 0; i < column_drawing_marker; i++) {
@@ -149,9 +155,10 @@ public class WorldMap {
 		origin_y = hexMarkerY + (sideLength * (Math.sqrt(3)) * row_drawing_marker) - (Math.sqrt(3) * (sideLength / 2));
 		if (column_drawing_marker % 2 == 0)
 			origin_y += (sideLength / 2) * (Math.sqrt(3));
-		origin_y -= sideLength / 2 * Math.sqrt(3); // manual override of sujith's calculations
-
-		// draws the world objects in
+		origin_y -= sideLength / 2 * Math.sqrt(3);
+		
+		// draws world objects
+		gc.setLineWidth(3);
 		drawObjects();
 
 		if (selectedHex != null) {
@@ -160,11 +167,6 @@ public class WorldMap {
 		}
 	}
 
-	/** Used to update the grid and draw updates after each time step. */
-	public void updateGrid() {
-
-	}
-
 	/** Draws the world objects onto the grid. */
 	private void drawObjects() {
 		for (Map.Entry<SimpleCritter, Hex> entry : model.getCritterMap()) {
@@ -269,15 +271,44 @@ public class WorldMap {
 			yPoints[i] += cartY;
 		}
 
-		// get critter color
+		// set critter color
 		String species = sc.getName();
-		int hash = species.hashCode();
-		Color color = new Color(0, 1, (Math.abs(hash) % 10) / 10.0, 1);
-		System.out.println(hash);
+		int randomizer = (int) (Math.sqrt(Math.abs(species.hashCode())) * 100);
+		int blendType = randomizer % 3;
+		double blendLevel = (randomizer % 100) / 100.0;
+		double red;
+		double green;
+		double blue;
+		switch (blendType) {
+		case 0:
+			red = 0;
+			green = blendLevel;
+			blue = 1 - blendLevel;
+			break;
+		case 1:
+			red = 1 - blendLevel;
+			green = 0;
+			blue = blendLevel;
+			break;
+		case 2:
+			red = blendLevel;
+			green = 1 - blendLevel;
+			blue = 0;
+			break;
+		default:
+			red = 0;
+			green = 0;
+			blue = 0;
+		}
+		Color color = new Color(red, green, blue, 1);
 
-		// draw critter
-		gc.setStroke(Color.LIME);
+		// draw critter (outlines only)
+		gc.setStroke(color);
 		gc.strokePolygon(xPoints, yPoints, 3);
+
+		// draw critter (filled in)
+		// gc.setFill(color);
+		// gc.fillPolygon(xPoints, yPoints, 3);
 	}
 
 	/**
@@ -297,25 +328,26 @@ public class WorldMap {
 
 		if (wo instanceof Rock) {
 			double size = 0.9 * sideLength;
-			gc.setFill(Color.BROWN);
+			gc.setStroke(Color.BROWN);// GOLDENROD
 			gc.strokeRect(cartX - size / 2, cartY - size / 2, size, size);
 		}
 
 		else if (wo instanceof Food) {
 			int calories = ((Food) wo).getCalories();
 			double size = 0.9 * sideLength;
-			gc.setStroke(Color.RED);
+			gc.setStroke(Color.WHITE);// RED
 			gc.strokeOval(cartX - size / 2, cartY - size / 2, size, size);
 			gc.setTextAlign(TextAlignment.CENTER);
-			gc.setFont(new Font(8));
+			gc.setFont(new Font(8 * sideLength / 30));
+			gc.setLineWidth(1);
 			gc.strokeText(String.valueOf(calories), cartX, cartY);
+			gc.setLineWidth(3);
 		}
 	}
 
 	/**
-	 * 
-	 * @param centerX
-	 * @param centerY
+	 * Draws a hexagon centered at the rectangular coordinates specified by
+	 * {@code centerX} and {@code centerY}.
 	 */
 	private void drawHex(double centerX, double centerY) {
 		gc.setStroke(HEX_COLOR);
@@ -333,27 +365,32 @@ public class WorldMap {
 	 * @param zoomIn
 	 */
 	public void zoom(boolean zoomIn) {
+		double oldSideLength = sideLength;
 		if (zoomIn) {
 			sideLength += ZOOM_FACTOR;
 			if (sideLength >= MAX_SIDELENGTH)
 				sideLength = MAX_SIDELENGTH;
+
 		} else {
 			sideLength -= ZOOM_FACTOR;
 			if (sideLength <= MIN_SIDELENGTH)
 				sideLength = MIN_SIDELENGTH;
 		}
-		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
-				+ (sideLength / 2);
-		y_position_marker = (((double) height / 2)
-				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
-				+ (Math.sqrt(3) * (sideLength / 2));
+		double factor = sideLength / (oldSideLength);
+
+		x_position_marker = width / 2 - (width / 2 - x_position_marker) * factor;
+		y_position_marker = height / 2 - (height / 2 - y_position_marker) * factor;
+
 		draw();
 	}
 
 	/**
-	 * highlightHex highlights the hex that is currently selected 
-	 * @param x xCoordinate of the spot that the user clicks
-	 * @param y yCooridnate of the spot that the user clicks
+	 * highlightHex highlights the hex that is currently selected
+	 * 
+	 * @param x
+	 *            x-coordinate of the spot that the user clicks
+	 * @param y
+	 *            y-coordinate of the spot that the user clicks
 	 */
 	public void highlightHex(double x, double y) {
 		int[] hexCoordinates = closestHex(x, y);
@@ -372,12 +409,14 @@ public class WorldMap {
 
 	/**
 	 * drag implements panning
-	 * @param deltaX 
+	 * 
+	 * @param deltaX
 	 * @param deltaY
 	 */
 	public void drag(double deltaX, double deltaY) {
 		x_position_marker += deltaX * 0.05;
 		y_position_marker += deltaY * 0.05;
+
 		if (x_position_marker - sideLength > width)
 			x_position_marker = width - sideLength;
 		if ((((3 * sideLength) / 2) * column_drawing_marker + x_position_marker) < 0) {
@@ -387,6 +426,7 @@ public class WorldMap {
 			y_position_marker = height - Math.sqrt(3) * sideLength;
 		if ((y_position_marker + Math.sqrt(3) * sideLength * row_drawing_marker) < 0)
 			y_position_marker = Math.sqrt(3) * sideLength - Math.sqrt(3) * sideLength * row_drawing_marker;
+
 		gc.clearRect(0, 0, width, height);
 		draw();
 	}
@@ -403,7 +443,6 @@ public class WorldMap {
 		}
 		double[] highlightCoordinates = hexToCartesian(closestHexCoordinates);
 		highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
-
 		draw();
 		return returnValue;
 	}
@@ -420,10 +459,10 @@ public class WorldMap {
 	public int[] closestHex(double xCoordinate, double yCoordinate) {
 		// determines the possible hexes that the point could be in
 		int possibleColumnOne = (int) Math.ceil(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
-		int possibleColumnTwo = (int) Math.floor(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
+		int possibleColumnTwo = (int) (2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
 		int possibleRowOne = (int) Math.ceil((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
 				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
-		int possibleRowTwo = (int) Math.floor((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
+		int possibleRowTwo = (int) ((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
 				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
 
 		int[][] possibleCoordinates = new int[4][2];
@@ -435,7 +474,6 @@ public class WorldMap {
 		double distanceSquared = Integer.MAX_VALUE;
 		int returnIndex = 0;
 		for (int i = 0; i < 4; i++) {
-			//System.out.println("Option #" + i + ": " + possibleCoordinates[i][0] + " " + possibleCoordinates[i][1]);
 			double tempArray[] = hexToCartesian(possibleCoordinates[i]);
 			double tempDistanceSquared = Math.pow(xCoordinate - tempArray[0], 2)
 					+ Math.pow(yCoordinate - tempArray[1], 2);
@@ -444,13 +482,12 @@ public class WorldMap {
 				returnIndex = i;
 			}
 		}
-		//System.out.println(possibleCoordinates[returnIndex][0] + " " + possibleCoordinates[returnIndex][1]);
-		//System.out.println("\n");
 		return possibleCoordinates[returnIndex];
 	}
 
 	/**
-	 * A method that converts a hex coordinate pair and gives the hex coordinates of
+	 * A method that converts a hex coordinate pair converts it to cartesian
+	 * coordinates.
 	 * 
 	 * @param hexCoordinates
 	 * @return
diff --git a/src/main/java/gui/WorldModel.java b/src/main/java/gui/WorldModel.java
index ce05af3..330ba4d 100644
--- a/src/main/java/gui/WorldModel.java
+++ b/src/main/java/gui/WorldModel.java
@@ -5,16 +5,26 @@ import java.io.FileNotFoundException;
 import java.util.Map;
 import java.util.Set;
 
+import distributed.WorldStateJSON;
+import simulation.Hex;
 import simulation.SimpleCritter;
 import simulation.SimpleWorld;
 import simulation.World;
 import simulation.WorldObject;
-import simulation.Hex;
 
+/**
+ * The model that stores world and critter states. It also serves as an
+ * abstraction barrier between the world and the modules that interact with the
+ * world.
+ */
 public class WorldModel {
+
+	/** An instance of the world. */
 	private SimpleWorld world;
-	int numCritters;
-	int time;
+	/** The number of critters. */
+	private int numCritters;
+	/** The number of time steps taken. */
+	private int time;
 
 	/** Creates a new blank world model. */
 	public WorldModel() {
@@ -22,9 +32,31 @@ public class WorldModel {
 		time = 0;
 	}
 
-	/** Creates a new random world. */
-	public void createNewWorld() {
+	/**
+	 * Creates a new random world.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             if the constants.txt file could not be read
+	 */
+	public void createNewWorld() throws UnsupportedOperationException {
 		world = new World();
+		time = 0;
+		numCritters = world.numRemainingCritters();
+	}
+
+	/**
+	 * Loads in a world based on a description.
+	 * 
+	 * @param desc
+	 * @throws IllegalArgumentException
+	 *             if the description is invalid
+	 * @throws UnsupportedOperationException
+	 *             if the constants.txt file could not be read
+	 */
+	public void loadWorld(WorldStateJSON w) throws IllegalArgumentException, UnsupportedOperationException {
+		world = new World(w);
+		time = world.getTimePassed();
+		numCritters = world.numRemainingCritters();
 	}
 
 	/**
@@ -33,11 +65,13 @@ public class WorldModel {
 	 * @param worldfile
 	 * @throws FileNotFoundException
 	 *             if the file could not be found or is somehow invalid
-	 * @throws IllegalArgumentException
+	 * @throws UnsupportedOperationException
 	 *             if the constants.txt file could not be read
 	 */
-	public void loadWorld(File worldfile) throws FileNotFoundException, IllegalArgumentException {
+	public void loadWorld(File worldfile) throws FileNotFoundException, UnsupportedOperationException {
 		world = new World(worldfile);
+		time = 0;
+		numCritters = world.numRemainingCritters();
 	}
 
 	public boolean isReady() {
@@ -54,18 +88,48 @@ public class WorldModel {
 		return world.getRows();
 	}
 
-	public synchronized int hexContent(int c, int r) {
+	/** Returns the number of living critters in the world. */
+	public int getNumCritters() {
+		return numCritters;
+	}
+
+	/** Returns the current time step of the world. */
+	public int getCurrentTimeStep() {
+		return time;
+	}
+
+	/**
+	 * Returns a number giving information about a hex.
+	 * 
+	 * @param c
+	 * @param r
+	 * @return
+	 */
+	public int hexInfo(int c, int r) {
 		return world.analyzeHex(c, r);
 	}
 
-	public synchronized SimpleCritter getCritter(int c, int r) {
+	/**
+	 * Returns a pointer to a critter.
+	 * @param c The column index of the critter
+	 * @param r The row index of the critter
+	 */
+	public SimpleCritter getCritter(int c, int r) {
 		return world.analyzeCritter(c, r);
 	}
 
-	public synchronized Set<Map.Entry<SimpleCritter, Hex>> getCritterMap() {
+	/**
+	 * 
+	 * @return
+	 */
+	public Set<Map.Entry<SimpleCritter, Hex>> getCritterMap() {
 		return world.getCritterMap();
 	}
 
+	/**
+	 * 
+	 * @return
+	 */
 	public synchronized Set<Map.Entry<WorldObject, Hex>> getObjectMap() {
 		return world.getObjectMap();
 	}
@@ -75,14 +139,19 @@ public class WorldModel {
 		world.advanceOneTimeStep();
 		time++;
 		numCritters = world.numRemainingCritters();
-		//System.out.println(world.printGrid());
 	}
 
+	/**
+	 * Loads critters at random locations.
+	 * 
+	 * @param f The file specifying the critter to load
+	 * @param n The number of critters to load
+	 */
 	public synchronized void loadRandomCritters(File f, int n) {
 		world.loadCritters(f, n, -1);
 		numCritters = world.numRemainingCritters();
 	}
-	
+
 	public synchronized void loadCritterAtLocation(File f, int c, int r) {
 		world.loadCritterAtLocation(f, c, r);
 		numCritters = world.numRemainingCritters();
diff --git a/src/main/java/gui/gui.fxml b/src/main/java/gui/gui.fxml
index 9937ccf..8bec71d 100644
--- a/src/main/java/gui/gui.fxml
+++ b/src/main/java/gui/gui.fxml
@@ -6,13 +6,12 @@
 <?import javafx.scene.control.Menu?>
 <?import javafx.scene.control.MenuBar?>
 <?import javafx.scene.control.MenuItem?>
-<?import javafx.scene.control.RadioButton?>
 <?import javafx.scene.control.ScrollPane?>
 <?import javafx.scene.control.Slider?>
 <?import javafx.scene.control.SplitPane?>
-<?import javafx.scene.control.TextArea?>
 <?import javafx.scene.control.TextField?>
 <?import javafx.scene.control.TitledPane?>
+<?import javafx.scene.control.ToggleButton?>
 <?import javafx.scene.control.ToggleGroup?>
 <?import javafx.scene.layout.AnchorPane?>
 <?import javafx.scene.layout.HBox?>
@@ -20,124 +19,123 @@
 <?import javafx.scene.text.Text?>
 
 <AnchorPane prefHeight="900.0" prefWidth="1600.0" xmlns="http://javafx.com/javafx/9.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="gui.Controller">
-   <children>
-      <MenuBar fx:id="Menu" prefHeight="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
-         <menus>
-            <Menu mnemonicParsing="false" text="File">
-               <items>
-                  <MenuItem fx:id="help" mnemonicParsing="false" text="Help" />
-                  <MenuItem fx:id="close" mnemonicParsing="false" onAction="#close" text="Close" />
-               </items>
-            </Menu>
-         </menus>
-      </MenuBar>
-      <HBox alignment="BOTTOM_LEFT" layoutY="774.0" prefHeight="25.0" AnchorPane.bottomAnchor="2.1316282072803006E-14" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0">
-         <children>
-            <SplitPane dividerPositions="0.5" prefHeight="26.0" style="-fx-background-color: lightgray;" HBox.hgrow="ALWAYS">
-              <items>
-                  <HBox alignment="CENTER" prefHeight="25.0" prefWidth="200.0">
-                     <children>
-                        <Label fx:id="crittersAlive" alignment="CENTER" text="Critters Alive: 0" />
-                     </children>
-                  </HBox>
-                  <HBox alignment="CENTER" prefHeight="100.0" prefWidth="200.0">
-                     <children>
-                        <Label fx:id="stepsTaken" text="Time: 0" />
-                     </children>
-                  </HBox>
-              </items>
-            </SplitPane>
-         </children></HBox>
-      <AnchorPane layoutX="749.0" layoutY="25.0" prefHeight="775.0" prefWidth="250.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="25.0">
-         <children>
-            <TitledPane animated="false" layoutY="-3.0" minHeight="274.0" prefHeight="274.0" prefWidth="250.0" text="World Info" AnchorPane.bottomAnchor="510.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
-               <content>
-                  <ScrollPane fitToWidth="true" hbarPolicy="NEVER" prefWidth="248.0">
-                    <content>
-                      <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="333.0" prefWidth="248.0">
-                           <children>
-                              <Label layoutX="10.0" layoutY="16.0" prefHeight="10.0" text="Column" />
-                              <Label layoutX="110.0" layoutY="16.0" prefHeight="10.0" prefWidth="39.0" text="Row" />
-                              <Label layoutX="10.0" layoutY="37.0" prefHeight="21.0" prefWidth="69.0" text="Mem Size" />
-                              <Label layoutX="10.0" layoutY="59.0" prefHeight="10.0" prefWidth="60.0" text="Defense" />
-                              <Label layoutX="110.0" layoutY="59.0" prefHeight="10.0" prefWidth="57.0" text="Offense" />
-                              <Label layoutX="10.0" layoutY="80.0" prefHeight="10.0" prefWidth="55.0" text="Energy" />
-                              <Label layoutX="110.0" layoutY="80.0" prefHeight="10.0" prefWidth="35.0" text="Pass" />
-                              <Label layoutX="10.0" layoutY="99.0" prefHeight="10.0" prefWidth="35.0" text="Tag" />
-                              <Label layoutX="110.0" layoutY="99.0" prefHeight="10.0" prefWidth="54.0" text="Posture" />
-                              <Label layoutX="110.0" layoutY="37.0" text="Species" />
-                              <TextArea fx:id="lastRuleDisplay" layoutX="41.0" layoutY="120.0" prefHeight="150.0" prefWidth="167.0" />
-                              <Button fx:id="displayProgram" layoutX="60.0" layoutY="277.0" mnemonicParsing="false" onMouseClicked="#handleDisplayProgram" text="Display Program" />
-                              <Text fx:id="columnText" layoutX="70.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
-                              <Text fx:id="rowText" layoutX="147.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="27.0" />
-                              <Text fx:id="memSizeText" layoutX="81.0" layoutY="53.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="28.0" />
-                              <Text fx:id="speciesText" layoutX="170.0" layoutY="52.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="76.0" />
-                              <Text fx:id="defenseText" layoutX="70.0" layoutY="75.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
-                              <Text fx:id="offenseText" layoutX="179.0" layoutY="74.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
-                              <Text fx:id="energyText" layoutX="65.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
-                              <Text fx:id="passText" layoutX="146.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
-                              <Text fx:id="tagText" layoutX="39.0" layoutY="115.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
-                              <Text fx:id="postureText" layoutX="164.0" layoutY="114.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
-                              <Label layoutX="176.0" layoutY="16.0" text="Size" />
-                              <Text fx:id="sizeText" layoutX="208.0" layoutY="29.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="40.0" />
-                           </children></AnchorPane>
-                    </content>
-                  </ScrollPane>
-               </content>
-            </TitledPane>
-            <TitledPane animated="false" layoutY="300.0" minHeight="100.0" prefHeight="100.0" prefWidth="250.0" text="Create World" AnchorPane.bottomAnchor="410.0">
-               <content>
-                  <AnchorPane minHeight="0.0" minWidth="0.0" prefWidth="239.0">
-                     <children>
-                        <Button fx:id="newWorld" layoutX="33.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleNewWorldPressed" text="New World" />
-                        <Button fx:id="loadWorld" layoutX="136.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleLoadWorldPressed" text="Load World" />
-                     </children>
-                  </AnchorPane>
-               </content>
-            </TitledPane>
-            <TitledPane animated="false" layoutY="400.0" minHeight="260.0" prefHeight="260.0" prefWidth="250.0" text="World Controls" AnchorPane.bottomAnchor="150.0">
-               <content>
-                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="0.0" prefWidth="249.0">
-                     <children>
-                        <Button fx:id="loadCritterFile" layoutX="14.0" layoutY="14.0" mnemonicParsing="false" onMousePressed="#handleLoadCritters" text="Load Critter File" />
-                        <RadioButton fx:id="chkRand" layoutX="24.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkRandom" text="Random hex">
-                           <toggleGroup>
-                              <ToggleGroup fx:id="LoadChoice" />
-                           </toggleGroup>
-                        </RadioButton>
-                        <RadioButton fx:id="chkSpecify" layoutX="143.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkSpecify" text="Specify hex">
-                           <toggleGroup>
-                              <ToggleGroup fx:id="HexChoice" />
-                           </toggleGroup></RadioButton>
-                        <TextField fx:id="numCritters" layoutX="201.0" layoutY="15.0" prefHeight="23.0" prefWidth="30.0">
-                           <font>
-                              <Font size="10.0" />
-                           </font>
-                        </TextField>
-                        <Label layoutX="144.0" layoutY="18.0" text="Number" />
-                        <Button fx:id="stepForward" layoutX="83.0" layoutY="102.0" mnemonicParsing="false" onMousePressed="#handleStep" text="Step Forward" />
-                        <Button fx:id="run" layoutX="42.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handleRunPressed" text=" Run " />
-                        <Button fx:id="pause" layoutX="166.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handlePauseClicked" text="Pause" />
-                        <Button fx:id="reset" layoutX="104.0" layoutY="190.0" mnemonicParsing="false" onMousePressed="#handleResetClicked" text="Reset" />
-                     </children>
-                  </AnchorPane>
-               </content>
-            </TitledPane>
-            <TitledPane animated="false" layoutY="660.0" minHeight="150.0" prefHeight="150.0" prefWidth="250.0" text="Simulation Controls" AnchorPane.bottomAnchor="0.0">
-               <content>
-                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="250.0" prefWidth="250.0">
-                     <children>
-                        <Slider fx:id="simulationSpeed" layoutX="24.0" layoutY="22.0" prefHeight="80.0" prefWidth="200.0" showTickLabels="true" showTickMarks="true" value="30.0" />
-                     </children>
-                  </AnchorPane>
-               </content>
-            </TitledPane>
-         </children>
-      </AnchorPane>
-      <ScrollPane fx:id="scroll" fitToHeight="true" fitToWidth="true" hbarPolicy="NEVER" layoutY="25.0" prefHeight="775.0" prefWidth="750.0" vbarPolicy="NEVER" AnchorPane.bottomAnchor="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0" AnchorPane.topAnchor="25.0">
-         <content>
-            <Canvas fx:id="c" height="775.0" onMouseDragged="#handleMapDrag" onMousePressed="#handleMapClicked" onScroll="#handleMapScroll" width="750.0" />
-         </content>
-      </ScrollPane>
-   </children>
+	<children>
+		<MenuBar prefHeight="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+			<menus>
+				<Menu mnemonicParsing="false" text="File">
+					<items>
+						<MenuItem fx:id="help" mnemonicParsing="false" onAction="#help" text="Help" />
+						<MenuItem fx:id="close" mnemonicParsing="false" onAction="#close" text="Close" />
+					</items>
+				</Menu>
+			</menus>
+		</MenuBar>
+		<HBox alignment="BOTTOM_LEFT" layoutY="774.0" prefHeight="25.0" AnchorPane.bottomAnchor="2.1316282072803006E-14" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0">
+			<children>
+				<SplitPane dividerPositions="0.5" prefHeight="26.0" style="-fx-background-color: lightgray;" HBox.hgrow="ALWAYS">
+					<items>
+						<HBox alignment="CENTER" prefHeight="25.0" prefWidth="200.0">
+							<children>
+								<Label fx:id="crittersAlive" alignment="CENTER" text="Critters Alive: 0" />
+							</children>
+						</HBox>
+						<HBox alignment="CENTER" prefHeight="100.0" prefWidth="200.0">
+							<children>
+								<Label fx:id="stepsTaken" text="Time: 0" />
+							</children>
+						</HBox>
+					</items>
+				</SplitPane>
+			</children>
+		</HBox>
+		<AnchorPane layoutX="749.0" layoutY="25.0" prefHeight="775.0" prefWidth="250.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="25.0">
+			<children>
+				<TitledPane animated="false" collapsible="false" layoutY="-3.0" minHeight="274.0" prefHeight="274.0" prefWidth="250.0" text="World Info" AnchorPane.bottomAnchor="510.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+					<content>
+						<ScrollPane fitToWidth="true" hbarPolicy="NEVER" prefWidth="248.0">
+							<content>
+								<AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="333.0" prefWidth="248.0">
+									<children>
+										<Label layoutX="10.0" layoutY="1.0" text="Species" />
+										<Label layoutX="10.0" layoutY="25.0" prefHeight="10.0" prefWidth="70.0" text="Column" />
+										<Label layoutX="130.0" layoutY="25.0" prefHeight="10.0" prefWidth="55.0" text="Row" />
+										<Label layoutX="10.0" layoutY="45.0" prefHeight="10.0" prefWidth="70.0" text="Mem Size" />
+										<Label layoutX="130.0" layoutY="45.0" prefHeight="10.0" prefWidth="55.0" text="Pass" />
+										<Label layoutX="10.0" layoutY="65.0" prefHeight="10.0" prefWidth="70.0" text="Defense" />
+										<Label layoutX="130.0" layoutY="65.0" prefHeight="10.0" prefWidth="55.0" text="Offense" />
+										<Label layoutX="10.0" layoutY="85.0" prefHeight="10.0" prefWidth="70.0" text="Energy" />
+										<Label layoutX="130.0" layoutY="85.0" prefWidth="55.0" text="Size" />
+										<Label layoutX="10.0" layoutY="105.0" prefHeight="10.0" prefWidth="70.0" text="Tag" />
+										<Label layoutX="130.0" layoutY="105.0" prefHeight="10.0" prefWidth="55.0" text="Posture" />
+										<Label fx:id="lastRuleDisplay" layoutX="46.0" layoutY="133.0" prefHeight="150.0" prefWidth="167.0" wrapText="true" />
+										<Button fx:id="displayProgram" layoutX="78.0" layoutY="294.0" mnemonicParsing="false" onMouseClicked="#handleDisplayProgram" text="Display Program" />
+
+										<Text fx:id="speciesText" layoutX="66.0" layoutY="16.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="174.4000244140625" />
+										<Text fx:id="columnText" layoutX="75.0" layoutY="41.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+										<Text fx:id="rowText" layoutX="185.0" layoutY="41.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="27.0" />
+										<Text fx:id="memSizeText" layoutX="75.0" layoutY="61.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="28.0" />
+										<Text fx:id="passText" layoutX="185.0" layoutY="61.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
+										<Text fx:id="defenseText" layoutX="75.0" layoutY="81.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+										<Text fx:id="offenseText" layoutX="185.0" layoutY="81.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+										<Text fx:id="energyText" layoutX="75.0" layoutY="101.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
+										<Text fx:id="sizeText" layoutX="185.0" layoutY="101.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="40.0" />
+										<Text fx:id="tagText" layoutX="75.0" layoutY="121.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
+										<Text fx:id="postureText" layoutX="185.0" layoutY="121.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
+									</children>
+								</AnchorPane>
+							</content>
+						</ScrollPane>
+					</content>
+				</TitledPane>
+				<TitledPane animated="false" collapsible="false" layoutY="300.0" minHeight="100.0" prefHeight="100.0" prefWidth="250.0" text="Create World" AnchorPane.bottomAnchor="410.0">
+					<content>
+						<AnchorPane minHeight="0.0" minWidth="0.0" prefWidth="239.0">
+							<children>
+								<Button fx:id="newWorld" layoutX="33.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleNewWorldPressed" text="New World" />
+								<Button fx:id="loadWorld" layoutX="136.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleLoadWorldPressed" text="Load World" />
+							</children>
+						</AnchorPane>
+					</content>
+				</TitledPane>
+				<TitledPane animated="false" collapsible="false" layoutY="400.0" minHeight="260.0" prefHeight="260.0" prefWidth="250.0" text="World Controls" AnchorPane.bottomAnchor="150.0">
+					<content>
+						<AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="0.0" prefWidth="249.0">
+							<children>
+								<Button fx:id="loadCritterFile" layoutX="14.0" layoutY="14.0" mnemonicParsing="false" onMousePressed="#handleLoadCritters" text="Load Critter File" />
+								<TextField fx:id="numCritters" layoutX="201.0" layoutY="15.0" prefHeight="23.0" prefWidth="30.0">
+									<font>
+										<Font size="10.0" />
+									</font>
+								</TextField>
+								<Label layoutX="144.0" layoutY="18.0" text="Number" />
+								<Button fx:id="stepForward" layoutX="83.0" layoutY="102.0" mnemonicParsing="false" onMousePressed="#handleStep" text="Step Forward" />
+								<Button fx:id="run" layoutX="42.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handleRunPressed" text=" Run " />
+								<Button fx:id="pause" layoutX="166.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handlePauseClicked" text="Pause" />
+								<ToggleButton fx:id="chkRandom" layoutX="27.0" layoutY="51.0" mnemonicParsing="false" onMousePressed="#handleCheckRandom" text="Random hex">
+									<toggleGroup>
+										<ToggleGroup fx:id="LoadChoice" />
+									</toggleGroup>
+								</ToggleButton>
+								<ToggleButton fx:id="chkSpecify" layoutX="146.0" layoutY="51.0" mnemonicParsing="false" text="Specify hex" toggleGroup="$LoadChoice" />
+							</children>
+						</AnchorPane>
+					</content>
+				</TitledPane>
+				<TitledPane animated="false" collapsible="false" layoutY="660.0" minHeight="150.0" prefHeight="150.0" prefWidth="250.0" text="Simulation Controls" AnchorPane.bottomAnchor="0.0">
+					<content>
+						<AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="250.0" prefWidth="250.0">
+							<children>
+								<Slider fx:id="simulationSpeed" layoutX="24.0" layoutY="22.0" prefHeight="80.0" prefWidth="200.0" showTickLabels="true" showTickMarks="true" value="30.0" />
+							</children>
+						</AnchorPane>
+					</content>
+				</TitledPane>
+			</children>
+		</AnchorPane>
+		<ScrollPane fx:id="scroll" fitToHeight="true" fitToWidth="true" hbarPolicy="NEVER" layoutY="25.0" prefHeight="775.0" prefWidth="750.0" vbarPolicy="NEVER" AnchorPane.bottomAnchor="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0" AnchorPane.topAnchor="25.0">
+			<content>
+				<Canvas fx:id="c" height="775.0" onKeyPressed="#handleKeyEvents" onMouseClicked="#handleMapClicked" onMouseDragged="#handleMapDrag" onScroll="#handleMapScroll" width="1350.0" />
+			</content>
+		</ScrollPane>
+	</children>
 </AnchorPane>
diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
index bd7e371..545509b 100644
--- a/src/main/java/interpret/InterpreterImpl.java
+++ b/src/main/java/interpret/InterpreterImpl.java
@@ -28,7 +28,6 @@ public class InterpreterImpl implements Interpreter
 	{
 		Action a = interpret(c.getProgram());
 		executeAction(a);
-		//System.out.println("AS");
 	}
 	
 	/**
@@ -59,13 +58,14 @@ public class InterpreterImpl implements Interpreter
 					}
 					else
 						applyUpdate((Update) ruleCommand.getLast());
-					c.setLastRule(r.toString());
+					c.setLastRuleString(r.toString());
+					c.setLastRuleIndex(rl.indexOf(r));
 					break;
 				}
 			}
-			c.incrementPass();
+			c.incrementPass(world.getMaxRules());
 		}
-		c.setMemory(0, 5);
+		c.resetPass();
 		
 		if(a == null)
 			a = new Action(ActType.WAIT);
@@ -259,7 +259,7 @@ public class InterpreterImpl implements Interpreter
 				else
 					result = (int) (Math.random() * index);
 			case SMELL:
-				result = 0;
+				result = world.smell(c);
 		}
 		return result;
 	}
diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
index a0cf4e4..f114205 100644
--- a/src/main/java/parse/ParserImpl.java
+++ b/src/main/java/parse/ParserImpl.java
@@ -9,14 +9,14 @@ import ast.BinaryCondition.Operator;
 import ast.UnaryExpr.ExprType;
 import exceptions.SyntaxError;
 
-class ParserImpl implements Parser {
+public class ParserImpl implements Parser {
 	/** tokens is the Tokenizer that contains all the tokens from which the AST is built. */
 	private Tokenizer tokens;
 	private Program programAST;
 
 	@Override
 	public Program parse(Reader r) {
-		this.tokens = new Tokenizer(r);
+		tokens = new Tokenizer(r);
 		try {
 			programAST = parseProgram(tokens);
 		}
@@ -24,8 +24,7 @@ class ParserImpl implements Parser {
 			programAST = null;
 		}
 
-		return this.programAST;
-
+		return programAST;
 	}
 
 	/**
diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
index 067a9c8..2163b02 100644
--- a/src/main/java/simulation/AbstractWorld.java
+++ b/src/main/java/simulation/AbstractWorld.java
@@ -1,5 +1,6 @@
 package simulation;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
 
@@ -12,6 +13,10 @@ public abstract class AbstractWorld implements SimpleWorld
 	protected HashMap<String, Double> CONSTANTS;
 	/** Stores all the critters present in the world, in the order in which they were created. */
 	protected LinkedList<SimpleCritter> critterList;
+	/** Stores all critters that have died or have been removed. */
+	protected LinkedList<SimpleCritter> deadCritters;
+	/** A list of all the hexes that have changed during one critter turn. Is reset at the end of each turn. */
+	protected ArrayList<Hex> updatedHexes;
 	/** The number of time steps passed since this world's genesis. */
 	protected int timePassed;
 	
@@ -39,18 +44,31 @@ public abstract class AbstractWorld implements SimpleWorld
 		return timePassed;
 	}
 	
+	@Override
+	public LinkedList<SimpleCritter> getCritterList()
+	{
+		return critterList;
+	}
+	
+	@Override
+	public LinkedList<SimpleCritter> collectCritterCorpses()
+	{
+		return deadCritters;
+	}
+	
 	@Override
 	@SuppressWarnings("unchecked")
 	public void advanceOneTimeStep()
 	{
 		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
-		System.out.println(clone.toString());
 		for(int i = 0; i < clone.size(); i++)
 		{
 			SimpleCritter sc = clone.get(i);
-			Interpreter im = new InterpreterImpl(sc, this);
-			im.simulateCritterTurn();
-			//System.out.println("AH");
+			if (critterList.contains(sc))
+			{
+				Interpreter im = new InterpreterImpl(sc, this);
+				im.simulateCritterTurn();
+			}
 		}
 		
 		for(int i = 0; i < clone.size(); i++)
@@ -61,6 +79,19 @@ public abstract class AbstractWorld implements SimpleWorld
 		
 		timePassed++;
 	}
+	
+	@Override
+	public ArrayList<Hex> getAndResetUpdatedHexes()
+	{
+		try
+		{
+			return updatedHexes;
+		}
+		finally
+		{
+			updatedHexes = new ArrayList<Hex>();
+		}
+	}
 
 	@Override
 	public abstract void loadCritters(String filename, int n, int direction);
@@ -74,20 +105,27 @@ public abstract class AbstractWorld implements SimpleWorld
 	
 	/**
 	 * Looks at the contents of a hex adjacent to a critter.
-	 * @param sc : the critter who is observing its surroundings
-	 * @param dir : the direction in which to look
-	 * @return an integer value based on the contents of the observed hex, determined by the {@code WorldObject}
+	 * @param sc - The critter who is observing its surroundings
+	 * @param dir - The direction in which to look
+	 * @return An integer value based on the contents of the observed hex, determined by the {@code WorldObject}
 	 * 		   method {@code getAppearance()}.
 	 */
 	public abstract int searchNearby(SimpleCritter sc, int dir);
 
 	/**
 	 * Looks at the contents of a hex ahead of a critter.
-	 * @param sc : the critter who is observing its surroundings
-	 * @param index : how far ahead to look
-	 * @return an integer value based on the contents of the observed hex, following the same scheme as {@code searchNearby}.
+	 * @param sc - The critter who is observing its surroundings
+	 * @param index - How far ahead to look
+	 * @return An integer value based on the contents of the observed hex, following the same scheme as {@code searchNearby}.
 	 */
 	public abstract int searchAhead(SimpleCritter sc, int index);
+	
+	/**
+	 * Finds the direction and distance of the nearest food source.
+	 * @param sc - The critter who is observing its surroundings
+	 * @return An integer value defined to be {@code distance * 1000 + direction}.
+	 */
+	public abstract int smell(SimpleCritter sc);
 
 	/* ========================================= */
 	/* ----------- Critter Actions ------------- */
@@ -102,34 +140,34 @@ public abstract class AbstractWorld implements SimpleWorld
 	
 	/**
 	 * Moves a critter, if there is nothing in the way and critter will not move off the world bounds.
-	 * @param sc : the moving critter
-	 * @param forward : whether or not the critter is moving forward or backward
+	 * @param sc - The moving critter
+	 * @param forward - Whether or not the critter is moving forward or backward
 	 */
 	public abstract void moveCritter(SimpleCritter sc, boolean forward);
 	
 	/**
 	 * Turns a critter.
-	 * @param sc : the turning critter
-	 * @param forward : whether or not the critter is turning clockwise or counterclockwise
+	 * @param sc - The turning critter
+	 * @param forward - Whether or not the critter is turning clockwise or counterclockwise
 	 */
 	public abstract void turnCritter(SimpleCritter sc, boolean clockwise);
 
 	/**
 	 * Forces a critter to eat, if there is food in the hex directly in front of it. This action replenishes energy
 	 * equal to the caloric content of the food eaten.
-	 * @param sc : the feasting critter
+	 * @param sc - The feasting critter
 	 */
 	public abstract void critterEat(SimpleCritter sc);
 
 	/**
 	 * Grows a critter by one size.
-	 * @param sc : the growing critter
+	 * @param sc - The growing critter
 	 */
 	public abstract void growCritter(SimpleCritter sc);
 
 	/** 
 	 * Simulates the results of one critter attacking another.
-	 * @param attacker
+	 * @param attacker - The critter who initiates the fight
 	 */
 	public abstract void critterBattle(SimpleCritter attacker);
 	
@@ -137,7 +175,7 @@ public abstract class AbstractWorld implements SimpleWorld
 	/** 
 	 * Executes the result of one critter attempting to bud. The newly created offspring will appear directly behind
 	 * the parent critter, unless there is something already in that hex (in which case no reproduction will occur).
-	 * @param sc : the budding critter
+	 * @param sc - The budding critter
 	 */
 	public abstract void critterBud(SimpleCritter sc);
 	
@@ -145,28 +183,28 @@ public abstract class AbstractWorld implements SimpleWorld
 	 * Executes the result of one critter attempting to mate with another critter. The other critter must be directly in
 	 * front of the first critter and facing the first critter. The newly created offspring will appear directly behind
 	 * one of the parent critters, unless there is something already in that hex (in which case no reproduction will occur).
-	 * @param sc
+	 * @param sc - The critter who initiates the mating process
 	 */
 	public abstract void critterMate(SimpleCritter sc);
 	
 	/**
 	 * One critter "tags" another critter by setting its "tag" attribute in memory equal to the value of {@code index}.
-	 * @param sc
-	 * @param index
+	 * @param sc - The tagging critter
+	 * @param index - The value at which to tag
 	 */
 	public abstract void critterTag(SimpleCritter sc, int index);
 	
 	/**
 	 * One critter severs a part of its soul (its energy) and places it on the hex in front of it in the form of food. It is
-	 * possible for the critter to serve all of its remaining energy, killing it in the process
-	 * @param sc : the overly generous critter
-	 * @param index : the amount of food to serve
+	 * possible for the critter to serve all of its remaining energy, killing it in the process.
+	 * @param sc - The overly generous critter
+	 * @param index - The amount of food to serve
 	 */
 	public abstract void critterServe(SimpleCritter sc, int index);
 	
 	/**
 	 * A critter does nothing but sit in the sun. It replenishes some energy in the process.
-	 * @param sc
+	 * @param sc - The soaking critter
 	 */
 	public abstract void critterSoakEnergy(SimpleCritter sc);
 }
\ No newline at end of file
diff --git a/src/main/java/simulation/AdjustablePriorityQueue.java b/src/main/java/simulation/AdjustablePriorityQueue.java
new file mode 100644
index 0000000..d903b8d
--- /dev/null
+++ b/src/main/java/simulation/AdjustablePriorityQueue.java
@@ -0,0 +1,341 @@
+package simulation;
+
+import java.util.AbstractQueue;
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+/**
+ * A priority queue implementation supporting in situ adjustment of priorities.
+ * Priorities are double values. Elements themselves are used as keys in the
+ * {@link #getPriority(Object)} and {@link #setPriority(Object, double)}
+ * methods, therefore the elements in the queue must be unique and the notion of
+ * equality used to access them must be identity ({@code ==}), in constrast to
+ * {@link java.util.PriorityQueue}, which relies on the natural ordering of the
+ * elements or a supplied {@link java.util.Comparator}. An attempt to insert an
+ * element that is already there results in an {@link IllegalArgumentException}.
+ * 
+ * @author CS 2110
+ * @param <T>
+ *           the type of elements contained in this {@code PriorityQueue}.
+ */
+public class AdjustablePriorityQueue<T> extends AbstractQueue<T> {
+
+   /**
+    * The heap in which elements are stored.
+    */
+   private List<PQElement<T>> heap = new ArrayList<PQElement<T>>();
+
+   /**
+    * A map giving the location of each object in the heap.
+    */
+   private Map<T, Integer> map = new IdentityHashMap<T, Integer>();
+
+   /**
+    * Whether this is a min queue (true) or a max queue (false). A min queue
+    * supports extract min and a max queue supports extract max.
+    */
+   private boolean orientation;
+
+   private class PQElement<U> {
+      private U item;
+      private double priority;
+
+      PQElement(U item, double priority) {
+         this.item = item;
+         this.priority = priority;
+      }
+   }
+
+   /**
+    * Constructs a {@code PriorityQueue} that extracts elements according to
+    * priority. Priorities are doubles that are supplied in the constructor, but
+    * can be changed in situ. The priority queue can be either a max queue
+    * (extract max supported) or a min queue (extract min supported) depending
+    * on the value of the parameter.
+    * 
+    * @param orientation
+    *           the orientation of the queue - true=min, false=max.
+    */
+   public AdjustablePriorityQueue(boolean orientation) {
+      this.orientation = orientation;
+   }
+
+   /**
+    * Constructs a {@code PriorityQueue} min queue. The element with the
+    * smallest priority value is the next extracted.
+    */
+   public AdjustablePriorityQueue() {
+      this(true);
+   }
+
+   /**
+    * By using this method to enter an element in the heap, we maintain the
+    * invariant that {@code map} always gives the current index of the item.
+    * 
+    * @param index
+    *           the starting index
+    */
+   private void set(int index, PQElement<T> x) {
+      heap.set(index, x);
+      map.put(x.item, index);
+   }
+
+   /**
+    * Remove an element, maintaining the invariant that {@code map} always gives
+    * the current index of the item.
+    * 
+    * @param index
+    *           the starting index
+    * @return the element removed
+    */
+   T delete(int index) {
+      T returnValue;
+      try {
+         returnValue = heap.get(index).item;
+      } catch (IndexOutOfBoundsException npe) {
+         throw new NoSuchElementException();
+      }
+      map.remove(returnValue);
+      PQElement<T> z = heap.remove(heap.size() - 1);
+      if (index != heap.size()) {
+         set(index, z);
+         rotateDown(index);
+      }
+      return returnValue;
+   }
+
+   /**
+    * Rotate up starting at the given index until heap order is reestablished.
+    * 
+    * @param index
+    *           the starting index
+    */
+   private void rotateUp(int index) {
+      PQElement<T> x = heap.get(index);
+      while (index > 0) {
+         int parentIndex = (index - 1) / 2;
+         PQElement<T> y = heap.get(parentIndex);
+         if (orientation && x.priority >= y.priority) break;
+         if (!orientation && x.priority <= y.priority) break;
+         set(index, y);
+         index = parentIndex;
+      }
+      set(index, x);
+   }
+
+   /**
+    * Rotate down starting at the given index until heap order is reestablished.
+    * 
+    * @param index
+    *           the starting index
+    */
+   private void rotateDown(int index) {
+      PQElement<T> x = heap.get(index), y, z;
+      int leftIndex, rightIndex;
+      while (2 * index + 2 < heap.size()) {
+         leftIndex = 2 * index + 1;
+         rightIndex = leftIndex + 1;
+         y = heap.get(leftIndex);
+         z = heap.get(rightIndex);
+         if (orientation && x.priority <= y.priority
+                  && x.priority <= z.priority) break;
+         if (!orientation && x.priority >= y.priority
+                  && x.priority >= z.priority) break;
+         if ((orientation && y.priority < z.priority)
+                  || (!orientation && y.priority > z.priority)) {
+            set(index, y);
+            index = leftIndex;
+         } else {
+            set(index, z);
+            index = rightIndex;
+         }
+      }
+      leftIndex = 2 * index + 1;
+      if (leftIndex < heap.size()) {
+         y = heap.get(leftIndex);
+         if ((orientation && x.priority > y.priority)
+                  || (!orientation && x.priority < y.priority)) {
+            set(index, y);
+            index = leftIndex;
+         }
+      }
+      set(index, x);
+   }
+
+   /**
+    * Inserts an item with the default priority:
+    * {@link Double#POSITIVE_INFINITY} for a min queue,
+    * {@link Double#NEGATIVE_INFINITY} for a max queue.
+    * 
+    * @param item
+    *           the item to insert
+    * 
+    * @throws IllegalArgumentException
+    *            if the item is already in the queue
+    */
+   @Override
+   public boolean offer(T item) {
+      return offer(item, orientation? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);
+   }
+
+   /**
+    * Inserts an item with the given priority.
+    * 
+    * @param item
+    *           the item to insert
+    * @param priority
+    *           the double priority of the item
+    * 
+    * @throws IllegalArgumentException
+    *            if the item is already in the queue
+    */
+   private boolean offer(T item, double priority)
+            throws IllegalArgumentException {
+      if (item == null) throw new IllegalArgumentException();
+      if (map.containsKey(item)) throw new IllegalArgumentException();
+      PQElement<T> wrapper = new PQElement<T>(item, priority);
+      map.put(item, heap.size());
+      heap.add(wrapper);
+      rotateUp(heap.size() - 1);
+      return true;
+   }
+
+   /**
+    * Tests whether the data structure contains the given item. This is
+    * implemented in the AbstractQueue adapter, but overridden here to do in
+    * constant time.
+    * 
+    * @param item
+    *           the item to test
+    * @return true if the data structure contains the item
+    */
+   @Override
+   public boolean contains(Object item) {
+      return map.get(item) != null;
+   }
+
+   /**
+    * {@inheritDoc}
+    * See {@link java.util.Queue#poll()}.
+    */
+   @Override
+   public T poll() {
+      if (size() == 0) return null;
+      return delete(0);
+   }
+
+   /**
+    * {@inheritDoc}
+    * See {@link java.util.Queue#peek()}.
+    */
+   @Override
+   public T peek() {
+      if (size() == 0) return null;
+      return heap.get(0).item;
+   }
+
+   /**
+    * Gets the current priority of the given item.
+    * 
+    * @param item
+    *           the item
+    * 
+    * @throws NoSuchElementException
+    *            if the item is not in the queue
+    *            
+    * @return the priority of the given item
+    */
+   public double getPriority(T item) throws NoSuchElementException {
+      int index;
+      try {
+         index = map.get(item);
+      } catch (NullPointerException npe) {
+         throw new NoSuchElementException();
+      }
+      PQElement<T> y = heap.get(index);
+      return y.priority;
+   }
+
+   /**
+    * Sets the priority of the given item.
+    * 
+    * @param item
+    *           the item to be adjusted
+    * @param newPriority
+    *           the new priority
+    * 
+    * @throws NoSuchElementException
+    *            if the item is not in the queue
+    */
+   public void setPriority(T item, double newPriority)
+            throws NoSuchElementException {
+      int index;
+      try {
+         index = map.get(item);
+      } catch (NullPointerException npe) {
+         throw new NoSuchElementException();
+      }
+      PQElement<T> y = heap.get(index);
+      double oldPriority = y.priority;
+      y.priority = newPriority;
+      if ((orientation && newPriority < oldPriority)
+               || (!orientation && newPriority > oldPriority)) {
+         rotateUp(index);
+      } else rotateDown(index);
+   }
+
+   /**
+    * {@inheritDoc}
+    * See {@link java.util.Collection#size()}.
+    */
+   @Override
+   public int size() {
+      return heap.size();
+   }
+
+   /**
+    * {@inheritDoc}
+    * See {@link java.util.Collection#iterator()}.
+    */
+   @Override
+   public Iterator<T> iterator() {
+      return new APQIterator(this);
+   }
+
+   private class APQIterator implements Iterator<T> {
+
+      private Iterator<PQElement<T>> iterator;
+      private PQElement<T> last = null;
+      private AdjustablePriorityQueue<T> apq;
+
+      APQIterator(AdjustablePriorityQueue<T> apq) {
+         this.apq = apq;
+         this.iterator = apq.heap.iterator();
+      }
+
+      @Override
+      public boolean hasNext() {
+         return iterator.hasNext();
+      }
+
+      @Override
+      public T next() {
+         last = iterator.next();
+         return last.item;
+      }
+
+      @Override
+      public void remove() {
+         if (last == null) throw new IllegalStateException();
+         int index = map.get(last.item);
+         assert 0 <= index && index < apq.size();
+         apq.delete(index);
+         last = null;
+      }
+   }
+
+}
diff --git a/src/main/java/simulation/Critter.java b/src/main/java/simulation/Critter.java
index a414aab..3082646 100644
--- a/src/main/java/simulation/Critter.java
+++ b/src/main/java/simulation/Critter.java
@@ -6,6 +6,8 @@ import java.util.Arrays;
 /** A critter is a creature that inhabits CritterWorld. */
 public class Critter implements SimpleCritter
 {
+	/** The ID of this critter. */
+	private int ID;
 	/** The set of rules for this critter. */
 	private Program prog;
 	/** The memory of this critter, which stores important attributes of the critter. */
@@ -20,13 +22,15 @@ public class Critter implements SimpleCritter
 	private String name;
 	/** A string containing information about the last rule this critter completed. */
 	private String lastRuleCompleted;
+	/** the index of the last rule executed by this critter, or -1 if none have been executed yet. */
+	private int lastRuleIndex;
 	
 	/**
 	 * Creates a new Critter with a specified ruleset, memory, orientation, and name.
-	 * @param p
-	 * @param mem
-	 * @param dir
-	 * @param s
+	 * @param p The critter's program
+	 * @param mem The critter's memory
+	 * @param dir The critter's initial orientation
+	 * @param s The critter's species name
 	 */
 	public Critter(Program p, int[] mem, String s, int dir)
 	{
@@ -36,15 +40,17 @@ public class Critter implements SimpleCritter
 		name = s;
 		readyToMingle = false;
 		lastRuleCompleted = null;
+		lastRuleIndex = -1;
+		ID = 0;
 		
 		orientation = Direction.constructDir(dir);
 	}
 	
 	/**
 	 * Creates a new Critter with a specified ruleset, memory, name, and a random orientation.
-	 * @param p
-	 * @param mem
-	 * @param s
+	 * @param p The critter's program
+	 * @param mem The critter's memory
+	 * @param s The critter's species name
 	 */
 	public Critter(Program p, int[] mem, String s)
 	{
@@ -54,11 +60,25 @@ public class Critter implements SimpleCritter
 		name = s;
 		readyToMingle = false;
 		lastRuleCompleted = null;
+		lastRuleIndex = -1;
+		ID = 0;
 		
 		int rand = (int) (Math.random() * 6);
 		orientation = Direction.constructDir(rand);
 	}
 	
+	@Override
+	public int getID()
+	{
+		return ID;
+	}
+	
+	@Override
+	public void setID(int id)
+	{
+		ID = id;
+	}
+	
 	@Override
 	public int size()
 	{
@@ -84,16 +104,36 @@ public class Critter implements SimpleCritter
 	}
 	
 	@Override
-	public String getLastRule()
+	public void randomizeOrientation()
+	{
+		int rand = (int) (Math.random() * 6);
+		orientation = Direction.constructDir(rand);
+	}
+	
+	@Override
+	public String getLastRuleString()
 	{
 		return lastRuleCompleted;
 	}
+	
+	@Override
+	public int getLastRuleIndex()
+	{
+		return lastRuleIndex;
+	}
+	
 	@Override
-	public void setLastRule(String s)
+	public void setLastRuleString(String s)
 	{
 		lastRuleCompleted = s;
 	}
 	
+	@Override
+	public void setLastRuleIndex(int i)
+	{
+		lastRuleIndex = i;
+	}
+	
 	@Override
 	public int readMemory(int index)
 	{
@@ -137,12 +177,24 @@ public class Critter implements SimpleCritter
 	}
 	
 	@Override
-	public void incrementPass()
+	public void setTag(int newVal)
 	{
-		if(memory[5] < 999)
+		if(newVal >= 0 && newVal <= 99)
+			memory[6] = newVal;
+	}
+	@Override
+	public void incrementPass(int maxRules)
+	{
+		if(memory[5] < maxRules)
 			memory[5]++;
 	}
 	
+	@Override
+	public void resetPass()
+	{
+		memory[5] = 0;
+	}
+	
 	@Override
 	public void turn(boolean counterclockwise)
 	{
diff --git a/src/main/java/simulation/FileParser.java b/src/main/java/simulation/FileParser.java
index 95dbc6b..b2a4633 100644
--- a/src/main/java/simulation/FileParser.java
+++ b/src/main/java/simulation/FileParser.java
@@ -57,8 +57,8 @@ public class FileParser
 	 * trimming out a specified substring {@code substringToCut}. If {@code substringToCut} is not present in the line or the end
 	 * of the file is reached, returns an empty string.
 	 * 
-	 * @param b : the BufferedReader to read lines from
-	 * @param : substringToCut the substring to trim
+	 * @param b The BufferedReader to read lines from
+	 * @param substringToCut The substring to trim out
 	 * @return A string containing only the attribute given on the line
 	 */
 	public static String parseAttributeFromLine(BufferedReader b, String substringToCut)
@@ -78,6 +78,24 @@ public class FileParser
 		return result;
 	}
 	
+	/**
+	 * Given a plaintext string, returns a string with the specified substring {@code substringToCut} trimmed out. If
+	 * {@code substringToCut} is not present, returns an empty string.
+	 * 
+	 * @param initial The plaintext string
+	 * @param substringToCut The substring to trim out
+	 * @return A string containing only the attribute given on the line
+	 */
+	public static String parseAttributeFromLine(String initial, String substringToCut)
+	{
+		String result = "";
+		int len = substringToCut.length();
+		if(initial != null && initial.startsWith(substringToCut) && len < initial.length())
+			result = initial.substring(len);
+		
+		return result;
+	}
+	
 	/**
 	 * Prepares an int array to be used as critter memory, based on a string array.<br>
 	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
diff --git a/src/main/java/simulation/Hex.java b/src/main/java/simulation/Hex.java
index cd3bd91..298b27f 100644
--- a/src/main/java/simulation/Hex.java
+++ b/src/main/java/simulation/Hex.java
@@ -1,81 +1,78 @@
 package simulation;
 
 /** Stores the information for one hex in the world grid. */
-public class Hex
-{
+public class Hex {
 	/** The column index of this Hex. */
 	private int colIndex;
 	/** The row index of this Hex. */
 	private int rowIndex;
 	/** What this hex contains. May be null if there is nothing on this hex. */
 	private WorldObject content;
-	
+
 	/** Creates a new empty Hex object with the specified rowIndex and colIndex. */
-	public Hex(int c, int r)
-	{
+	public Hex(int c, int r) {
 		colIndex = c;
 		rowIndex = r;
 		content = null;
 	}
-	
+
 	/** Returns the column index of this Hex. */
-	public int getColumnIndex()
-	{
+	public int getColumnIndex() {
 		return colIndex;
 	}
-	
+
 	/** Returns the row index of this Hex. */
-	public int getRowIndex()
-	{
+	public int getRowIndex() {
 		return rowIndex;
 	}
-	
+
 	/**
 	 * Adds a world object to this hex, if it is empty.
-	 * @param wo the object to add
+	 * 
+	 * @param wo
+	 *            the object to add
 	 * @return whether or not {@code wo} was able to be added to this hex.
 	 */
-	public boolean addContent(WorldObject wo)
-	{
-		if(isEmpty())
-		{
+	public boolean addContent(WorldObject wo) {
+		if (isEmpty()) {
 			content = wo;
 			return true;
 		}
 		return false;
 	}
-	
+
 	/** Removes the content on this hex. */
-	public void removeContent()
-	{
+	public void removeContent() {
 		content = null;
 	}
-	
-	public WorldObject getContent()
-	{
+
+	public WorldObject getContent() {
 		return content;
 	}
+
 	/** Returns {@code true} if and only if {@code content == null}. */
-	public boolean isEmpty()
-	{
+	public boolean isEmpty() {
 		return content == null;
 	}
-	
+
 	/**
-	 * Returns an integer representing how this hex appears to a critter. If this hex is empty, this integer is 0,
-	 * but otherwise, this value is determined by {@code content.getAppearance()}, which follows the numbering scheme
-	 * described in the interface {@code WorldObject}.
+	 * Returns an integer representing how this hex appears to a critter. If this
+	 * hex is empty, this integer is 0, but otherwise, this value is determined by
+	 * {@code content.getAppearance()}, which follows the numbering scheme described
+	 * in the interface {@code WorldObject}.
 	 */
-	public int hexAppearance()
-	{
+	public int hexAppearance() {
 		return isEmpty() ? 0 : content.getAppearance();
 	}
-	
+
 	@Override
-	public String toString()
-	{
-		if(content == null)
+	public String toString() {
+		if (content == null)
 			return "-";
 		return content.toString();
 	}
+
+	public boolean equals(Hex other) {
+		return this.colIndex == other.colIndex && this.rowIndex == other.rowIndex;
+	}
 }
\ No newline at end of file
diff --git a/src/main/java/simulation/SimpleCritter.java b/src/main/java/simulation/SimpleCritter.java
index 0bfb0f2..25003c8 100644
--- a/src/main/java/simulation/SimpleCritter.java
+++ b/src/main/java/simulation/SimpleCritter.java
@@ -4,6 +4,12 @@ import ast.Program;
 
 public interface SimpleCritter extends WorldObject
 {
+	/** Returns the ID of this critter, or 0 if it hasn't been assigned one. */
+	public int getID();
+	
+	/** Sets the ID of this critter. */
+	public void setID(int id);
+	
 	/** Returns the ruleset of this critter. */
 	public Program getProgram();
 	
@@ -16,12 +22,24 @@ public interface SimpleCritter extends WorldObject
 	/** Returns the orientation of this critter. */
 	public int getOrientation();
 	
+	/** Randomizes the orientation of this critter. */
+	public void randomizeOrientation();
+	
 	/** Returns the current energy level of this critter. */
 	public int getEnergy();
 	
 	/** Updates the critter's energy by the amount specified. */
 	public void updateEnergy(int amount, int maxEnergyPerSize);
 	
+	/** Updates the critter's tag number to the value specified, if that value is in [0, 99]. */
+	public void setTag(int newVal);
+	
+	/** Increments the pass number of this critter (memory index 5) by one, if it is less than {@code maxRules}. */
+	public void incrementPass(int maxRules);
+	
+	/** Resets the pass number of this critter (memory index 5) to zero. */
+	public void resetPass();
+	
 	/** 
 	 * Returns the value of {@code memory[index]}.
 	 * @param index
@@ -48,13 +66,16 @@ public interface SimpleCritter extends WorldObject
 	public String getName();
 	
 	/** Returns a string representation of the last rule executed by this critter. */
-	public String getLastRule();
+	public String getLastRuleString();
+	
+	/** Returns the index of the last rule executed by this critter, or -1 if none have been executed yet. */
+	public int getLastRuleIndex();
 	
 	/** Sets the last rule executed. */
-	public void setLastRule(String s);
+	public void setLastRuleString(String s);
 	
-	/** Increments the pass number of this critter (memory index 5) by one, if it is less than 999. */
-	public void incrementPass();
+	/** Sets the index of the last rule executed by this critter. */
+	public void setLastRuleIndex(int i);
 	
 	/**
 	 * Turns this critter in the direction specified.
diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
index d551c22..66b7699 100644
--- a/src/main/java/simulation/SimpleWorld.java
+++ b/src/main/java/simulation/SimpleWorld.java
@@ -1,6 +1,8 @@
 package simulation;
 
 import java.io.File;
+import java.util.ArrayList;
+import java.util.LinkedList;
 import java.util.Map;
 import java.util.Set;
 
@@ -25,6 +27,9 @@ public interface SimpleWorld
 	/** Returns the amount of time passed since this world's genesis. */
 	int getTimePassed();
 	
+	/** Returns the name of this world. */
+	String getWorldName();
+	
 	/**
 	 * Loads critters of following a set pattern into this world.
 	 * @param filename the file containing the critter information
@@ -43,11 +48,61 @@ public interface SimpleWorld
 	 */
 	void loadCritters(File file, int n, int direction);
 	
+	/**
+	 * Loads one critter species into the world at random locations.
+	 * @param sc
+	 * @param n
+	 * @param sessionID
+	 * @return 
+	 */
+	int[] loadCritters(SimpleCritter sc, int n, int sessionID);
+	
+	/**
+	 * 
+	 * @param file
+	 * @param c
+	 * @param r
+	 */
 	void loadCritterAtLocation(File file, int c, int r);
 	
+	/**
+	 * Loads a single critter into the world at the specified coordinates, if
+	 * possible. Does nothing if the hex is not within the world boundaries, or if
+	 * there is something already present at the hex.
+	 * 
+	 * @param sc The critter to add
+	 * @param c The column index of the hex where the critter will be added
+	 * @param r The row index of the hex where the critter will be added
+	 * @return The ID of the newly created critter
+	 */
+	int loadOneCritter(SimpleCritter sc, int c, int r, int sessionID);
+	
+	/**
+	 * Loads a single non-critter world object into the world at the specified
+	 * coordinates, if possible. Does nothing if the hex is not within the world
+	 * boundaries or if there is something already present at the hex. This method
+	 * cannot be used to add critters into the world. Use the method
+	 * {@code loadCritter(SimpleCritter sc, int c, int r)} instead.
+	 * 
+	 * @param wo The object to add
+	 * @param c The column index of the hex where the object will be added
+	 * @param r The row index of the hex where the object will be added
+	 * @return 
+	 */
+	boolean addNonCritterObject(WorldObject wo, int c, int r);
+	
+	/** Gets a list of the living critters in the world. */
+	LinkedList<SimpleCritter> getCritterList();
+	
+	/** Retrieves a list of all critters that have died in this world. */
+	LinkedList<SimpleCritter> collectCritterCorpses();
+	
 	/** Advances the world state by a single time step. */
 	void advanceOneTimeStep();
 	
+	/** Retrieves the list of updated hexes from the most recent time steps, and then empties the list. */ 
+	ArrayList<Hex> getAndResetUpdatedHexes();
+	
 	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
 	boolean isValidHex(int c, int r);
 	
@@ -57,6 +112,9 @@ public interface SimpleWorld
 	/** Returns an entry set mapping the world objects to hex locations. */
 	Set<Map.Entry<WorldObject, Hex>> getObjectMap();
 	
+	/** Removes a critter from the world. */
+	void removeCritter(SimpleCritter sc);
+	
 	/**
 	 * Returns information about a hex.
 	 * @param c
@@ -67,11 +125,49 @@ public interface SimpleWorld
 	
 	/**
 	 * Returns the critter on a hex, for analysis.
-	 * @param c
-	 * @param r
-	 * @return
+	 * @param c The column index of the hex on which the critter is located
+	 * @param r The row index of the hex on which the critter is located
+	 * @return A pointer to the critter, or {@code null} if there is no critter there
+	 * 		   (or if the provided column-row pair is not on the world grid).
 	 */
 	SimpleCritter analyzeCritter(int c, int r);
+	
+	/**
+	 * 
+	 * @param sc
+	 * @return
+	 */
+	int getCritterID(SimpleCritter sc);
+	
+	/**
+	 * 
+	 * @param id
+	 * @return
+	 */
+	SimpleCritter getCritterFromID(int id);
+	
+	/**
+	 * 
+	 * @param sc
+	 * @return
+	 */
+	int getCritterCreatorID(SimpleCritter sc);
+	
+	/**
+	 * 
+	 * @param sc
+	 * @return
+	 */
+	int[] getCritterLocation(SimpleCritter sc);
+	
+	/**
+	 * Retrieves the contents of a hex.
+	 * @param c The column index of the desired hex
+	 * @param r The row index of the desired hex
+	 * @return The world object at that hex, or {@code null} if it is empty.
+	 * 		   Also returns {@code null} if the provided column-row pair is not on the world grid.
+	 */
+	WorldObject getHexContent(int c, int r);
 
 	/** Returns a StringBuilder containing the printed version of the world grid. */
 	StringBuilder printGrid();
diff --git a/src/main/java/simulation/SmellValue.java b/src/main/java/simulation/SmellValue.java
new file mode 100644
index 0000000..7c6ff7d
--- /dev/null
+++ b/src/main/java/simulation/SmellValue.java
@@ -0,0 +1,23 @@
+package simulation;
+
+public class SmellValue {
+	/**
+	 * Distance from the root to this hex
+	 */
+	public int totalDist = Integer.MAX_VALUE;
+	
+	/**
+	 * Direction in which Dijkstra reached this hex
+	 */
+	public int orientation;
+	
+	/**
+	 * Orientation of first hex in the sequence of hexes Dijkstra traversed to get to this hex
+	 */
+	public int origin;
+	
+	/**
+	 * Number of steps Dijkstra took to get to this hex
+	 */
+	public int numSteps;
+}
diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
index ee3704d..f79ec63 100644
--- a/src/main/java/simulation/World.java
+++ b/src/main/java/simulation/World.java
@@ -4,8 +4,11 @@ import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
@@ -15,14 +18,17 @@ import java.util.Set;
 import ast.Program;
 import ast.ProgramImpl;
 import ast.Rule;
+import distributed.JSONWorldObject;
+import distributed.WorldStateJSON;
 
 /** A class to simulate the world state. */
-public class World extends AbstractWorld
-{
+public class World extends AbstractWorld {
 	/** The name of this world. */
 	private String worldname;
 	/** Contains the hex grid of the world. */
 	private Hex[][] grid;
+	/** Contains the objects of the world. */
+	private JSONWorldObject[][] objects;
 	/** Maps each critter to a location in the world. */
 	private HashMap<SimpleCritter, Hex> critterMap;
 	/** Maps each non critter object to a location in the world. */
@@ -33,49 +39,70 @@ public class World extends AbstractWorld
 	private int rows;
 	/** The number of hexes that lie on the world grid. */
 	private int numValidHexes;
+	/**
+	 * Assigned as a critter ID. Is modified every time a critter is added to ensure
+	 * uniqueness of IDs.
+	 */
+	private int critterIDcount;
+	/** Maps unique critter IDs to critters. */
+	private HashMap<Integer, SimpleCritter> IDToCritterMap;
+	/** Maps critters to their unique IDs. */
+	private HashMap<SimpleCritter, Integer> critterToIDMap;
+	/** Maps critter IDs to the session IDs that created them. */
+	private HashMap<Integer, Integer> critterCreatorMap;
 
 	/**
-	 * Loads a world based on a world description file.
+	 * Loads a world from a description.
 	 * 
-	 * @param filename The name of the file that contains world information.
-	 * @throws FileNotFoundException if the world file could not be found
-	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 * @param worlddesc
+	 *            A String description of the world.
+	 * @throws UnsupportedOperationException
+	 *             if the world constants file could not be found or was improperly
+	 *             formatted IllegalArgumentException if the {@code worlddesc} is
+	 *             invalid
 	 */
-	public World(String filename) throws FileNotFoundException, IllegalArgumentException
-	{
+	public World(String worlddesc) throws UnsupportedOperationException, IllegalArgumentException {
 		// sets constants and initializes instance fields
 		super();
 		setConstants();
 		critterMap = new HashMap<SimpleCritter, Hex>();
 		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+		critterIDcount = 1;
+		IDToCritterMap = new HashMap<Integer, SimpleCritter>();
+		critterToIDMap = new HashMap<SimpleCritter, Integer>();
+		critterCreatorMap = new HashMap<Integer, Integer>();
+		super.updatedHexes = new ArrayList<Hex>();
 		super.critterList = new LinkedList<SimpleCritter>();
+		super.deadCritters = new LinkedList<SimpleCritter>();
 		super.timePassed = 0;
 
-		BufferedReader bf = new BufferedReader(new FileReader(filename));
+		String[] lines = worlddesc.split("\r\n");
+		if (lines.length < 2)
+			throw new IllegalArgumentException();
 
 		// parses the world name, and if no valid one is parsed, supplies a default one
-		worldname = FileParser.parseAttributeFromLine(bf, "name ");
+		worldname = FileParser.parseAttributeFromLine(lines[0], "name ");
+
 		if (worldname.equals(""))
 			worldname = "Arrakis";
 
-		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
-		try
-		{
-			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
+		// parses world dimensions, and supplies default ones if no valid dimensions are
+		// parsed
+		try {
+			String worldDimensions = FileParser.parseAttributeFromLine(lines[1], "size ");
 			String[] dim = worldDimensions.split(" ");
 			columns = Integer.parseInt(dim[0]);
 			rows = Integer.parseInt(dim[1]);
 
-			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
-			{
+			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0)) {
 				columns = CONSTANTS.get("COLUMNS").intValue();
 				rows = CONSTANTS.get("ROWS").intValue();
+				System.err.println("Invalid world dimensions. Supplying default world dimensions...");
 			}
-		}
-		catch (Exception e)
-		{
+		} catch (Exception e) {
 			columns = CONSTANTS.get("COLUMNS").intValue();
 			rows = CONSTANTS.get("ROWS").intValue();
+			System.err.println("Invalid world dimensions. Supplying default world dimensions...");
 		}
 		numValidHexes = 0;
 
@@ -83,65 +110,103 @@ public class World extends AbstractWorld
 		grid = new Hex[columns][rows];
 		for (int i = 0; i < grid.length; i++)
 			for (int j = 0; j < grid[0].length; j++)
-				if (isValidHex(i, j))
-				{
+				if (isValidHex(i, j)) {
 					grid[i][j] = new Hex(i, j);
 					numValidHexes++;
+					updatedHexes.add(grid[i][j]);
 				}
 
-		try
-		{
-			// loads in world objects from file
-			String line = bf.readLine();
-			while (line != null)
-			{
-				String[] info = line.split(" ");
-				switch (info[0])
-				{
-					case "rock":
-						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
-						break;
-					case "food":
-						Food f = new Food(Integer.parseInt(info[3]));
-						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
-						break;
-					case "critter":
-						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
-						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
-								Integer.parseInt(info[4]));
-						if(sc == null)
-						{
-							System.err.println("The critter file " + filename + " does not have the right syntax, so it was not loaded.");
-							break;
-						}
-							
-						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
-						break;
+		// loads in food and rock objects from description (ignores critter additions)
+		for (int i = 2; i < lines.length; i++) {
+			String[] info = lines[i].split(" ");
+			try {
+				switch (info[0]) {
+				case "rock":
+					addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+					break;
+				case "food":
+					Food f = new Food(Integer.parseInt(info[3]));
+					addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+					break;
 				}
-				line = bf.readLine();
+			} catch (Exception e) {
+				break;
 			}
 		}
-		catch (Exception e)
-		{
-			return;
+	}
+
+	/** */
+	public World(WorldStateJSON state) throws IllegalArgumentException {
+		// sets constants and initializes instance fields
+		super();
+		setConstants();
+		critterMap = new HashMap<SimpleCritter, Hex>();
+		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+		critterIDcount = 1;
+		IDToCritterMap = new HashMap<Integer, SimpleCritter>();
+		critterToIDMap = new HashMap<SimpleCritter, Integer>();
+		critterCreatorMap = new HashMap<Integer, Integer>();
+		super.updatedHexes = new ArrayList<Hex>();
+		super.critterList = new LinkedList<SimpleCritter>();
+		super.deadCritters = new LinkedList<SimpleCritter>();
+		super.timePassed = 0;
+		
+		columns = state.getCols();
+		rows = state.getRows();
+		worldname = state.getName();
+		numValidHexes = 0;
+		
+		// initializes world grid
+		grid = new Hex[columns][rows];
+		objects = new JSONWorldObject[columns][rows];
+		for (int i = 0; i < grid.length; i++)
+			for (int j = 0; j < grid[0].length; j++)
+				if (isValidHex(i, j)) {
+					grid[i][j] = new Hex(i, j);
+					numValidHexes++;
+					updatedHexes.add(grid[i][j]);
+				}
+		
+		for(JSONWorldObject obj : state.getWorldObjects()) {
+			objects[obj.getCol()][obj.getRow()] = obj;
+			if(obj.getType().equals("critter")) {
+				int[] mem = obj.getMemory();
+				String name = obj.getSpeciesName();
+				int dir = obj.getOrientation();
+				loadOneCritter(new Critter(null, mem, name, dir), obj.getCol(), obj.getRow(), -1);
+			} else if(obj.getType().equals("rock")) {
+				addNonCritterObject(new Rock(), obj.getCol(), obj.getRow());
+			} else if(obj.getType().equals("food")) {
+				Food f = new Food(obj.getCalories());
+				addNonCritterObject(f, obj.getCol(), obj.getRow());
+			}
 		}
 	}
 
 	/**
-	 * Loads a world from a world description file, in the form of a pre-determined file.
+	 * Loads a world from a world description file, in the form of a pre-determined
+	 * file.
 	 * 
-	 * @param filename The name of the file that contains world information.
-	 * @throws FileNotFoundException if the world file could not be found
-	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 * @param file
+	 *            The file that contains world information.
+	 * @throws FileNotFoundException
+	 *             if the world file could not be found
+	 *             UnsupportedOperationException if the world constants file could
+	 *             not be found or was improperly formatted
 	 */
-	public World(File file) throws FileNotFoundException, IllegalArgumentException
-	{
+	public World(File file) throws FileNotFoundException, IllegalArgumentException {
 		// sets constants and initializes instance fields
 		super();
 		setConstants();
 		critterMap = new HashMap<SimpleCritter, Hex>();
 		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+		critterIDcount = 1;
+		IDToCritterMap = new HashMap<Integer, SimpleCritter>();
+		critterToIDMap = new HashMap<SimpleCritter, Integer>();
+		critterCreatorMap = new HashMap<Integer, Integer>();
+		super.updatedHexes = new ArrayList<Hex>();
 		super.critterList = new LinkedList<SimpleCritter>();
+		super.deadCritters = new LinkedList<SimpleCritter>();
 		super.timePassed = 0;
 
 		BufferedReader bf = new BufferedReader(new FileReader(file));
@@ -151,90 +216,94 @@ public class World extends AbstractWorld
 		if (worldname.equals(""))
 			worldname = "Arrakis";
 
-		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
-		try
-		{
+		// parses world dimensions, and supplies default ones if no valid dimensions are
+		// parsed
+		try {
 			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
 			String[] dim = worldDimensions.split(" ");
 			columns = Integer.parseInt(dim[0]);
 			rows = Integer.parseInt(dim[1]);
 
-			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
-			{
+			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0)) {
 				columns = CONSTANTS.get("COLUMNS").intValue();
 				rows = CONSTANTS.get("ROWS").intValue();
+				System.err.println("Invalid world dimensions. Supplying default world dimensions...");
 			}
-		}
-		catch (Exception e)
-		{
+		} catch (Exception e) {
 			columns = CONSTANTS.get("COLUMNS").intValue();
 			rows = CONSTANTS.get("ROWS").intValue();
+			System.err.println("Invalid world dimensions. Supplying default world dimensions...");
 		}
 		numValidHexes = 0;
-
 		// initializes world grid
 		grid = new Hex[columns][rows];
 		for (int i = 0; i < grid.length; i++)
 			for (int j = 0; j < grid[0].length; j++)
-				if (isValidHex(i, j))
-				{
+				if (isValidHex(i, j)) {
 					grid[i][j] = new Hex(i, j);
 					numValidHexes++;
+					updatedHexes.add(grid[i][j]);
 				}
 
-		try
-		{
+		try {
 			// loads in world objects from file
 			String line = bf.readLine();
-			while (line != null)
-			{
+			while (line != null) {
 				String[] info = line.split(" ");
-				switch (info[0])
-				{
-					case "rock":
-						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
-						break;
-					case "food":
-						Food f = new Food(Integer.parseInt(info[3]));
-						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
-						break;
-					case "critter":
-						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
-						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
-								Integer.parseInt(info[4]));
-						if(sc == null)
-						{
-							System.err.println("The critter file " + file.toString() + " does not have the right syntax, so it was not loaded.");
-							break;
-						}
-							
-						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
+				switch (info[0]) {
+				case "rock":
+					addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+					break;
+				case "food":
+					Food f = new Food(Integer.parseInt(info[3]));
+					addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+					break;
+				case "critter":
+					BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
+					SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
+							Integer.parseInt(info[4]));
+					if (sc == null) {
+						System.err.println("The critter file " + file.toString()
+								+ " does not have the right syntax, so it was not loaded.");
 						break;
+					}
+
+					loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]), -1);
+					break;
 				}
 				line = bf.readLine();
 			}
-		}
-		catch (Exception e)
-		{
+		} catch (FileNotFoundException e) {
+			System.out.println("Critter file not found.");
+			return;
+		} catch (IOException e) {
+			return;
+		} catch (Exception e) {
 			return;
 		}
 	}
+
 	/**
 	 * Generates a default size world containing nothing but randomly placed rocks.
-	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             if the world constants file could not be found or was improperly
+	 *             formatted
 	 */
-	public World() throws IllegalArgumentException
-	{
+	public World() throws UnsupportedOperationException {
 		// sets constants and initializes instance fields
 		super();
 		worldname = "Arrakis";
 		setConstants();
 		critterMap = new HashMap<SimpleCritter, Hex>();
 		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
-		critterList = new LinkedList<SimpleCritter>();
-		timePassed = 0;
-
+		critterIDcount = 1;
+		IDToCritterMap = new HashMap<Integer, SimpleCritter>();
+		critterToIDMap = new HashMap<SimpleCritter, Integer>();
+		critterCreatorMap = new HashMap<Integer, Integer>();
+		super.updatedHexes = new ArrayList<Hex>();
 		super.critterList = new LinkedList<SimpleCritter>();
+		super.deadCritters = new LinkedList<SimpleCritter>();
 		super.timePassed = 0;
 
 		columns = CONSTANTS.get("COLUMNS").intValue();
@@ -243,12 +312,11 @@ public class World extends AbstractWorld
 
 		grid = new Hex[columns][rows];
 		for (int i = 0; i < grid.length; i++)
-			for (int j = 0; j < grid[0].length; j++)
-			{
-				if (isValidHex(i, j))
-				{
+			for (int j = 0; j < grid[0].length; j++) {
+				if (isValidHex(i, j)) {
 					grid[i][j] = new Hex(i, j);
 					numValidHexes++;
+					updatedHexes.add(grid[i][j]);
 				}
 			}
 
@@ -256,12 +324,10 @@ public class World extends AbstractWorld
 		int c = (int) (Math.random() * columns);
 		int r = (int) (Math.random() * rows);
 		int n = 0;
-		while (n < numValidHexes / 40)
-		{
+		while (n < numValidHexes / 40) {
 			c = (int) (Math.random() * columns);
 			r = (int) (Math.random() * rows);
-			if (isValidHex(c, r))
-			{
+			if (isValidHex(c, r) && grid[c][r].isEmpty()) {
 				addNonCritterObject(new Rock(), c, r);
 				n++;
 			}
@@ -269,36 +335,39 @@ public class World extends AbstractWorld
 	}
 
 	/**
-	 * Parses the constants file in the project directory and stores the constants in the CONSTANTS field.
-	 * @throws IllegalArgumentException if the constants file couldn't be found or is improperly formatted
+	 * Parses the constants file in the project directory and stores the constants
+	 * in the CONSTANTS field.
+	 * 
+	 * @throws UnsupportedOperationException
+	 *             if the constants file couldn't be found or is improperly
+	 *             formatted
 	 */
-	private void setConstants() throws IllegalArgumentException
-	{
+	private void setConstants() throws UnsupportedOperationException {
 		InputStream in = World.class.getClassLoader().getResourceAsStream("simulation/constants.txt");
-		if(in == null)
-		{ 
-			throw new IllegalArgumentException();
-		}
-		
+		if (in == null)
+			throw new UnsupportedOperationException();
+
 		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
 		CONSTANTS = FileParser.parseConstants(bf);
 	}
 
 	@Override
-	public int getColumns()
-	{
+	public int getColumns() {
 		return columns;
 	}
-	
+
 	@Override
-	public int getRows()
-	{
+	public int getRows() {
 		return rows;
 	}
-	
+
+	@Override
+	public String getWorldName() {
+		return worldname;
+	}
+
 	@Override
-	public boolean isValidHex(int c, int r)
-	{
+	public boolean isValidHex(int c, int r) {
 		if (c < 0 || r < 0)
 			return false;
 		else if (c >= columns || r >= rows)
@@ -309,120 +378,128 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public synchronized void loadCritters(String filename, int n, int direction)
-	{
-		try
-		{
-			BufferedReader br = new BufferedReader(new FileReader(filename));
-			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
-
-			for (int i = 0; i < n; i++)
-			{
-
+	public void loadCritters(String filename, int n, int direction) {
+		try {
+			for (int i = 0; i < n; i++) {
+				if (i >= numValidHexes - (critterList.size() + nonCritterObjectMap.size()))
+					break;
+				BufferedReader br = new BufferedReader(new FileReader(filename));
+				SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
 				int randc = (int) (Math.random() * columns);
 				int randr = (int) (Math.random() * rows);
-				while (!isValidHex(randc, randr))
-				{
+				while (!isValidHex(randc, randr) || !grid[randc][randr].isEmpty()) {
 					randc = (int) (Math.random() * columns);
 					randr = (int) (Math.random() * rows);
 				}
 
 				if (isValidHex(randc, randr))
-					loadOneCritter(sc, randc, randr);
+					loadOneCritter(sc, randc, randr, -1);
 			}
-		}
-		catch (FileNotFoundException e)
-		{
+		} catch (FileNotFoundException e) {
 			System.err.println("Critter file not found.");
 			return;
 		}
 	}
 
 	@Override
-	public void loadCritters(File file, int n, int direction)
-	{
-		try
-		{
-			BufferedReader br = new BufferedReader(new FileReader(file));
-			//SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
-
-			for (int i = 0; i < n; i++)
-			{
+	public void loadCritters(File file, int n, int direction) {
+		try {
+			for (int i = 0; i < n; i++) {
+				if (i >= numValidHexes - (critterList.size() + nonCritterObjectMap.size()))
+					break;
+				BufferedReader br = new BufferedReader(new FileReader(file));
 				SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
+				if (sc == null) {
+					return;
+				}
 				int randc = (int) (Math.random() * columns);
 				int randr = (int) (Math.random() * rows);
-				while (!isValidHex(randc, randr))
-				{
+				while (!isValidHex(randc, randr) || !grid[randc][randr].isEmpty()) {
 					randc = (int) (Math.random() * columns);
 					randr = (int) (Math.random() * rows);
 				}
 
 				if (isValidHex(randc, randr))
-					loadOneCritter(sc, randc, randr);
+					loadOneCritter(sc, randc, randr, -1);
 			}
-		}
-		catch (FileNotFoundException e)
-		{
+		} catch (FileNotFoundException e) {
 			System.err.println("Critter file not found.");
 			return;
 		}
 	}
-	
+
+	@Override
+	public int[] loadCritters(SimpleCritter sc, int n, int sessionID) {
+		int[] result = new int[n];
+		Program scProgram = sc.getProgram();
+		int[] scMem = sc.getMemoryCopy();
+		String scId = sc.getName();
+		int scDir = sc.getOrientation();
+		Arrays.fill(result, -1);
+		for (int i = 0; i < n; i++) {
+			if (i >= numValidHexes - (critterList.size() + nonCritterObjectMap.size()))
+				break;
+			int randc = (int) (Math.random() * columns);
+			int randr = (int) (Math.random() * rows);
+			while (!isValidHex(randc, randr) || !grid[randc][randr].isEmpty()) {
+				randc = (int) (Math.random() * columns);
+				randr = (int) (Math.random() * rows);
+			}
+
+			if (isValidHex(randc, randr)) {
+				SimpleCritter holder = new Critter(scProgram, scMem, scId, scDir);
+				result[i] = loadOneCritter(holder, randc, randr, sessionID);
+			}
+		}
+		return result;
+	}
+
 	@Override
-	public void loadCritterAtLocation(File file, int c, int r)
-	{
-		try
-		{
+	public void loadCritterAtLocation(File file, int c, int r) {
+		try {
 			BufferedReader br = new BufferedReader(new FileReader(file));
 			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), -1);
-			if(isValidHex(c, r))
-				loadOneCritter(sc, c, r);
-		}
-		catch (FileNotFoundException e)
-		{
+			if (isValidHex(c, r))
+				loadOneCritter(sc, c, r, -1);
+		} catch (FileNotFoundException e) {
 			System.err.println("Critter file not found.");
 			return;
 		}
 	}
-	
-	/**
-	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
-	 * the hex is not within the world boundaries, or if there is something already present at the hex.
-	 * 
-	 * @param sc the critter to add
-	 * @param c the column index of the hex where the critter will be added
-	 * @param r the row index of the hex where the critter will be added
-	 */
-	private void loadOneCritter(SimpleCritter sc, int c, int r)
-	{
+
+	@Override
+	public int loadOneCritter(SimpleCritter sc, int c, int r, int sessionID) {
 		if (!isValidHex(c, r))
-			return;
+			return -1;
+		int result;
+		sc.randomizeOrientation();
 		boolean added = grid[c][r].addContent(sc);
-		if (added)
-		{
+		if (added) {
 			critterList.add(sc);
 			critterMap.put(sc, grid[c][r]);
+			updatedHexes.add(grid[c][r]);
+			result = critterIDcount;
+			IDToCritterMap.put(critterIDcount, sc);
+			critterToIDMap.put(sc, critterIDcount);
+			if (sessionID > 0)
+				critterCreatorMap.put(critterIDcount, sessionID);
+			critterIDcount++;
+		} else {
+			result = -1;
 		}
+		return result;
 	}
 
-	/**
-	 * Loads a single non-critter world object into the world at the specified coordinates, if possible.
-	 * Does nothing if the hex is not within the world boundaries or if there is something already present at
-	 * the hex. This method cannot be used to add critters into the world. Use the method
-	 * {@code loadCritter(SimpleCritter sc, int c, int r)} instead.
-	 * 
-	 * @param sc the object to add
-	 * @param c the column index of the hex where the object will be added
-	 * @param r the row index of the hex where the object will be added
-	 */
-	private void addNonCritterObject(WorldObject wo, int c, int r)
-	{
+	@Override
+	public boolean addNonCritterObject(WorldObject wo, int c, int r) {
 		if (wo instanceof Critter)
-			return;
+			return false;
 		if (!isValidHex(c, r))
-			return;
+			return false;
 		nonCritterObjectMap.put(wo, grid[c][r]);
-		grid[c][r].addContent(wo);
+		boolean isValid = grid[c][r].addContent(wo);
+		updatedHexes.add(grid[c][r]);
+		return isValid;
 	}
 
 	/* ========================================= */
@@ -430,13 +507,12 @@ public class World extends AbstractWorld
 	/* ========================================= */
 
 	@Override
-	public int searchNearby(SimpleCritter sc, int dir)
-	{
-		//determines the row and column coordinates of the critter
+	public int searchNearby(SimpleCritter sc, int dir) {
+		// determines the row and column coordinates of the critter
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
-		
+
 		// finds the hex to look in, based on the value of dir
 		if (dir < 0)
 			dir = 0;
@@ -453,13 +529,12 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public int searchAhead(SimpleCritter sc, int index)
-	{
-		//determines the row and column coordinates of the critter
+	public int searchAhead(SimpleCritter sc, int index) {
+		// determines the row and column coordinates of the critter
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
-		
+
 		if (index < 0)
 			index = 0;
 		int aheadc = c + sc.changeInPosition(true, sc.getOrientation())[0] * index;
@@ -471,13 +546,129 @@ public class World extends AbstractWorld
 		return nearby.hexAppearance();
 	}
 
+	@Override
+	public int smell(SimpleCritter sc) {
+		int direction = 0;
+		int distance = 1000;
+		ArrayList<SmellValue> foodList = new ArrayList<SmellValue>();
+
+		// adds all the possible hexes to be used in method to a hash map
+		Hex root = critterMap.get(sc);
+		HashMap<Hex, SmellValue> graph = new HashMap<Hex, SmellValue>();
+		for (int i = 0; i < grid.length; i++) {
+			for (int j = 0; j < grid[i].length; j++) {
+				if (isValidHex(i, j)) {
+					if (grid[i][j] == root || grid[i][j].hexAppearance() == 0 || grid[i][j].hexAppearance() < -1) {
+						SmellValue sv = new SmellValue();
+						graph.put(grid[i][j], sv);
+						if (grid[i][j].hexAppearance() < -1) {
+							foodList.add(sv);
+						}
+					}
+				}
+			}
+		}
+
+		ArrayList<Hex> visitedHexes = new ArrayList<>();
+		
+		// sets up critter's smellValue for smell function
+		SmellValue rootSmell = graph.get(root);
+		rootSmell.totalDist = 0;
+		rootSmell.orientation = sc.getOrientation();
+		rootSmell.numSteps = 0;
+
+		// sets up priority queue
+		AdjustablePriorityQueue<Hex> frontier = new AdjustablePriorityQueue<Hex>();
+		frontier.add(root);
+		frontier.setPriority(root, 0);
+
+		boolean initialIteration = true;
+		while (!frontier.isEmpty()) {
+			// pops hex from priority queue
+			Hex curr = frontier.remove();
+			visitedHexes.add(curr);
+			SmellValue currSmell = graph.get(curr);
+
+			if (foodList.contains(currSmell)) {
+				continue; // TODO remove this optimization to smell if it makes things break
+			}
+
+			int c = curr.getColumnIndex();
+			int r = curr.getRowIndex();
+
+			// find neighbor hexes if they exist
+			Hex[] neighbors = new Hex[6];
+			if (isValidHex(c, r + 1))
+				neighbors[0] = grid[c][r + 1];
+			if (isValidHex(c + 1, r + 1))
+				neighbors[1] = grid[c + 1][r + 1];
+			if (isValidHex(c + 1, r))
+				neighbors[2] = grid[c + 1][r];
+			if (isValidHex(c, r - 1))
+				neighbors[3] = grid[c][r - 1];
+			if (isValidHex(c - 1, r - 1))
+				neighbors[4] = grid[c - 1][r - 1];
+			if (isValidHex(c - 1, r))
+				neighbors[5] = grid[c - 1][r];
+
+			// apply an iteration of Dijkstra's algorithm
+			for (int i = 0; i < neighbors.length; i++) {
+				SmellValue sv = graph.get(neighbors[i]);
+				if (sv != null) {
+					boolean isFood = foodList.contains(sv);
+
+					// moves on to the next hex if it has taken 11 steps to reach new hex (or 12 in
+					// the case of food)
+					if (currSmell.numSteps == (isFood ? 11 : 10)) {
+						continue;
+					}
+
+					int newDistance = currSmell.totalDist;
+					if (!isFood) {
+						newDistance += calculateSmellWeight(currSmell, sv);
+					}
+					if (sv.totalDist == Integer.MAX_VALUE) {
+						sv.totalDist = newDistance;
+						sv.origin = initialIteration ? i : currSmell.origin;
+						sv.numSteps = currSmell.numSteps + 1;
+						frontier.add(neighbors[i]);
+						frontier.setPriority(neighbors[i], sv.totalDist);
+					} else if (!visitedHexes.contains(neighbors[i])) {
+						sv.totalDist = Math.min(sv.totalDist, newDistance);
+						if (sv.totalDist == newDistance) {
+							sv.origin = initialIteration ? i : currSmell.origin;
+							sv.numSteps = currSmell.numSteps + 1;
+						}
+						frontier.setPriority(neighbors[i], sv.totalDist);
+					}
+				}
+			}
+
+			initialIteration = false;
+		}
+
+		// finds closest food
+		for (SmellValue sv : foodList) {
+			distance = Math.min(distance, sv.totalDist);
+			if (distance == sv.totalDist) {
+				direction = sv.origin;
+			}
+		}
+		return distance * 1000 + direction;
+	}
+
+	private int calculateSmellWeight(SmellValue a, SmellValue b) {
+		int x = a.orientation;
+		int y = b.orientation;
+		return Math.min(Math.abs(x - y), 6 - Math.abs(x - y)) + 1;
+	}
+
 	/* ========================================= */
 	/* ----------- Critter Actions ------------- */
 	/* ========================================= */
 
 	@Override
-	public void moveCritter(SimpleCritter sc, boolean forward)
-	{
+	public void moveCritter(SimpleCritter sc, boolean forward) {
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
@@ -485,9 +676,9 @@ public class World extends AbstractWorld
 		int cost = CONSTANTS.get("MOVE_COST").intValue() * sc.size();
 		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		// if the critter did not have enough energy to complete this action, kills the critter
-		if (sc.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (sc.getEnergy() < 0) {
 			kill(sc);
 			return;
 		}
@@ -496,41 +687,41 @@ public class World extends AbstractWorld
 		int newc = c + changeInCoords[0];
 		int newr = r + changeInCoords[1];
 
-		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
-		{
+		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty()) {
 			if (sc.getEnergy() == 0)
 				kill(sc);
 			return;
 		}
 		grid[c][r].removeContent();
 		critterMap.remove(sc);
+		updatedHexes.add(grid[c][r]);
 		grid[newc][newr].addContent(sc);
 		critterMap.put(sc, grid[newc][newr]);
+		updatedHexes.add(grid[newc][newr]);
 		if (sc.getEnergy() == 0)
 			kill(sc);
 	}
 
 	@Override
-	public void turnCritter(SimpleCritter sc, boolean clockwise)
-	{
+	public void turnCritter(SimpleCritter sc, boolean clockwise) {
 		int cost = sc.size();
 		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		// if the critter did not have enough energy to complete this action, kills the critter
-		if (sc.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (sc.getEnergy() < 0) {
 			kill(sc);
 			return;
 		}
 
 		sc.turn(clockwise);
+		updatedHexes.add(critterMap.get(sc));
 		if (sc.getEnergy() == 0)
 			kill(sc);
 	}
 
 	@Override
-	public void critterEat(SimpleCritter sc)
-	{
+	public void critterEat(SimpleCritter sc) {
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
@@ -538,55 +729,53 @@ public class World extends AbstractWorld
 		int cost = sc.size();
 		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		// if the critter did not have enough energy to complete this action, kills the critter
-		if (sc.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (sc.getEnergy() < 0) {
 			kill(sc);
 			return;
 		}
 
 		int newc = c + sc.changeInPosition(true, sc.getOrientation())[0];
 		int newr = r + sc.changeInPosition(true, sc.getOrientation())[1];
-		if (!isValidHex(newc, newr))
-		{
+		if (!isValidHex(newc, newr)) {
 			if (sc.getEnergy() == 0)
 				kill(sc);
 			return;
 		}
 
 		Hex directlyInFront = grid[newc][newr];
-		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof Food)
-		{
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof Food) {
 			Food nourishment = (Food) directlyInFront.getContent();
 			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 			nonCritterObjectMap.remove(nourishment);
 			directlyInFront.removeContent();
+			updatedHexes.add(directlyInFront);
 		}
 		if (sc.getEnergy() == 0)
 			kill(sc);
 	}
 
 	@Override
-	public void growCritter(SimpleCritter sc)
-	{
+	public void growCritter(SimpleCritter sc) {
 		int cost = sc.size()
 				* sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
 		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		// if the critter did not have enough energy to complete this action, kills the critter
-		if (sc.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (sc.getEnergy() < 0) {
 			kill(sc);
 			return;
 		}
 
 		int currentSize = sc.readMemory(3);
 		sc.setMemory(currentSize + 1, 3);
+		updatedHexes.add(critterMap.get(sc));
 	}
 
 	@Override
-	public void critterBattle(SimpleCritter attacker)
-	{
+	public void critterBattle(SimpleCritter attacker) {
 		Hex location = critterMap.get(attacker);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
@@ -594,33 +783,33 @@ public class World extends AbstractWorld
 		int cost = attacker.size() * CONSTANTS.get("ATTACK_COST").intValue();
 		attacker.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		//if the critter did not have enough energy to complete this action, kills the critter
-		if (attacker.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (attacker.getEnergy() < 0) {
 			kill(attacker);
 			return;
 		}
 
 		int newc = c + attacker.changeInPosition(true, attacker.getOrientation())[0];
 		int newr = r + attacker.changeInPosition(true, attacker.getOrientation())[1];
-		if (!isValidHex(newc, newr))
-		{
+		if (!isValidHex(newc, newr)) {
 			if (attacker.getEnergy() == 0)
 				kill(attacker);
 			return;
 		}
 
 		Hex directlyInFront = grid[newc][newr];
-		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
-		{
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter) {
 			// Calculates the damage dealt to the target critter
 			SimpleCritter target = (SimpleCritter) (directlyInFront.getContent());
 			int baseDamage = CONSTANTS.get("BASE_DAMAGE").intValue();
 			double dmgMultiplier = CONSTANTS.get("DAMAGE_INC").doubleValue();
 			int dmgBeforeScaling = (attacker.size() * attacker.readMemory(2)) - (target.size() * target.readMemory(1));
-			int damage = baseDamage * attacker.size() * logisticFunction(dmgMultiplier * (double)dmgBeforeScaling);
+			int damage = (int) (baseDamage * attacker.size()
+					* logisticFunction(dmgMultiplier * (double) dmgBeforeScaling));
 
-			// kills the target if it took damage greater than or equal to its current energy
+			// kills the target if it took damage greater than or equal to its current
+			// energy
 			target.updateEnergy(-1 * damage, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 			if (target.getEnergy() <= 0)
 				kill(target);
@@ -630,16 +819,17 @@ public class World extends AbstractWorld
 			kill(attacker);
 	}
 
-	/** Performs the logistic function 1 / (1 + e^-x), floored to an integer value. */
-	private int logisticFunction(double x)
-	{
+	/**
+	 * Applies the logistic function, {@code f(x) = 1 / (1 + e^-x)}, to the given
+	 * number.
+	 */
+	private double logisticFunction(double x) {
 		double exponent = -1 * x;
-		return (int) (1 / (1 + Math.exp(exponent)));
+		return (1 / (1 + Math.exp(exponent)));
 	}
 
 	@Override
-	public void critterBud(SimpleCritter sc)
-	{
+	public void critterBud(SimpleCritter sc) {
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
@@ -648,23 +838,23 @@ public class World extends AbstractWorld
 		sc.updateEnergy(-1 * CONSTANTS.get("BUD_COST").intValue() * complexity,
 				CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		//if the critter did not have enough energy to complete this action, kills the critter
-		if (sc.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (sc.getEnergy() < 0) {
 			kill(sc);
 			return;
 		}
 
 		int newc = c + sc.changeInPosition(false, sc.getOrientation())[0];
 		int newr = r + sc.changeInPosition(false, sc.getOrientation())[1];
-		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
-		{
+		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty()) {
 			if (sc.getEnergy() == 0)
 				kill(sc);
 			return;
 		}
 
-		//Constructs the baby critter's memory, copying memory length, offense, and defense from the parent
+		// Constructs the baby critter's memory, copying memory length, offense, and
+		// defense from the parent
 		int[] babymem = new int[sc.getMemLength()];
 		babymem[0] = sc.getMemLength();
 		babymem[1] = sc.readMemory(1);
@@ -674,52 +864,50 @@ public class World extends AbstractWorld
 		for (int i = 5; i < babymem.length; i++)
 			babymem[i] = 0;
 
-		String name = sc.getName() + " Jr.";
+		String name = sc.getName();
 		Program prog = sc.getProgram();
 		int numMutations = numberMutations();
-		for (int i = 0; i < numMutations; i++)
+		for (int i = 0; i < numMutations; i++) {
 			prog = prog.mutate();
+		}
 
 		SimpleCritter baby = new Critter(prog, babymem, name, sc.getOrientation());
-		loadOneCritter(baby, newc, newr);
+		Integer parentCreatorID = critterCreatorMap.get(critterToIDMap.get(sc));
+		int babyCreatorID = parentCreatorID == null ? -1 : parentCreatorID;
+		loadOneCritter(baby, newc, newr, babyCreatorID);
 
 		if (sc.getEnergy() == 0)
 			kill(sc);
 	}
 
 	@Override
-	public void critterMate(SimpleCritter sc)
-	{
+	public void critterMate(SimpleCritter sc) {
 		sc.toggleMatingPheromones(true);
 		Hex location = critterMap.get(sc);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
 		int behindColumnParent1 = c + sc.changeInPosition(false, sc.getOrientation())[0];
 		int behindRowParent1 = r + sc.changeInPosition(false, sc.getOrientation())[1];
-		if (!isValidHex(behindColumnParent1, behindRowParent1))
-		{
+		if (!isValidHex(behindColumnParent1, behindRowParent1)) {
 			sc.toggleMatingPheromones(false);
 			return;
 		}
 		// coordinates of Parent 2
 		int columnParent2 = c + sc.changeInPosition(true, sc.getOrientation())[0];
 		int rowParent2 = r + sc.changeInPosition(true, sc.getOrientation())[1];
-		if (!isValidHex(columnParent2, rowParent2))
-		{
+		if (!isValidHex(columnParent2, rowParent2)) {
 			sc.toggleMatingPheromones(false);
 			return;
 		}
 		Hex directlyInFront = grid[columnParent2][rowParent2];
-		if (!(directlyInFront.getContent() instanceof SimpleCritter))
-		{
+		if (!(directlyInFront.getContent() instanceof SimpleCritter)) {
 			sc.toggleMatingPheromones(false);
 			return;
 		}
 		SimpleCritter parent2 = (SimpleCritter) (directlyInFront.getContent());
 		int behindColumnParent2 = columnParent2 + sc.changeInPosition(false, sc.getOrientation())[0];
 		int behindRowParent2 = rowParent2 + sc.changeInPosition(false, sc.getOrientation())[1];
-		if (!isValidHex(behindColumnParent2, behindRowParent2))
-		{
+		if (!isValidHex(behindColumnParent2, behindRowParent2)) {
 			sc.toggleMatingPheromones(false);
 			return;
 		}
@@ -730,8 +918,7 @@ public class World extends AbstractWorld
 		int parent2Direction = parent2.getOrientation();
 
 		// direction checking
-		if (!(Math.abs(parent1Direction - parent2Direction) == 3))
-		{
+		if (!(Math.abs(parent1Direction - parent2Direction) == 3)) {
 			sc.toggleMatingPheromones(false);
 			return;
 		}
@@ -739,8 +926,7 @@ public class World extends AbstractWorld
 		// energy calculation
 		sc.updateEnergy(-sc.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 		parent2.updateEnergy(-parent2.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
-		if (sc.getEnergy() < 0 || parent2.getEnergy() < 0)
-		{
+		if (sc.getEnergy() < 0 || parent2.getEnergy() < 0) {
 			if (sc.getEnergy() < 0)
 				kill(sc);
 			if (parent2.getEnergy() < 0)
@@ -750,15 +936,16 @@ public class World extends AbstractWorld
 		initiateMatingProcess(sc, parent2);
 	}
 
-	/** Randomly determines the number of mutations that will occur during mating or budding. */
-	private int numberMutations()
-	{
+	/**
+	 * Randomly determines the number of mutations that will occur during mating or
+	 * budding.
+	 */
+	private int numberMutations() {
 		double randomNumber = Math.random();
 		int returnValue = 0;
 		double temp = 0.25;
 
-		for (int i = 0; i < 10; i++)
-		{
+		for (int i = 0; i < 10; i++) {
 			if (randomNumber < temp)
 				returnValue++;
 			temp = Math.pow(0.25, i + 1);
@@ -766,9 +953,11 @@ public class World extends AbstractWorld
 		return returnValue;
 	}
 
-	/** Executes the mating process, as long as there is one empty hex around the two critters. */
-	private void initiateMatingProcess(SimpleCritter sc1, SimpleCritter sc2)
-	{
+	/**
+	 * Executes the mating process, as long as there is one empty hex around the two
+	 * critters.
+	 */
+	private void initiateMatingProcess(SimpleCritter sc1, SimpleCritter sc2) {
 		Random random = new Random();
 		// energy calculation
 		int complexity1 = sc1.complexity(CONSTANTS.get("RULE_COST").intValue(),
@@ -777,8 +966,7 @@ public class World extends AbstractWorld
 				CONSTANTS.get("ABILITY_COST").intValue());
 		sc1.updateEnergy(-5 * complexity1, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 		sc2.updateEnergy(-5 * complexity2, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
-		if (sc1.getEnergy() < 0 || sc2.getEnergy() < 0)
-		{
+		if (sc1.getEnergy() < 0 || sc2.getEnergy() < 0) {
 			if (sc1.getEnergy() < 0)
 				kill(sc1);
 			if (sc2.getEnergy() < 0)
@@ -793,17 +981,13 @@ public class World extends AbstractWorld
 			ruleSetSize = sc1.getProgram().getRulesList().size();
 		else
 			ruleSetSize = sc2.getProgram().getRulesList().size();
-		for (int i = 0; i < ruleSetSize; i++)
-		{
-			if (random.nextBoolean())
-			{
+		for (int i = 0; i < ruleSetSize; i++) {
+			if (random.nextBoolean()) {
 				if (i >= sc1.getProgram().getRulesList().size())
 					babyRules.add(sc2.getProgram().getRulesList().get(i));
 				else
 					babyRules.add(sc1.getProgram().getRulesList().get(i));
-			}
-			else
-			{
+			} else {
 				if (i >= sc2.getProgram().getRulesList().size())
 					babyRules.add(sc1.getProgram().getRulesList().get(i));
 				else
@@ -812,20 +996,16 @@ public class World extends AbstractWorld
 		}
 		Program prog = new ProgramImpl(babyRules);
 
-		//generating memory
+		// generate memory
 		int[] babymem = null;
-		if (random.nextBoolean())
-		{
+		if (random.nextBoolean()) {
 			babymem = new int[sc1.getMemLength()];
 			babymem[0] = sc1.getMemLength();
-		}
-		else
-		{
+		} else {
 			babymem = new int[sc2.getMemLength()];
 			babymem[0] = sc2.getMemLength();
 		}
-		for (int i = 1; i <= 2; i++)
-		{
+		for (int i = 1; i <= 2; i++) {
 			if (random.nextBoolean())
 				babymem[i] = sc1.readMemory(i);
 			else
@@ -836,17 +1016,14 @@ public class World extends AbstractWorld
 		for (int i = 5; i < babymem.length; i++)
 			babymem[i] = 0;
 
-		// coordinate Generation
+		// generate coordinates
 		int babyColumn = 0;
 		int babyRow = 0;
-		if (random.nextBoolean())
-		{
+		if (random.nextBoolean()) {
 			Hex location = critterMap.get(sc1);
 			babyColumn = location.getColumnIndex() + sc1.changeInPosition(false, sc1.getOrientation())[0];
 			babyRow = location.getRowIndex() + sc1.changeInPosition(false, sc1.getOrientation())[1];
-		}
-		else
-		{
+		} else {
 			Hex location = critterMap.get(sc2);
 			babyColumn = location.getColumnIndex() + sc2.changeInPosition(false, sc2.getOrientation())[0];
 			babyRow = location.getRowIndex() + sc2.changeInPosition(false, sc2.getOrientation())[1];
@@ -855,12 +1032,14 @@ public class World extends AbstractWorld
 		int numMutations = numberMutations();
 		for (int i = 0; i < numMutations; i++)
 			prog = prog.mutate();
-		String name = sc1.getName() + sc2.getName() + " Jr.";
+		String name = random.nextBoolean() ? sc1.getName() : sc2.getName();
+		Integer parentCreatorID = random.nextBoolean() ? critterCreatorMap.get(critterToIDMap.get(sc1))
+				: critterCreatorMap.get(critterToIDMap.get(sc2));
+		int babyCreatorID = parentCreatorID == null ? -1 : parentCreatorID;
 		SimpleCritter baby = new Critter(prog, babymem, name, 0);
-		loadOneCritter(baby, babyColumn, babyRow);
+		loadOneCritter(baby, babyColumn, babyRow, babyCreatorID);
 
-		if (sc1.getEnergy() == 0 || sc2.getEnergy() == 0)
-		{
+		if (sc1.getEnergy() == 0 || sc2.getEnergy() == 0) {
 			if (sc1.getEnergy() == 0)
 				kill(sc1);
 			if (sc2.getEnergy() == 0)
@@ -872,36 +1051,33 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public void critterTag(SimpleCritter tagger, int val)
-	{
+	public void critterTag(SimpleCritter tagger, int val) {
 		Hex location = critterMap.get(tagger);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
 
 		tagger.updateEnergy(-1 * tagger.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		//if the critter did not have enough energy to complete this action, kills the critter
-		if (tagger.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (tagger.getEnergy() < 0) {
 			kill(tagger);
 			return;
 		}
 
 		int newc = c + tagger.changeInPosition(true, tagger.getOrientation())[0];
 		int newr = r + tagger.changeInPosition(true, tagger.getOrientation())[1];
-		if (!isValidHex(newc, newr))
-		{
+		if (!isValidHex(newc, newr)) {
 			if (tagger.getEnergy() == 0)
 				kill(tagger);
 			return;
 		}
 
 		Hex directlyInFront = grid[newc][newr];
-		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
-		{
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter) {
 			SimpleCritter taggee = (SimpleCritter) (directlyInFront.getContent());
 			if (!(val < 0 || val > 99))
-				taggee.setMemory(val, 6);
+				taggee.setTag(val);
 		}
 
 		if (tagger.getEnergy() == 0)
@@ -909,59 +1085,60 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public void critterServe(SimpleCritter donator, int index)
-	{
+	public void critterServe(SimpleCritter donator, int index) {
 		Hex location = critterMap.get(donator);
 		int c = location.getColumnIndex();
 		int r = location.getRowIndex();
 
 		if (index < 0)
 			index = 0;
-		else if(index > donator.getEnergy() + donator.size())
+		else if (index > donator.getEnergy() + donator.size())
 			index = donator.getEnergy() + donator.size();
 
 		donator.updateEnergy(-1 * (donator.size() + index), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 
-		//if the critter did not have enough energy to complete this action, kills the critter
-		if (donator.getEnergy() < 0)
-		{
+		// if the critter did not have enough energy to complete this action, kills the
+		// critter
+		if (donator.getEnergy() < 0) {
 			kill(donator);
 			return;
 		}
 
 		int newc = c + donator.changeInPosition(true, donator.getOrientation())[0];
 		int newr = r + donator.changeInPosition(true, donator.getOrientation())[1];
-		if (!isValidHex(newc, newr))
-		{
+		if (!isValidHex(newc, newr)) {
 			if (donator.getEnergy() == 0)
 				kill(donator);
 			return;
 		}
 
 		Hex directlyInFront = grid[newc][newr];
-		if (directlyInFront.isEmpty())
-		{
+		if (directlyInFront.isEmpty()) {
 			Food f = new Food(index);
 			nonCritterObjectMap.put(f, directlyInFront);
 			directlyInFront.addContent(f);
+			updatedHexes.add(directlyInFront);
 		}
 		if (donator.getEnergy() == 0)
 			kill(donator);
 	}
 
 	@Override
-	public void critterSoakEnergy(SimpleCritter sc)
-	{
+	public void critterSoakEnergy(SimpleCritter sc) {
 		sc.updateEnergy(CONSTANTS.get("SOLAR_FLUX").intValue(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
 	}
 
-	/** Kills a critter and removes it from any lists or mappings of critters. Rest in peace, buddy. */
-	private void kill(SimpleCritter sc)
-	{
+	/**
+	 * Kills a critter and removes it from any lists or mappings of critters. Rest
+	 * in peace, buddy.
+	 */
+	private void kill(SimpleCritter sc) {
 		Hex location = critterMap.get(sc);
 		location.removeContent();
 		critterMap.remove(sc);
 		critterList.remove(sc);
+		updatedHexes.add(location);
+		deadCritters.add(sc);
 
 		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
 		nonCritterObjectMap.put(remnant, location);
@@ -969,17 +1146,26 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public StringBuilder printGrid()
-	{	
+	public void removeCritter(SimpleCritter sc) {
+		if (sc == null)
+			return;
+		Hex location = critterMap.get(sc);
+		location.removeContent();
+		critterMap.remove(sc);
+		critterList.remove(sc);
+		updatedHexes.add(location);
+		deadCritters.add(sc);
+	}
+
+	@Override
+	public StringBuilder printGrid() {
 		StringBuilder result = new StringBuilder();
-		for(int i = 0; i < 2 * rows - columns; i++)
-		{
+		for (int i = 0; i < 2 * rows - columns; i++) {
 			StringBuilder sb = new StringBuilder();
-			if(i % 2 != 0)
+			if (i % 2 != 0)
 				sb.append("  ");
-			for(int c = i % 2, r = (int) Math.ceil(i / 2.0); c < columns && r < rows; c += 2, r++)
-			{
-				if(isValidHex(c, r))
+			for (int c = i % 2, r = (int) Math.ceil(i / 2.0); c < columns && r < rows; c += 2, r++) {
+				if (isValidHex(c, r))
 					sb.append("" + grid[c][r].toString() + "   ");
 			}
 			result.insert(0, sb.toString() + "\n");
@@ -987,32 +1173,66 @@ public class World extends AbstractWorld
 		result.insert(0, "World name: " + worldname + "\n");
 		return result;
 	}
-	
+
 	@Override
-	public Set<Map.Entry<SimpleCritter, Hex>> getCritterMap()
-	{
-		return critterMap.entrySet();
+	@SuppressWarnings("unchecked")
+	public Set<Map.Entry<SimpleCritter, Hex>> getCritterMap() {
+		HashMap<SimpleCritter, Hex> copy = (HashMap<SimpleCritter, Hex>) critterMap.clone();
+		return copy.entrySet();
 	}
-	
+
 	@Override
-	public Set<Map.Entry<WorldObject, Hex>> getObjectMap()
-	{
-		return nonCritterObjectMap.entrySet();
+	@SuppressWarnings("unchecked")
+	public Set<Map.Entry<WorldObject, Hex>> getObjectMap() {
+		HashMap<WorldObject, Hex> copy = (HashMap<WorldObject, Hex>) nonCritterObjectMap.clone();
+		return copy.entrySet();
 	}
-	
+
 	@Override
-	public int analyzeHex(int c, int r)
-	{
-		if(!isValidHex(c, r))
+	public int analyzeHex(int c, int r) {
+		if (!isValidHex(c, r))
 			return Integer.MIN_VALUE;
 		return grid[c][r].hexAppearance();
 	}
-	
+
 	@Override
-	public SimpleCritter analyzeCritter(int c, int r)
-	{
-		if(!isValidHex(c, r) || !(grid[c][r].getContent() instanceof SimpleCritter))
+	public SimpleCritter analyzeCritter(int c, int r) {
+		if (!isValidHex(c, r) || !(grid[c][r].getContent() instanceof SimpleCritter))
 			return null;
 		return (SimpleCritter) (grid[c][r].getContent());
 	}
+
+	@Override
+	public int[] getCritterLocation(SimpleCritter sc) {
+		Hex location = critterMap.get(sc);
+		if (location == null)
+			return null;
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+		return new int[] { c, r };
+	}
+
+	@Override
+	public int getCritterID(SimpleCritter sc) {
+		Integer ID = critterToIDMap.get(sc);
+		int result = (ID == null) ? 0 : ID;
+		return result;
+	}
+
+	@Override
+	public SimpleCritter getCritterFromID(int id) {
+		return IDToCritterMap.get(id);
+	}
+
+	@Override
+	public int getCritterCreatorID(SimpleCritter sc) {
+		return critterCreatorMap.get(getCritterID(sc));
+	}
+
+	@Override
+	public WorldObject getHexContent(int c, int r) {
+		if (!isValidHex(c, r))
+			return null;
+		return grid[c][r].getContent();
+	}
 }
\ No newline at end of file
diff --git a/src/main/resources/gui/critterworld_favicon.png b/src/main/resources/gui/critterworld_favicon.png
new file mode 100644
index 0000000..4ed4790
Binary files /dev/null and b/src/main/resources/gui/critterworld_favicon.png differ
diff --git a/src/test/resources/simulationTests/AttackWorld.txt b/src/test/resources/simulationTests/AttackWorld.txt
deleted file mode 100644
index d1151bb..0000000
--- a/src/test/resources/simulationTests/AttackWorld.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-name Attack World 
-size 5 10
-
-critter src/test/resources/simulationTests/AttackCritter1.txt 3 4 0
-critter src/test/resources/simulationTests/AttackCritter2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorld.txt b/src/test/resources/simulationTests/BudWorld.txt
deleted file mode 100644
index f606bf2..0000000
--- a/src/test/resources/simulationTests/BudWorld.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Bud World 1
-size 5 10
-
-critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorld3.txt b/src/test/resources/simulationTests/BudWorld3.txt
deleted file mode 100644
index aea4f1b..0000000
--- a/src/test/resources/simulationTests/BudWorld3.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Bud World 3
-size 5 10
-
-critter src/test/resources/simulationTests/BudCritterNoEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorldRock.txt b/src/test/resources/simulationTests/BudWorldRock.txt
deleted file mode 100644
index e3bed1c..0000000
--- a/src/test/resources/simulationTests/BudWorldRock.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Bud World 2
-size 5 10
-rock 3 4
-critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorld.txt b/src/test/resources/simulationTests/MateWorld.txt
deleted file mode 100644
index 62ea1a2..0000000
--- a/src/test/resources/simulationTests/MateWorld.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-name Mate World 
-size 5 10
-
-critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
-critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
deleted file mode 100644
index 127dfcd..0000000
--- a/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-name Mate World Different Time Steps
-size 5 10
-
-critter src/test/resources/simulationTests/MatingParent5.txt 3 4 0
-critter src/test/resources/simulationTests/MatingParent6.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldLittleEnergy.txt b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
deleted file mode 100644
index 7fe7a11..0000000
--- a/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-name Mate World Little Energy
-size 5 10
-
-critter src/test/resources/simulationTests/MatingParent3.txt 3 4 0
-critter src/test/resources/simulationTests/MatingParent4.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldRock.txt b/src/test/resources/simulationTests/MateWorldRock.txt
deleted file mode 100644
index 5c3b717..0000000
--- a/src/test/resources/simulationTests/MateWorldRock.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-name Mate World Rock
-size 5 10
-rock 3 6
-critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
-critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorld.txt b/src/test/resources/simulationTests/MovingWorld.txt
deleted file mode 100644
index 6f1baea..0000000
--- a/src/test/resources/simulationTests/MovingWorld.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Moving World
-size 5 10
-
-critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorldFileRock.txt b/src/test/resources/simulationTests/MovingWorldFileRock.txt
deleted file mode 100644
index 845f953..0000000
--- a/src/test/resources/simulationTests/MovingWorldFileRock.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Moving World2
-size 5 10
-rock 3 6
-critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
diff --git a/src/test/resources/simulationTests/MovingWorldFour.txt b/src/test/resources/simulationTests/MovingWorldFour.txt
deleted file mode 100644
index c9a3ea8..0000000
--- a/src/test/resources/simulationTests/MovingWorldFour.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Moving World 4
-size 5 10
-
-critter src/test/resources/simulationTests/MovingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorldThree.txt b/src/test/resources/simulationTests/MovingWorldThree.txt
deleted file mode 100644
index 322aa54..0000000
--- a/src/test/resources/simulationTests/MovingWorldThree.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Moving World 3
-size 5 10
-
-critter src/test/resources/simulationTests/MovingCritterLittleEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
deleted file mode 100644
index 040f068..0000000
--- a/src/test/resources/simulationTests/SensingWorld.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Sensing World 1
-size 5 10
-
-critter src/test/resources/simulationTests/SensingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
deleted file mode 100644
index ca69671..0000000
--- a/src/test/resources/simulationTests/SpiralCritterWorld.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Spiral World
-size 11 13
-critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
-food 5 7 10000
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/TurnNearbyWorld.txt b/src/test/resources/simulationTests/TurnNearbyWorld.txt
deleted file mode 100644
index 64bb6c2..0000000
--- a/src/test/resources/simulationTests/TurnNearbyWorld.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-name Turn World 1
-size 5 10
-food 3 3 500
-critter src/test/resources/simulationTests/Turner1.txt 3 4 0
diff --git a/src/test/resources/simulationTests/TurnWorldTwo.txt b/src/test/resources/simulationTests/TurnWorldTwo.txt
deleted file mode 100644
index d53c1bb..0000000
--- a/src/test/resources/simulationTests/TurnWorldTwo.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-name Turn World 1
-size 5 10
-critter src/test/resources/simulationTests/Turner2.txt 3 4 0
diff --git a/src/test/resources/simulationTests/AttackCritter1.txt b/src/test/resources/simulationtests/critters/AttackCritter1.txt
similarity index 100%
rename from src/test/resources/simulationTests/AttackCritter1.txt
rename to src/test/resources/simulationtests/critters/AttackCritter1.txt
diff --git a/src/test/resources/simulationTests/AttackCritter2.txt b/src/test/resources/simulationtests/critters/AttackCritter2.txt
similarity index 100%
rename from src/test/resources/simulationTests/AttackCritter2.txt
rename to src/test/resources/simulationtests/critters/AttackCritter2.txt
diff --git a/src/test/resources/simulationTests/BudCritter.txt b/src/test/resources/simulationtests/critters/BudCritter.txt
similarity index 100%
rename from src/test/resources/simulationTests/BudCritter.txt
rename to src/test/resources/simulationtests/critters/BudCritter.txt
diff --git a/src/test/resources/simulationTests/BudCritterNoEnergy.txt b/src/test/resources/simulationtests/critters/BudCritterNoEnergy.txt
similarity index 100%
rename from src/test/resources/simulationTests/BudCritterNoEnergy.txt
rename to src/test/resources/simulationtests/critters/BudCritterNoEnergy.txt
diff --git a/src/test/resources/simulationTests/MatingParent1.txt b/src/test/resources/simulationtests/critters/MatingParent1.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent1.txt
rename to src/test/resources/simulationtests/critters/MatingParent1.txt
diff --git a/src/test/resources/simulationTests/MatingParent2.txt b/src/test/resources/simulationtests/critters/MatingParent2.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent2.txt
rename to src/test/resources/simulationtests/critters/MatingParent2.txt
diff --git a/src/test/resources/simulationTests/MatingParent3.txt b/src/test/resources/simulationtests/critters/MatingParent3.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent3.txt
rename to src/test/resources/simulationtests/critters/MatingParent3.txt
diff --git a/src/test/resources/simulationTests/MatingParent4.txt b/src/test/resources/simulationtests/critters/MatingParent4.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent4.txt
rename to src/test/resources/simulationtests/critters/MatingParent4.txt
diff --git a/src/test/resources/simulationTests/MatingParent5.txt b/src/test/resources/simulationtests/critters/MatingParent5.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent5.txt
rename to src/test/resources/simulationtests/critters/MatingParent5.txt
diff --git a/src/test/resources/simulationTests/MatingParent6.txt b/src/test/resources/simulationtests/critters/MatingParent6.txt
similarity index 100%
rename from src/test/resources/simulationTests/MatingParent6.txt
rename to src/test/resources/simulationtests/critters/MatingParent6.txt
diff --git a/src/test/resources/simulationTests/MovingCritter.txt b/src/test/resources/simulationtests/critters/MovingCritter.txt
similarity index 100%
rename from src/test/resources/simulationTests/MovingCritter.txt
rename to src/test/resources/simulationtests/critters/MovingCritter.txt
diff --git a/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt b/src/test/resources/simulationtests/critters/MovingCritterLittleEnergy.txt
similarity index 100%
rename from src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
rename to src/test/resources/simulationtests/critters/MovingCritterLittleEnergy.txt
diff --git a/src/test/resources/simulationTests/SensingCritter.txt b/src/test/resources/simulationtests/critters/SensingCritter.txt
similarity index 100%
rename from src/test/resources/simulationTests/SensingCritter.txt
rename to src/test/resources/simulationtests/critters/SensingCritter.txt
diff --git a/src/test/resources/simulationTests/Turner1.txt b/src/test/resources/simulationtests/critters/Turner1.txt
similarity index 100%
rename from src/test/resources/simulationTests/Turner1.txt
rename to src/test/resources/simulationtests/critters/Turner1.txt
diff --git a/src/test/resources/simulationTests/Turner2.txt b/src/test/resources/simulationtests/critters/Turner2.txt
similarity index 100%
rename from src/test/resources/simulationTests/Turner2.txt
rename to src/test/resources/simulationtests/critters/Turner2.txt
diff --git a/src/test/resources/simulationtests/critters/draw_critter.txt b/src/test/resources/simulationtests/critters/draw_critter.txt
new file mode 100644
index 0000000..10d59b2
--- /dev/null
+++ b/src/test/resources/simulationtests/critters/draw_critter.txt
@@ -0,0 +1,13 @@
+species: draw_critter
+memsize: 9
+defense: 2
+offense: 3
+size: 50
+energy: 500000
+posture: 17
+POSTURE != 17 --> POSTURE := 17;
+nearby[3] = 0 and ENERGY > 2500 --> bud;
+{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
+ahead[0] < -1 and ENERGY < 500 * SIZE --> eat;
+(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
+1 = 1 --> wait;
diff --git a/example-critter.txt b/src/test/resources/simulationtests/critters/example-critter.txt
similarity index 100%
rename from example-critter.txt
rename to src/test/resources/simulationtests/critters/example-critter.txt
diff --git a/src/test/resources/simulationtests/critters/smell_critter.txt b/src/test/resources/simulationtests/critters/smell_critter.txt
new file mode 100644
index 0000000..19b4b68
--- /dev/null
+++ b/src/test/resources/simulationtests/critters/smell_critter.txt
@@ -0,0 +1,22 @@
+species: Smell
+memsize: 13
+defense: 2
+offense: 3
+size: 1
+energy: 50000
+posture: 17
+
+ENERGY <= SIZE * 3 --> wait;
+ahead[1] < -1 --> eat;
+
+1 = 1 --> mem[6] := smell;
+
+mem[9] = 0 --> mem[8] := mem[8] + 1 mem[9] := 1 forward;
+
+mem[9] = 1 and mem[10] = 0 --> mem[10] := mem[10] + 1 right;
+mem[10] = 1 and mem[11] < mem[8] - 1 --> mem[11] := mem[11] + 1 forward;
+mem[10] = 1 and mem[11] = mem[8] - 1 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+
+mem[11] < mem[8] --> mem[11] := mem[11] + 1 forward;
+mem[11] = mem[8] and mem[10] < 6 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+mem[10] = 6 and mem[9] = 1 --> mem[9] := 0 mem[10] := 0 mem[11] := 0;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/spiral_critter.txt b/src/test/resources/simulationtests/critters/spiral_critter.txt
similarity index 97%
rename from src/test/resources/simulationTests/spiral_critter.txt
rename to src/test/resources/simulationtests/critters/spiral_critter.txt
index 8da44ad..fc4821f 100644
--- a/src/test/resources/simulationTests/spiral_critter.txt
+++ b/src/test/resources/simulationtests/critters/spiral_critter.txt
@@ -3,7 +3,7 @@ memsize: 12
 defense: 2
 offense: 3
 size: 1
-energy: 500
+energy: 50000
 posture: 17
 
 //ensures that the critter has enough energy, and will eat food in its way
diff --git a/src/test/resources/simulationtests/critters/spiral_critter_2.txt b/src/test/resources/simulationtests/critters/spiral_critter_2.txt
new file mode 100644
index 0000000..1de925f
--- /dev/null
+++ b/src/test/resources/simulationtests/critters/spiral_critter_2.txt
@@ -0,0 +1,21 @@
+species: SUJITHWORLD
+memsize: 12
+defense: 2
+offense: 3
+size: 1
+energy: 500
+posture: 17
+
+//ensures that the critter has enough energy, and will eat food in its way
+ENERGY <= SIZE * 3 --> wait;
+ahead[1] < -1 --> eat;
+
+mem[9] = 0 --> mem[8] := mem[8] + 1 mem[9] := 1 forward;
+
+mem[9] = 1 and mem[10] = 0 --> mem[10] := mem[10] + 1 right;
+mem[10] = 1 and mem[11] < mem[8] - 1 --> mem[11] := mem[11] + 1 forward;
+mem[10] = 1 and mem[11] = mem[8] - 1 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+
+mem[11] < mem[8] --> mem[11] := mem[11] + 1 forward;
+mem[11] = mem[8] and mem[10] < 6 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+mem[10] = 6 and mem[9] = 1 --> mem[9] := 0 mem[10] := 0 mem[11] := 0;
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/AttackWorld.txt b/src/test/resources/simulationtests/worlds/AttackWorld.txt
new file mode 100644
index 0000000..e444fe2
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/AttackWorld.txt
@@ -0,0 +1,5 @@
+name Attack World 
+size 5 10
+
+critter src/test/resources/simulationTests/critters/AttackCritter1.txt 3 4 0
+critter src/test/resources/simulationTests/critters/AttackCritter2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/BudWorld.txt b/src/test/resources/simulationtests/worlds/BudWorld.txt
new file mode 100644
index 0000000..facd836
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/BudWorld.txt
@@ -0,0 +1,4 @@
+name Bud World 1
+size 5 10
+
+critter src/test/resources/simulationTests/critters/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/BudWorld3.txt b/src/test/resources/simulationtests/worlds/BudWorld3.txt
new file mode 100644
index 0000000..391b20e
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/BudWorld3.txt
@@ -0,0 +1,4 @@
+name Bud World 3
+size 5 10
+
+critter src/test/resources/simulationTests/critters/BudCritterNoEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/BudWorldRock.txt b/src/test/resources/simulationtests/worlds/BudWorldRock.txt
new file mode 100644
index 0000000..9ebd882
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/BudWorldRock.txt
@@ -0,0 +1,4 @@
+name Bud World 2
+size 5 10
+rock 3 4
+critter src/test/resources/simulationTests/critters/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MateWorld.txt b/src/test/resources/simulationtests/worlds/MateWorld.txt
new file mode 100644
index 0000000..64e17c8
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MateWorld.txt
@@ -0,0 +1,5 @@
+name Mate World 
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MatingParent1.txt 3 4 0
+critter src/test/resources/simulationTests/critters/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MateWorldDifferentTimeSteps.txt b/src/test/resources/simulationtests/worlds/MateWorldDifferentTimeSteps.txt
new file mode 100644
index 0000000..f0a08d9
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MateWorldDifferentTimeSteps.txt
@@ -0,0 +1,5 @@
+name Mate World Different Time Steps
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MatingParent5.txt 3 4 0
+critter src/test/resources/simulationTests/critters/MatingParent6.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MateWorldLittleEnergy.txt b/src/test/resources/simulationtests/worlds/MateWorldLittleEnergy.txt
new file mode 100644
index 0000000..9e9ad1f
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MateWorldLittleEnergy.txt
@@ -0,0 +1,5 @@
+name Mate World Little Energy
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MatingParent3.txt 3 4 0
+critter src/test/resources/simulationTests/critters/MatingParent4.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MateWorldRock.txt b/src/test/resources/simulationtests/worlds/MateWorldRock.txt
new file mode 100644
index 0000000..66b5aea
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MateWorldRock.txt
@@ -0,0 +1,5 @@
+name Mate World Rock
+size 5 10
+rock 3 6
+critter src/test/resources/simulationTests/critters/MatingParent1.txt 3 4 0
+critter src/test/resources/simulationTests/critters/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MovingWorld.txt b/src/test/resources/simulationtests/worlds/MovingWorld.txt
new file mode 100644
index 0000000..5b0f554
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MovingWorld.txt
@@ -0,0 +1,4 @@
+name Moving World
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MovingCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MovingWorldFileRock.txt b/src/test/resources/simulationtests/worlds/MovingWorldFileRock.txt
new file mode 100644
index 0000000..5d8c7e6
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MovingWorldFileRock.txt
@@ -0,0 +1,4 @@
+name Moving World2
+size 5 10
+rock 3 6
+critter src/test/resources/simulationTests/critters/MovingCritter.txt 3 5 0
diff --git a/src/test/resources/simulationtests/worlds/MovingWorldFour.txt b/src/test/resources/simulationtests/worlds/MovingWorldFour.txt
new file mode 100644
index 0000000..0f2be5e
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MovingWorldFour.txt
@@ -0,0 +1,4 @@
+name Moving World 4
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MovingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/MovingWorldThree.txt b/src/test/resources/simulationtests/worlds/MovingWorldThree.txt
new file mode 100644
index 0000000..dc80e41
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/MovingWorldThree.txt
@@ -0,0 +1,4 @@
+name Moving World 3
+size 5 10
+
+critter src/test/resources/simulationTests/critters/MovingCritterLittleEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/SensingWorld.txt b/src/test/resources/simulationtests/worlds/SensingWorld.txt
new file mode 100644
index 0000000..ad82c92
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/SensingWorld.txt
@@ -0,0 +1,4 @@
+name Sensing World 1
+size 5 10
+
+critter src/test/resources/simulationTests/critters/SensingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/SpiralCritterWorld.txt b/src/test/resources/simulationtests/worlds/SpiralCritterWorld.txt
new file mode 100644
index 0000000..a7ccc62
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/SpiralCritterWorld.txt
@@ -0,0 +1,4 @@
+name Spiral World
+size 11 13
+critter src/test/resources/simulationTests/critters/spiral_critter.txt 5 6 0
+food 5 7 10000
\ No newline at end of file
diff --git a/src/test/resources/simulationtests/worlds/TurnNearbyWorld.txt b/src/test/resources/simulationtests/worlds/TurnNearbyWorld.txt
new file mode 100644
index 0000000..2f155f0
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/TurnNearbyWorld.txt
@@ -0,0 +1,4 @@
+name Turn World 1
+size 5 10
+food 3 3 500
+critter src/test/resources/simulationTests/critters/Turner1.txt 3 4 0
diff --git a/src/test/resources/simulationtests/worlds/TurnWorldTwo.txt b/src/test/resources/simulationtests/worlds/TurnWorldTwo.txt
new file mode 100644
index 0000000..166f10a
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/TurnWorldTwo.txt
@@ -0,0 +1,3 @@
+name Turn World 1
+size 5 10
+critter src/test/resources/simulationTests/critters/Turner2.txt 3 4 0
diff --git a/a5world.txt b/src/test/resources/simulationtests/worlds/a5world.txt
similarity index 79%
rename from a5world.txt
rename to src/test/resources/simulationtests/worlds/a5world.txt
index e9fafb5..44d8ef2 100644
--- a/a5world.txt
+++ b/src/test/resources/simulationtests/worlds/a5world.txt
@@ -1,5 +1,5 @@
 name a5 world
-size 7 8
+size 17 18
 rock 0 4
 rock 6 6
 rock 0 1
diff --git a/biggerworld.txt b/src/test/resources/simulationtests/worlds/biggerworld.txt
similarity index 100%
rename from biggerworld.txt
rename to src/test/resources/simulationtests/worlds/biggerworld.txt
diff --git a/src/test/resources/simulationtests/worlds/nearbysensingworld.txt b/src/test/resources/simulationtests/worlds/nearbysensingworld.txt
new file mode 100644
index 0000000..aa1d589
--- /dev/null
+++ b/src/test/resources/simulationtests/worlds/nearbysensingworld.txt
@@ -0,0 +1,2 @@
+name nearby world
+size 2 3
\ No newline at end of file
diff --git a/world.txt b/src/test/resources/simulationtests/worlds/world.txt
similarity index 100%
rename from world.txt
rename to src/test/resources/simulationtests/worlds/world.txt
diff --git a/A6_written_problems.txt b/written_problems/A6_written_problems.txt
similarity index 100%
rename from A6_written_problems.txt
rename to written_problems/A6_written_problems.txt
