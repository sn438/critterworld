diff --git a/A6_written_problems.txt b/A6_written_problems.txt
new file mode 100644
index 0000000..4a2f8b6
--- /dev/null
+++ b/A6_written_problems.txt
@@ -0,0 +1,28 @@
+1. An implementation of or() is provided below:
+
+/** Returns: disjunction of this and that (this OR that). */
+public TVBool or(TVBool that) {
+	TVBool result = new TVBool();
+	result.state = Math.max(this.state, that.state);
+	return result;
+}
+
+2. normalize() is implemented correctly because it is simply a checking method whose job is to assert that there isn't any flaws in the logic of the other methods. It never actually changes the representation of the TVBool when being accessed by different classes because if the normalize method retains the sign of the field state even if the technical value of the field is changed. not() is implemented correctly because it never actually changes the value of the field state. It creates a new object, sets the state of that object, and returns that object. It never alters the state of the original object.
+
+3. The hashCode() method is incorrect because if two TVBools are equal, they need to have the same hash code. The given implementation does not have this property. A correct implementation is provided below:
+
+@Override
+public int hashCode() {
+	return Integer.signum(state);
+}
+
+An implementation of equals() is provided below:
+
+@Override
+public boolean equals(Object o) {
+	if (Integer.signum(state) == Integer.signum(o.state)) {
+		return true;
+	} else {
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/src/main/resources/constants.txt b/constants.txt
similarity index 100%
rename from src/main/resources/constants.txt
rename to constants.txt
diff --git a/diff.txt b/diff.txt
new file mode 100644
index 0000000..40c893c
--- /dev/null
+++ b/diff.txt
@@ -0,0 +1,6681 @@
+diff --git a/.gitignore b/.gitignore
+index cba70df..9d56415 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -12,3 +12,8 @@ content
+ *.pdf
+ *.DS_Store
+ 
++src/main/java/interpret/ActionOutcome.java
++src/main/java/parse/Token.java
++src/main/java/parse/TokenCategory.java
++src/main/java/parse/Tokenizer.java
++src/main/java/parse/TokenType.java
+diff --git a/a5world.txt b/a5world.txt
+new file mode 100644
+index 0000000..e9fafb5
+--- /dev/null
++++ b/a5world.txt
+@@ -0,0 +1,13 @@
++name a5 world
++size 7 8
++rock 0 4
++rock 6 6
++rock 0 1
++rock 9 10
++
++// Some food
++food 2 5 500
++
++// example-critter.txt should be in the working directory
++critter example-critter.txt 2 3 1
++critter example-critter.txt 2 1 5
+\ No newline at end of file
+diff --git a/biggerworld.txt b/biggerworld.txt
+new file mode 100644
+index 0000000..10c3b47
+--- /dev/null
++++ b/biggerworld.txt
+@@ -0,0 +1,42 @@
++name Slightly bigger world
++size 100 150
++rock 2 2
++rock 3 6
++rock 9 10
++
++// Some food
++food 4 4 500
++food 1 3 1000
++food 28 128 10000
++food 29 129 10000
++food 29 129 10000
++food 29 128 10000
++food 26 128 10000
++food 26 129 10000
++food 28 129 10000
++food 26 127 10000
++food 41 25 10000
++food 39 26 10000
++food 39 25 10000
++food 39 28 10000
++food 40 26 10000
++food 41 28 10000
++food 38 24 10000
++food 39 24 10000
++
++// example-critter.txt should be in the working directory
++critter example-critter.txt 2 5 3
++critter example-critter.txt 4 3 1
++critter example-critter.txt 4 4 2
++critter example-critter.txt 40 25 4
++critter example-critter.txt 88 93 0
++critter example-critter.txt 66 128 5
++critter example-critter.txt 71 40 5
++critter example-critter.txt 69 100 5
++critter example-critter.txt 42 28 5
++critter example-critter.txt 60 58 5
++critter example-critter.txt 32 81 5
++critter example-critter.txt 97 60 5
++critter example-critter.txt 14 128 5
++critter example-critter.txt 27 128 5
++
+diff --git a/example-critter.txt b/example-critter.txt
+new file mode 100644
+index 0000000..cc5a71d
+--- /dev/null
++++ b/example-critter.txt
+@@ -0,0 +1,22 @@
++species: example
++memsize: 9
++defense: 2
++offense: 3
++size: 100
++energy: 500000
++posture: 17
++POSTURE != 17 --> POSTURE := 17; // we are species 17!
++nearby[3] = 0 and ENERGY > 2500 --> bud;
++{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
++ahead[1] < -1 and ENERGY < 500 * SIZE --> eat;
++// next line attacks only other species
++(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
++ahead[1] < -5 --> forward;
++ahead[2] < -10 and ahead[1] = 0 --> forward;
++ahead[3] < -15 and ahead[1] = 0 --> forward;
++ahead[4] < -20 and ahead[1] = 0 --> forward;
++nearby[0] > 0 and nearby[3] = 0 --> backward;
++// karma action: donate food if we are too full or large enough
++{ahead[1] = 0 or ahead[1] < -1} and { ENERGY > 2500 or SIZE > 7 } --> serve[ENERGY / 42];
++random[3] = 1 --> left;
++1 = 1 --> wait; // mostly soak up the rays
+diff --git a/examples/failure-example-critter1.txt b/examples/failure-example-critter1.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/examples/world.txt b/examples/world.txt
+index 0fbfadf..91bdd68 100644
+--- a/examples/world.txt
++++ b/examples/world.txt
+@@ -8,7 +8,7 @@ rock 9 10
+ food 4 4 500
+ food 1 3 1000
+ 
+-// example_critter.txt should be in the working directory
+-critter example_critter.txt 2 5 3
+-critter example_critter.txt 4 3 1
+-critter example_critter.txt 4 4 2
++// example-critter.txt should be in the working directory
++critter example-critter.txt 2 5 3
++critter example-critter.txt 4 3 1
++critter example-critter.txt 4 4 2
+diff --git a/log.txt b/log.txt
+new file mode 100644
+index 0000000..7aedfce
+--- /dev/null
++++ b/log.txt
+@@ -0,0 +1,271 @@
++[33mcommit fce536fec1b6d39c94b8eb25247226e99b89f023[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
++Merge: faaae27 41fe28e
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 22:47:22 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit faaae27e8751ae57808ad7b3b0819f7624e3e782[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 22:46:48 2017 -0400
++
++    Final tests
++
++[33mcommit 41fe28e826698ca5cf3e31913bdf54842644b50c[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 22:44:40 2017 -0400
++
++    Testing Done
++
++[33mcommit 3f34641d080ef40ea4dbab4d1980324643736d26[m
++Merge: 3631e4c 2e8bab8
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 21:38:55 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit 3631e4cef53d386e115ab7fa8364e9d22a95efe9[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 21:38:49 2017 -0400
++
++    Turning Tests
++
++[33mcommit 2e8bab888d0b606f53dda0b449210c2f3996abdc[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 21:35:36 2017 -0400
++
++    More Tests
++
++[33mcommit 90fd50cc87b830aff15673e999c4cd22044a9543[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 20:43:50 2017 -0400
++
++    Tests!
++
++[33mcommit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 20:14:08 2017 -0400
++
++    SpiralCritter works now
++
++[33mcommit 9bdbd6cc4f186af60209dce78176917924f76428[m
++Merge: 4c6c2ee 4892088
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 16:57:49 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 16:57:41 2017 -0400
++
++    Minor fixes
++
++[33mcommit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 15:37:39 2017 -0400
++
++    Mating Testing Final
++
++[33mcommit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 15:31:26 2017 -0400
++
++    Mating Testing
++
++[33mcommit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460[m
++Merge: d3b6060 753823a
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 14:59:59 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit d3b60607e47ccc71ddb9a8a65f249e65e127bb22[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 14:58:53 2017 -0400
++
++    Mate Test Change
++
++[33mcommit 9ca82f204cd008b0e3449775ebc042e96557f9a4[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 14:57:30 2017 -0400
++
++    File Parser Update
++
++[33mcommit ecdea17320fd143cf698fc9faa53d5b39131f071[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 14:57:00 2017 -0400
++
++    Mate Testing Done and Bug Fixed
++
++[33mcommit b669ff85cd406986cb387789b43c622d2fd53366[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 13:11:19 2017 -0400
++
++    Mate Testing
++
++[33mcommit b24dcaeecb0961141406915da0977e58847259c1[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 13:01:45 2017 -0400
++
++    Testing
++
++[33mcommit d9804214694a1287b36387ab5096161119fb7d2a[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 13:00:32 2017 -0400
++
++    Testing2
++
++[33mcommit 760b3702d46d973fc51fdfe2988e1365e553c229[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 12:59:02 2017 -0400
++
++    Revert "Testing"
++    
++    This reverts commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28.
++
++[33mcommit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 12:54:41 2017 -0400
++
++    Testing
++
++[33mcommit 753823a1f154f70f6e374d0b5e88df5d8239cd1e[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 12:49:12 2017 -0400
++
++    more fixes
++
++[33mcommit 086816869af82477368bfd3c77e6e9f1cff9e8fd[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 12:46:23 2017 -0400
++
++    Fixes
++
++[33mcommit a02473c4318c5f7012d276aed173e05a84fa7cfd[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 12:42:26 2017 -0400
++
++    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw"
++    
++    This reverts commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b, reversing
++    changes made to 21179a6b02c48db2457e6bdb649d6b4b581bd6e3.
++
++[33mcommit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b[m
++Merge: 21179a6 8fc49a4
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 12:41:21 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 12:40:30 2017 -0400
++
++    Stuff
++
++[33mcommit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 12:39:25 2017 -0400
++
++    Tokenizer Has Been Updated With Correct Solution
++
++[33mcommit cebe8f1a5273b0a0a02553cd42f682511f53e186[m
++Merge: 0343510 878321e
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 09:16:26 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit 03435103759b26ede1d3b7c4215dd1f117cd927a[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Tue Oct 31 09:16:19 2017 -0400
++
++    Bud Test
++
++[33mcommit 878321e363ceaa0b2d586c8be5b0102618d50634[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 02:11:11 2017 -0400
++
++    Documentation
++
++[33mcommit dc3812325cb76cf5af623bba64f907b01ca7e243[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 01:31:22 2017 -0400
++
++    Misc stuff
++
++[33mcommit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 01:09:31 2017 -0400
++
++    Documentation + finishing up console
++
++[33mcommit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9[m
++Author: Andy <az389@cornell.edu>
++Date:   Tue Oct 31 00:01:43 2017 -0400
++
++    More documentation
++
++[33mcommit 4c6783d0533f75d5d9b97742f61e7803f5aa4390[m
++Merge: c4f5689 adc8c91
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 23:51:40 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit c4f56899144a8923b956408256221a5e46fcc436[m
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 23:51:38 2017 -0400
++
++    Documentation
++
++[33mcommit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b[m
++Merge: 88613b7 ef684b3
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 30 23:47:38 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 30 23:47:33 2017 -0400
++
++    Moving Test Done
++
++[33mcommit ef684b37c2fe6924efcc416a45c716297c9f46d6[m
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 23:45:01 2017 -0400
++
++    Fixes
++
++[33mcommit 067278303066953f1241de39755d7545b4cb4b1e[m
++Merge: a6d2ead 5a4812d
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 23:43:56 2017 -0400
++
++    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
++
++[33mcommit a6d2eadf9badd7c0c163420549e66e2f9eaa2145[m
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 23:43:41 2017 -0400
++
++    Spiral stuff
++
++[33mcommit 5a4812d93de841aed1720ee36c4a6e9304f368e0[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 30 23:25:53 2017 -0400
++
++    Moving Test Initial
++
++[33mcommit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c[m
++Author: Andy <az389@cornell.edu>
++Date:   Mon Oct 30 17:53:50 2017 -0400
++
++    SpiralCritter stuff
++
++[33mcommit 200b419d4d5d2162ef30ddeb630491a180dd968d[m
++Author: sn438 <31802007+sn438@users.noreply.github.com>
++Date:   Mon Oct 30 17:35:38 2017 -0400
++
++ 
+\ No newline at end of file
+diff --git a/src/main/java/ast/Action.java b/src/main/java/ast/Action.java
+index bca9a07..fc50150 100644
+--- a/src/main/java/ast/Action.java
++++ b/src/main/java/ast/Action.java
+@@ -2,8 +2,6 @@ package ast;
+ 
+ import java.util.Random;
+ 
+-import ast.Action.ActType;
+-
+ /** An AST representation of a critter action. */
+ public class Action extends AbstractNode implements CommandComponent
+ {
+@@ -27,6 +25,32 @@ public class Action extends AbstractNode implements CommandComponent
+ 		val.setParent(this);
+ 	}
+ 	
++	/** Returns the type of action contained in this node. */
++	public ActType getActType()
++	{
++		return act;
++	}
++	
++	/** Sets the value of {@code act} to {@code at}, modifying {@code val} as necessary. */
++	public void setActType(ActType at)
++	{
++		Random r = new Random();
++		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
++		{
++			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
++				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
++		}
++		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
++			this.val = null;
++		this.act = at;
++	}
++	
++	/** Returns the expression stored at this node, if there is one. */
++	public Expr getVal()
++	{
++		return val;
++	}
++	
+ 	@Override
+ 	public int size()
+ 	{
+@@ -124,23 +148,6 @@ public class Action extends AbstractNode implements CommandComponent
+ 		return sb;
+ 	}
+ 	
+-	/**
+-	 * setActType sets the ActType for the Action. 
+-	 * @param at is the ActType that the Action is being set to. If at is not of the same type as the original 
+-	 * ActType, then the value is modified if necessary.
+-	 */
+-	public void setActType(ActType at)
+-	{
+-		Random r = new Random();
+-		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
+-		{
+-			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+-				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
+-		}
+-		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+-			this.val = null;
+-		this.act = at;
+-	}
+ 	/** An enumeration of all the possible action types. */
+ 	public enum ActType
+ 	{
+diff --git a/src/main/java/ast/BinaryCondition.java b/src/main/java/ast/BinaryCondition.java
+index 99ce650..4bc10ad 100644
+--- a/src/main/java/ast/BinaryCondition.java
++++ b/src/main/java/ast/BinaryCondition.java
+@@ -1,5 +1,7 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** A representation of a binary Boolean condition: 'and' or 'or' */
+ public class BinaryCondition extends AbstractNode implements Condition
+ {
+@@ -20,44 +22,43 @@ public class BinaryCondition extends AbstractNode implements Condition
+ 		left.setParent(this);
+ 		right.setParent(this);
+ 	}
+-	/**
+-	 * getLeft returns the left node for the BinaryCondition.
+-	 * @return left node.
+-	 */
++	/** Returns the left child of this binary condition. */
+ 	public Condition getLeft()
+ 	{
+ 		return left;
+ 	}
+ 	
+-	/**
+-	 * setLeft sets the left node for the Binary Condition.
+-	 * @param newLeft is the new left node of the Binary Condition.
+-	 */
++	/** Sets the value of {@code left} to {@code newleft}. */
+ 	public void setLeft(Condition newLeft)
+ 	{
+ 		left = newLeft;
+ 		left.setParent(this);
+ 	}
+ 	
+-	/**
+-	 * getRight returns the right node for the BinaryCondition.
+-	 * @return right node.
+-	 */
++	/** Returns the right child of this binary condition. */
+ 	public Condition getRight()
+ 	{
+ 		return right;
+ 	}
+ 	
+-	/**
+-	 * setRight sets the left node for the Binary Condition.
+-	 * @param newRight is the new left node of the Binary Condition.
+-	 */
++	/** Sets the value of {@code right} to {@code newRight}. */
+ 	public void setRight(Condition newRight)
+ 	{
+ 		right = newRight;
+ 		right.setParent(this);
+ 	}
+ 	
++	/** Returns the operator type of this binary condition. */
++	public Operator getOp()
++	{
++		return op;
++	}
++	
++	/** Sets the value of {@code op} to {@code o}. */
++	public void setOp(Operator o)
++	{
++		this.op = o;
++	}
+ 	@Override
+ 	public int size()
+ 	{
+@@ -130,9 +131,9 @@ public class BinaryCondition extends AbstractNode implements Condition
+ 	}
+ 
+ 	@Override
+-	public boolean evaluate()
++	public boolean acceptEvaluation(Interpreter i)
+ 	{
+-		throw new UnsupportedOperationException();
++		return i.eval(this);
+ 	}
+ 
+ 	/** An enumeration of all possible binary condition operators. */
+@@ -146,11 +147,4 @@ public class BinaryCondition extends AbstractNode implements Condition
+ 	{
+ 		return NodeType.BINARYCONDITION;
+ 	}
+-	/**
+-	 * setOperator sets the operator to op.
+-	 * @param op is the parameter that operator is being set to. 
+-	 */
+-	public void setOperator(Operator op) {
+-		this.op = op;
+-	}
+ }
+\ No newline at end of file
+diff --git a/src/main/java/ast/BinaryExpr.java b/src/main/java/ast/BinaryExpr.java
+index 1765f87..dac5008 100644
+--- a/src/main/java/ast/BinaryExpr.java
++++ b/src/main/java/ast/BinaryExpr.java
+@@ -1,5 +1,7 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** A representation of a binary numerical expression that evaluates to an integer. */
+ public class BinaryExpr extends AbstractNode implements Expr
+ {
+@@ -20,25 +22,34 @@ public class BinaryExpr extends AbstractNode implements Expr
+ 		left.setParent(this);
+ 		right.setParent(this);
+ 	}
+-	
++	/** Returns the left child of this binary expression. */
+ 	public Expr getLeft()
+ 	{
+ 		return left;
+ 	}
++	/** Sets the value of {@code left} to {@code newLeft}. */
+ 	public void setLeft(Expr newLeft)
+ 	{
+ 		left = newLeft;
+ 		left.setParent(this);
+ 	}
++	/** Returns the right child of this binary expression. */
+ 	public Expr getRight()
+ 	{
+ 		return right;
+ 	}
++	/** Sets the value of {@code right} to {@code newRight}. */
+ 	public void setRight(Expr newRight)
+ 	{
+ 		right = newRight;
+ 		right.setParent(this);
+ 	}
++	/** Returns the operator type of this binary expression. */
++	public MathOp getOperator()
++	{
++		return operator;
++	}
++	/** Sets the value of {@code operator} to {@code op}. */
+ 	public void setOperator(MathOp op)
+ 	{
+ 		this.operator = op;
+@@ -131,9 +142,9 @@ public class BinaryExpr extends AbstractNode implements Expr
+ 		return sb;
+ 	}
+ 	@Override
+-	public int evaluate()
++	public int acceptEvaluation(Interpreter i)
+ 	{
+-		throw new UnsupportedOperationException();
++		return i.eval(this);
+ 	}
+ 
+ 	/** Enumerates all the accepted binary mathematical operations. */
+diff --git a/src/main/java/ast/Command.java b/src/main/java/ast/Command.java
+index 79d7011..c46d579 100644
+--- a/src/main/java/ast/Command.java
++++ b/src/main/java/ast/Command.java
+@@ -21,10 +21,19 @@ public class Command extends AbstractNode
+ 			u.setParent(this);
+ 		last.setParent(this);
+ 	}
++	
++	/** Returns the list of updates in this command. */
+ 	public LinkedList<Update> getUpdateList()
+ 	{
+ 		return UpdateList;
+ 	}
++	
++	/** Returns the last component of this command. */
++	public CommandComponent getLast()
++	{
++		return last;
++	}
++	
+ 	@Override
+ 	public int size()
+ 	{
+@@ -111,7 +120,7 @@ public class Command extends AbstractNode
+ 	public StringBuilder prettyPrint(StringBuilder sb)
+ 	{
+ 		for(Update u : getUpdateList())
+-			sb.append(u.toString() + "\n");
++			sb.append(u.toString() + " ");
+ 		sb.append(last.toString());
+ 		return sb;
+ 	}
+diff --git a/src/main/java/ast/Condition.java b/src/main/java/ast/Condition.java
+index 3cf5e2b..92853be 100644
+--- a/src/main/java/ast/Condition.java
++++ b/src/main/java/ast/Condition.java
+@@ -1,10 +1,12 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** An interface representing a Boolean condition in a critter program. */
+ public interface Condition extends Node
+ {
+-	/** Returns the boolean value of this condition. */
+-	public boolean evaluate(); // to be done in A5
++	/** Accepts an evaluation from an Interpreter. */
++	public boolean acceptEvaluation(Interpreter i);
+ 	
+ 	/** Returns a deep copy of this condition. */
+ 	public Condition clone();
+diff --git a/src/main/java/ast/Expr.java b/src/main/java/ast/Expr.java
+index f6de6df..a535510 100644
+--- a/src/main/java/ast/Expr.java
++++ b/src/main/java/ast/Expr.java
+@@ -1,10 +1,12 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** A critter program expression that has an integer value. */
+ public interface Expr extends Node
+ {
+-	/** Returns the integer value of this expression. */
+-	public int evaluate(); // to be done in A5
++	/** Accepts an evaluation from Interpreter i. */
++	public int acceptEvaluation(Interpreter i);
+ 	
+ 	/** Returns a deep copy of this expression. */
+ 	public Expr clone();
+diff --git a/src/main/java/ast/MutationTransform.java b/src/main/java/ast/MutationTransform.java
+index 72282ee..ea98f5f 100644
+--- a/src/main/java/ast/MutationTransform.java
++++ b/src/main/java/ast/MutationTransform.java
+@@ -34,7 +34,7 @@ public class MutationTransform extends AbstractMutation
+ 			op = BinaryCondition.Operator.OR;
+ 			break;
+ 		}
+-		c.setOperator(op);
++		c.setOp(op);
+ 		if(printMutationDetail)
+ 			System.out.println("Transformed the Condition node\n" + c + "\n");
+ 		return true;
+diff --git a/src/main/java/ast/Program.java b/src/main/java/ast/Program.java
+index 31eba98..8a93f6f 100644
+--- a/src/main/java/ast/Program.java
++++ b/src/main/java/ast/Program.java
+@@ -1,8 +1,13 @@
+ package ast;
+ 
++import java.util.LinkedList;
++
+ /** An abstraction of a critter program. */
+ public interface Program extends Node
+ {
++	/** Returns the list of rules contained in this program node. */
++	public LinkedList<Rule> getRulesList();
++	
+ 	/**
+ 	 * Mutates this program with a single mutation
+ 	 * @return The root of the mutated AST
+diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
+index aa17e31..73c14b8 100644
+--- a/src/main/java/ast/ProgramImpl.java
++++ b/src/main/java/ast/ProgramImpl.java
+@@ -16,6 +16,7 @@ public class ProgramImpl extends AbstractNode implements Program
+ 			r.setParent(this);
+ 	}
+ 	
++	@Override
+ 	public LinkedList<Rule> getRulesList()
+ 	{
+ 		return RulesList;
+@@ -100,22 +101,22 @@ public class ProgramImpl extends AbstractNode implements Program
+ 			switch(rand)
+ 			{
+ 				case 0:
+-					m = MutationFactory.getRemove(true);
++					m = MutationFactory.getRemove(false);
+ 					break;
+ 				case 1:
+-					m = MutationFactory.getSwap(true);
++					m = MutationFactory.getSwap(false);
+ 					break;
+ 				case 2:
+-					m = MutationFactory.getReplace(true);
++					m = MutationFactory.getReplace(false);
+ 					break;
+ 				case 3:
+-					m = MutationFactory.getTransform(true);
++					m = MutationFactory.getTransform(false);
+ 					break;
+ 				case 4:
+-					m = MutationFactory.getInsert(true);
++					m = MutationFactory.getInsert(false);
+ 					break;
+ 				case 5:
+-					m = MutationFactory.getDuplicate(true);
++					m = MutationFactory.getDuplicate(false);
+ 					break;
+ 			}
+ 			valid = mutate(randIndex, m);
+diff --git a/src/main/java/ast/Relation.java b/src/main/java/ast/Relation.java
+index 150361b..e1f3fe4 100644
+--- a/src/main/java/ast/Relation.java
++++ b/src/main/java/ast/Relation.java
+@@ -1,5 +1,7 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** A representation of a relational comparison between two numerical expressions. */
+ public class Relation extends AbstractNode implements Condition
+ {
+@@ -9,10 +11,10 @@ public class Relation extends AbstractNode implements Condition
+ 	private RelOp op;
+ 	/** The right child of this node. */
+ 	private Expr right;
+-	
++	/** The condition contained in this relation, if there is one. */
+ 	private Condition cond;
+ 	
+-	/** Creates a relational comparison between two numerical expressions, representing l o r.*/
++	/** Creates a relational comparison between two numerical expressions, representing l op r.*/
+ 	public Relation(Expr l, RelOp o, Expr r)
+ 	{
+ 		this.left = l;
+@@ -35,32 +37,62 @@ public class Relation extends AbstractNode implements Condition
+ 		cond.setParent(this);
+ 	}
+ 
++	/** 
++	 * Returns the left child of this relation. 
++	 * Precondition: {@code this.op != ISCOND}
++	 */
+ 	public Expr getLeft()
+ 	{
+ 		return left;
+ 	}
++	
++	/** Sets the value of {@code left} to {@code newLeft}. */
+ 	public void setLeft(Expr newLeft)
+ 	{
+ 		left = newLeft;
+ 		left.setParent(this);
+ 	}
++	
++	/** 
++	 * Returns the right child of this relation. 
++	 * Precondition: {@code this.op != ISCOND}
++	 */
+ 	public Expr getRight()
+ 	{
+ 		return right;
+ 	}
++	
++	/** Sets the value of {@code right} to {@code newRight}. */
+ 	public void setRight(Expr newRight)
+ 	{
+ 		right = newRight;
+ 		right.setParent(this);
+ 	}
++	
++	/** Returns a boolean based on whether or not this relation node contains a condition. */
+ 	public boolean isCond()
+ 	{
+ 		return op == RelOp.ISCOND;
+ 	}
+ 	
++	/**
++	 * Returns the condition this relation contains.
++	 * Precondition: {@code this.op == ISCOND}
++	 */
++	public Condition getCond()
++	{
++		return cond;
++	}
++	
++	/** Returns the type of this Relation. */
++	public RelOp getRelOp()
++	{
++		return op;
++	}
++	/** Sets the value of {@code op} to {@code ro}, if {@code op} is not equal to ISCOND. */
+ 	public void setRelOp(RelOp ro)
+ 	{
+-		if (this.op.equals(RelOp.ISCOND))
++		if (isCond())
+ 			return;
+ 		if (ro.equals(RelOp.ISCOND))
+ 		{
+@@ -80,7 +112,7 @@ public class Relation extends AbstractNode implements Condition
+ 	@Override
+ 	public int size()
+ 	{
+-		if(op == RelOp.ISCOND)
++		if(isCond())
+ 			return 1 + cond.size();
+ 		return 1 + left.size() + right.size();
+ 	}
+@@ -92,7 +124,7 @@ public class Relation extends AbstractNode implements Condition
+ 			return this;
+ 		if(index > size() - 1 || index < 0)
+ 			throw new IndexOutOfBoundsException();
+-		if(op == RelOp.ISCOND)
++		if(isCond())
+ 			return cond.nodeAt(index - 1);
+ 		else
+ 		{
+@@ -106,7 +138,7 @@ public class Relation extends AbstractNode implements Condition
+ 	@Override
+ 	public Relation clone()
+ 	{
+-		if(op == RelOp.ISCOND)
++		if(isCond())
+ 			return new Relation(cond.clone());
+ 		Expr tempLeft = left.clone();
+ 		Expr tempRight = right.clone();
+@@ -122,7 +154,7 @@ public class Relation extends AbstractNode implements Condition
+ 	@Override
+ 	public boolean replaceChild(Node child, Node replacement)
+ 	{
+-		if(op == RelOp.ISCOND)
++		if(isCond())
+ 		{
+ 			if(child == this.cond)
+ 			{
+@@ -183,9 +215,9 @@ public class Relation extends AbstractNode implements Condition
+ 		return sb;
+ 	}
+ 	@Override
+-	public boolean evaluate()
++	public boolean acceptEvaluation(Interpreter i)
+ 	{
+-		throw new UnsupportedOperationException();
++		return i.eval(this);
+ 	}
+ 	/** An enumeration of all the accepted mathematical relational operators. */
+ 	public enum RelOp
+diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
+index e8c6fb9..3275487 100644
+--- a/src/main/java/ast/Rule.java
++++ b/src/main/java/ast/Rule.java
+@@ -17,6 +17,18 @@ public class Rule extends AbstractNode
+ 		comm.setParent(this);
+ 	}
+ 	
++	/** Returns the condition of this rule. */
++	public Condition getCond()
++	{
++		return cond;
++	}
++	
++	/** Returns the command of this rule. */
++	public Command getComm()
++	{
++		return comm;
++	}
++	
+ 	@Override
+ 	public int size()
+ 	{
+diff --git a/src/main/java/ast/Sensor.java b/src/main/java/ast/Sensor.java
+index f56656b..0769b29 100644
+--- a/src/main/java/ast/Sensor.java
++++ b/src/main/java/ast/Sensor.java
+@@ -1,12 +1,14 @@
+ package ast;
+ 
+ import java.util.Random;
++import interpret.Interpreter;
+ 
+ /** An AST representation of a Sensor node. */
+ public class Sensor extends AbstractNode implements Expr
+ {
+ 	/** The type of this Sensor node. */
+ 	private SensorType type;
++	/** The sensor index of this node. Not compatible with SensorType SMELL. */
+ 	private Expr sensorIndex;
+ 	
+ 	/** Creates a new Sensor node with the specified type and index. Not compatible with SensorType SMELL. */
+@@ -24,6 +26,21 @@ public class Sensor extends AbstractNode implements Expr
+ 		sensorIndex = null;
+ 	}
+ 	
++	/** Returns the type of this sensor. */
++	public SensorType getSensorType()
++	{
++		return type;
++	}
++	
++	/** 
++	 * Returns the sensor index of this sensor, if there is one.
++	 * Precondition: this sensor is not of type SMELL.
++	 */
++	public Expr getSensorIndex()
++	{
++		return sensorIndex;
++	}
++	
+ 	/** Sets the SensorType of this sensor node. */
+ 	public void setSensorType(SensorType st)
+ 	{
+@@ -111,9 +128,9 @@ public class Sensor extends AbstractNode implements Expr
+ 	}
+ 	
+ 	@Override
+-	public int evaluate()
++	public int acceptEvaluation(Interpreter i)
+ 	{
+-		throw new UnsupportedOperationException();
++		return i.eval(this);
+ 	}
+ 	
+ 	/** An enumeration of all the possible Sensor types. */
+diff --git a/src/main/java/ast/Test.java b/src/main/java/ast/Test.java
+deleted file mode 100644
+index b77889d..0000000
+--- a/src/main/java/ast/Test.java
++++ /dev/null
+@@ -1,80 +0,0 @@
+-package ast;
+-
+-import java.io.BufferedReader;
+-import java.io.InputStream;
+-import java.io.InputStreamReader;
+-import java.io.Reader;
+-import java.util.LinkedList;
+-
+-import ast.BinaryExpr;
+-import ast.BinaryCondition.Operator;
+-import ast.BinaryExpr.MathOp;
+-import ast.Relation.RelOp;
+-import ast.UnaryExpr.ExprType;
+-import parse.Parser;
+-import parse.ParserFactory;
+-import parse.Tokenizer;
+-import parsertests.ParserTest;
+-
+-public class Test
+-{
+-	public static void main(String[] args)
+-	{
+-		/*UnaryExpr e1 = new UnaryExpr(2);
+-		UnaryExpr e2 = new UnaryExpr(12);
+-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+-		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION);
+-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+-		Relation r = new Relation(e4, RelOp.EQUAL, e5);
+-		
+-		System.out.println(r.toString());
+-		System.out.println(r.size());*/
+-		
+-		/*UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
+-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+-		UnaryExpr e1 = new UnaryExpr(2);
+-		UnaryExpr e2 = new UnaryExpr(12);
+-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
+-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
+-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
+-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		ll.add(u2);
+-		ll.add(u3);
+-		ll.add(u4);
+-		Command c = new Command(ll, u);
+-		Rule rule = new Rule(con, c);
+-		
+-		System.out.println(rule.toString() + "\n" + rule.size() + "\n" + rule.nodeAt(13));
+-		System.out.println("" + rule.size() + "\n" + con.size() + "\n" + c.size());*/
+-		
+-		/*Sensor s = new Sensor();
+-		System.out.println(s.nodeAt(0).toString());*/
+-		
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+-        Reader r = new BufferedReader(new InputStreamReader(in));
+-        Tokenizer t = new Tokenizer(r);
+-        Parser p = ParserFactory.getParser();
+-        Program prog = p.parse(r);
+-        System.out.println(prog.toString());
+-        
+-        Program pclone = (Program) prog.clone();
+-        System.out.println(pclone.toString());
+-        pclone = null;
+-        System.out.println(prog.toString());
+-        
+-		
+-		/*Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		System.out.println(u.size() + "\n" + u.nodeAt(0) + "\nmem[" + u.nodeAt(1) + "] := " + u.nodeAt(2));
+-		UnaryExpr e1 = new UnaryExpr(new UnaryExpr(5), ExprType.NEGATION);
+-		System.out.println(e1.size() + "\n" + e1.nodeAt(1));
+-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+-		System.out.println(e5.size() + "\n" + e5.nodeAt(0));*/
+-		
+-		
+-	}
+-}
+diff --git a/src/main/java/ast/TestMutations.java b/src/main/java/ast/TestMutations.java
+deleted file mode 100644
+index 74fdb33..0000000
+--- a/src/main/java/ast/TestMutations.java
++++ /dev/null
+@@ -1,103 +0,0 @@
+-package ast;
+-
+-import java.io.BufferedReader;
+-import java.io.InputStream;
+-import java.io.InputStreamReader;
+-import java.io.Reader;
+-import java.util.LinkedList;
+-
+-import ast.BinaryCondition.Operator;
+-import ast.BinaryExpr.MathOp;
+-import ast.Relation.RelOp;
+-import ast.UnaryExpr.ExprType;
+-import parse.Parser;
+-import parse.ParserFactory;
+-import parse.Tokenizer;
+-import parsertests.ParserTest;
+-
+-public class TestMutations
+-{
+-	public static void main(String[] args)
+-	{
+-		/*
+-		UnaryExpr e = new UnaryExpr(5);
+-		
+-		BinaryExpr be = new BinaryExpr(e, MathOp.DIVIDE, new UnaryExpr(7));
+-		System.out.println(be.toString());
+-		be.acceptMutation(new MutationSwap());
+-		System.out.println(be.toString());
+-		System.out.println(be.toString());
+-		be.acceptMutation(new MutationSwap());
+-		System.out.println(be.toString());
+-		
+-		Update u = new Update(new UnaryExpr(2), new UnaryExpr(9));
+-		System.out.println(u.toString());
+-		u.acceptMutation(new MutationSwap());
+-		System.out.println(u.toString());
+-		
+-		System.out.println(u.getClass().getSimpleName());
+-		System.out.println(be.getClass().getSimpleName());*/
+-		
+-		
+-		
+-		//System.out.println(e.getParent().toString());
+-		
+-		/*Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
+-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
+-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
+-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
+-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
+-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+-		UnaryExpr e1 = new UnaryExpr(2);
+-		UnaryExpr e2 = new UnaryExpr(12);
+-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
+-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
+-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
+-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
+-		Command c = new Command(ll, u6);
+-		Rule r = new Rule(con, c);
+-		System.out.println(c.toString() + "\n");
+-		c.acceptMutation(new MutationSwap());
+-		System.out.println(c.toString() + "\n");
+-		
+-		//u6.acceptMutation(new MutationRemove());
+-		//System.out.println(c.toString());
+-		
+-		c.acceptMutation(new MutationDuplicate());
+-		System.out.println(c.toString());*/
+-		
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+-        Reader r = new BufferedReader(new InputStreamReader(in));
+-        Tokenizer t = new Tokenizer(r);
+-        Parser p = ParserFactory.getParser();
+-        Program prog = p.parse(r);
+-        
+-        System.out.println(prog.mutate());
+-        
+-        //for(int i = 0; i < prog.size(); i++)
+-			//try
+-			{
+-			//	System.out.println("Index #" + i + ": " + prog.nodeAt(i));
+-			}
+-			//catch (IndexOutOfBoundsException e)
+-			{
+-				//System.out.println("NODEAT FAILED");
+-			}
+-        
+-        //int n = (int) (Math.random() * (prog.size() - 1));
+-        //for(int i = 0; i < prog.size(); i++)
+-			//try
+-			//{
+-				//System.out.println(prog.mutate(n, new MutationInsert()).toString());
+-			//}
+-			//catch (NullPointerException e)
+-			//{
+-				//System.out.println("Incompatible node type");
+-			//}
+-		
+-	}
+-}
+\ No newline at end of file
+diff --git a/src/main/java/ast/UnaryExpr.java b/src/main/java/ast/UnaryExpr.java
+index a749244..8493bca 100644
+--- a/src/main/java/ast/UnaryExpr.java
++++ b/src/main/java/ast/UnaryExpr.java
+@@ -1,5 +1,7 @@
+ package ast;
+ 
++import interpret.Interpreter;
++
+ /** A representation of a unary numerical expression that evaluates to an integer. */
+ public class UnaryExpr extends AbstractNode implements Expr
+ {
+@@ -7,6 +9,7 @@ public class UnaryExpr extends AbstractNode implements Expr
+ 	private ExprType type;
+ 	/** The subexpression that this unary expression is based off of. May be null. */
+ 	private Expr exp;
++	/** The integer value contained in this unary expression, if it has one. Only applies to expressions of type CONSTANT. */
+ 	private int value;
+ 	
+ 	/** 
+@@ -32,6 +35,32 @@ public class UnaryExpr extends AbstractNode implements Expr
+ 		this.type = ExprType.CONSTANT;
+ 	}
+ 	
++	/** Returns the type of this unary expression. */
++	public ExprType getExprType()
++	{
++		return type;
++	}
++	
++	/**
++	 * Returns the integer value contained in this unary expression.
++	 * Precondition: the type of this expression must be CONSTANT.
++	 */
++	public int getValue()
++	{
++		return value;
++	}
++	/** Sets the value of {@code value} to {@code val}. */
++	public void setValue(int val)
++	{
++		this.exp = null;
++		this.value = val;
++		this.type = ExprType.CONSTANT;
++	}
++	
++	public Expr getExp()
++	{
++		return exp;
++	}
+ 	@Override
+ 	public int size()
+ 	{
+@@ -101,24 +130,20 @@ public class UnaryExpr extends AbstractNode implements Expr
+ 			case NEGATION:
+ 				sb.append("-" + exp.toString());
+ 				break;
+-			case SENSORVAL:
+-				//if this UnaryExpr has the type of SENSORVAL, then the class type of exp should be Sensor
+-				sb.append(exp.toString());
+-				break;
+ 		}
+ 		return sb;
+ 	}
+ 	
+ 	@Override
+-	public int evaluate()
++	public int acceptEvaluation(Interpreter i)
+ 	{
+-		throw new UnsupportedOperationException();
++		return i.eval(this);
+ 	}
+ 	
+ 	/** An enumeration of all the possible unary expression types. */
+ 	public enum ExprType
+ 	{
+-		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION, SENSORVAL;
++		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION;
+ 	}
+ 
+ 	@Override
+@@ -126,10 +151,4 @@ public class UnaryExpr extends AbstractNode implements Expr
+ 	{
+ 		return NodeType.UNARYEXPR;
+ 	}
+-	
+-	public void setValue(int value) {
+-		this.exp = null;
+-		this.value = value;
+-		this.type = ExprType.CONSTANT;
+-	}
+ }
+\ No newline at end of file
+diff --git a/src/main/java/ast/Update.java b/src/main/java/ast/Update.java
+index a47ebfa..141a459 100644
+--- a/src/main/java/ast/Update.java
++++ b/src/main/java/ast/Update.java
+@@ -22,18 +22,25 @@ public class Update extends AbstractNode implements CommandComponent
+ 		value.setParent(this);
+ 	}
+ 	
++	/** Returns the memory index of this update. */
+ 	public Expr getMemIndex()
+ 	{
+ 		return memIndex;
+ 	}
++	
++	/** Sets the value of {@code memIndex} to {@code newIndex}. */
+ 	public void setMemIndex(Expr newIndex)
+ 	{
+ 		this.memIndex = newIndex;
+ 	}
++	
++	/** Returns the new value to be set for this update. */
+ 	public Expr getValue()
+ 	{
+ 		return value;
+ 	}
++	
++	/** Sets the value of {@code value} to {@code newVal}. */
+ 	public void setValue(Expr newVal)
+ 	{
+ 		this.value = newVal;
+diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
+index 89f4bec..ca92071 100644
+--- a/src/main/java/console/Console.java
++++ b/src/main/java/console/Console.java
+@@ -1,222 +1,311 @@
+ package console;
+ 
+-import java.io.InputStream;
+-import java.io.PrintStream;
++import java.io.*;
+ import java.util.Scanner;
+ 
+-/**
+- * The console user interface for Assignment 5.
+- */
+-public class Console {
+-    private Scanner scan;
+-    public boolean done;
+-    public PrintStream out;
+-
+-    /* =========================== */
+-    /* DO NOT EDIT ABOVE THIS LINE */
+-    /* (except imports...)         */
+-    /* =========================== */
+-
+-    //TODO world representation...
+-
+-    /**
+-     * Starts new random world simulation.
+-     */
+-    public void newWorld() {
+-        //TODO implement
+-    }
+-
+-    /**
+-     * Starts new simulation with world specified in filename.
+-     *
+-     * @param filename
+-     */
+-    public void loadWorld(String filename) {
+-        //TODO implement
+-    }
+-
+-    /**
+-     * Loads critter definition from filename and randomly places
+-     * n critters with that definition into the world.
+-     *
+-     * @param filename
+-     * @param n
+-     */
+-    public void loadCritters(String filename, int n) {
+-        //TODO implement
+-    }
+-
+-    /**
+-     * Advances the world by n time steps.
+-     *
+-     * @param n
+-     */
+-    public void advanceTime(int n) {
+-        //TODO implement
+-    }
+-
+-    /**
+-     * Prints current time step, number of critters, and world
+-     * map of the simulation.
+-     */
+-    public void worldInfo() {
+-        //TODO implement
+-        worldInfo(0, 0);
+-    }
+-
+-    /**
+-     * Prints description of the contents of hex (c,r).
+-     *
+-     * @param c column of hex
+-     * @param r row of hex
+-     */
+-    public void hexInfo(int c, int r) {
+-        //TODO implement and call appropriate method
+-
+-        critterInfo(null, null, null, null);
+-        // OR
+-//        terrainInfo(0);
+-    }
+-
+-    /* =========================== */
+-    /* DO NOT EDIT BELOW THIS LINE */
+-    /* =========================== */
+-
+-    /**
+-     * Be sure to call this function, we will override it to grade.
+-     *
+-     * @param numSteps      The number of steps that have passed in the world.
+-     * @param crittersAlive The number of critters currently alive.
+-     */
+-    protected void worldInfo(int numSteps, int crittersAlive) {
+-        out.println("steps: " + numSteps);
+-        out.println("critters: " + crittersAlive);
+-    }
+-
+-    /**
+-     * Be sure to call this function, we will override it to grade.
+-     *
+-     * @param species  The species of the critter.
+-     * @param mem      The memory of the critter.
+-     * @param program  The program of the critter pretty printed as a String. This should be able to be parsed back to
+-     *                 the same AST.
+-     * @param lastrule The last rule executed by the critter pretty printed as a String. This should be able to be
+-     *                 parsed back to the same AST. If no rule has been executed, this parameter should be null.
+-     */
+-    protected void critterInfo(String species, int[] mem, String program, String lastrule) {
+-        out.println("Species: " + species);
+-        StringBuilder sbmem = new StringBuilder();
+-        for (int i : mem) {
+-            sbmem.append(" ").append(i);
+-        }
+-        out.println("Memory:" + sbmem.toString());
+-        out.println("Program: " + program);
+-        out.println("Last rule: " + lastrule);
+-    }
+-
+-    /**
+-     * Be sure to call this function, we will override it to grade.
+-     *
+-     * @param terrain 0 is empty, -1 is rock, -X is (X-1) food
+-     */
+-    protected void terrainInfo(int terrain) {
+-        if (terrain == 0) {
+-            out.println("Empty");
+-        } else if (terrain == -1) {
+-            out.println("Rock");
+-        } else {
+-            out.println("Food: " + (-terrain - 1));
+-        }
+-    }
+-
+-    /**
+-     * Prints a list of possible commands to the standard output.
+-     */
+-    public void printHelp() {
+-        out.println("new: start a new simulation with a random world");
+-        out.println("load <world_file>: start a new simulation with "
+-                + "the world loaded from world_file");
+-        out.println("critters <critter_file> <n>: add n critters "
+-                + "defined by critter_file randomly into the world");
+-        out.println("step <n>: advance the world by n timesteps");
+-        out.println("info: print current timestep, number of critters "
+-                + "living, and map of world");
+-        out.println("hex <c> <r>: print contents of hex "
+-                + "at column c, row r");
+-        out.println("exit: exit the program");
+-    }
+-
+-    /**
+-     * Constructs a new Console capable of reading a given input.
+-     */
+-    public Console(InputStream in, PrintStream out) {
+-        this.out = out;
+-        scan = new Scanner(in);
+-        done = false;
+-    }
+-
+-    /**
+-     * Constructs a new Console capable of reading the standard input.
+-     */
+-    public Console() {
+-        this(System.in, System.out);
+-    }
+-
+-    /**
+-     * Processes a single console command provided by the user.
+-     */
+-    public void handleCommand() {
+-        out.print("Enter a command or \"help\" for a list of commands.\n> ");
+-        String command = scan.next();
+-        switch (command) {
+-            case "new": {
+-                newWorld();
+-                break;
+-            }
+-            case "load": {
+-                String filename = scan.next();
+-                loadWorld(filename);
+-                break;
+-            }
+-            case "critters": {
+-                String filename = scan.next();
+-                int n = scan.nextInt();
+-                loadCritters(filename, n);
+-                break;
+-            }
+-            case "step": {
+-                int n = scan.nextInt();
+-                advanceTime(n);
+-                break;
+-            }
+-            case "info": {
+-                worldInfo();
+-                break;
+-            }
+-            case "hex": {
+-                int c = scan.nextInt();
+-                int r = scan.nextInt();
+-                hexInfo(c, r);
+-                break;
+-            }
+-            case "help": {
+-                printHelp();
+-                break;
+-            }
+-            case "exit": {
+-                done = true;
+-                break;
+-            }
+-            default:
+-                out.println(command + " is not a valid command.");
+-        }
+-    }
+-
+-    public static void main(String[] args) {
+-        Console console = new Console();
+-        while (!console.done) {
+-            console.handleCommand();
+-        }
+-    }
++import simulation.SimpleCritter;
++import simulation.SimpleWorld;
++import simulation.World;
++
++/** The console user interface for Assignment 5. */
++public class Console
++{
++	private Scanner scan;
++	public boolean done;
++	public PrintStream out;
++
++	/* =========================== */
++	/* DO NOT EDIT ABOVE THIS LINE */
++	/* (except imports...) */
++	/* =========================== */
++
++	// TODO world representation...
++	private SimpleWorld world;
++
++	/** Starts new random world simulation. */
++	public void newWorld()
++	{
++		try
++		{
++			world = new World();
++		}
++		catch (IllegalArgumentException i)
++		{
++			System.err.println("The constants.txt file could not be read. Please check if it exists or is formatted properly.");
++		}
++	}
++
++	/**
++	 * Starts new simulation with world specified in filename.
++	 * @param filename
++	 */
++	public void loadWorld(String filename)
++	{
++		try
++		{
++			world = new World(filename);
++		}
++		catch (FileNotFoundException f)
++		{
++			System.err.println("World file not found. Loading defaultly generated world...");
++			world = new World();
++		}
++		catch (IllegalArgumentException i)
++		{
++			System.err.println("The constants.txt file could not be read. Please check if it is formatted properly.");
++			System.exit(0);
++		}
++	}
++
++	/**
++	 * Loads critter definition from {@code filename} and randomly places n critters with that definition into the world.
++	 * If the file cannot be found, this method prints an error message and loads 0 critters. If the file contains invalid
++	 * attributes, critters are supplied with default memory values. A full list of default critter memory values can be
++	 * found in our overview document.
++	 *
++	 * @param filename
++	 * @param n
++	 */
++	public void loadCritters(String filename, int n)
++	{
++		//This method can't do anything if no world has been created yet.
++		if(world == null)
++		{
++			System.err.println("You must first create a world before you load critters into it.");
++			printHelp();
++			return;
++		}
++		
++		world.loadCritters(filename, n, -1);
++	}
++
++	/**
++	 * Advances the world by n time steps.
++	 * @param n
++	 */
++	public void advanceTime(int n)
++	{
++		//This method can't do anything if no world has been created yet.
++		if(world == null)
++		{
++			System.err.println("You must first create a world before you advance time in it.");
++			printHelp();
++			return;
++		}
++		for(int i = 0; i < n; i++)
++			world.advanceOneTimeStep();
++	}
++
++	/** Prints current time step, number of critters, and world map of the simulation. */
++	public void worldInfo()
++	{
++		//This method can't do anything if no world has been created yet.
++		if(world == null)
++		{
++			System.err.println("You must first create a world before you can view its information.");
++			printHelp();
++			return;
++		}
++		
++		out.println(world.printGrid().toString());
++		worldInfo(world.getTimePassed(), crittersAlive());
++	}
++
++	/** Returns the number of critters still alive. Useful for testing purposes. */
++	public int crittersAlive()
++	{
++		if(world == null)
++			return Integer.MIN_VALUE;
++		return world.numRemainingCritters();
++	}
++	
++	/**
++	 * Prints description of the contents of hex (c,r).
++	 *
++	 * @param c column of hex
++	 * @param r row of hex
++	 */
++	public void hexInfo(int c, int r)
++	{
++		//This method can't do anything if no world has been created yet.
++		if(world == null)
++		{
++			System.err.println("You must first create a world before you can view its information.");
++			printHelp();
++			return;
++		}
++		
++		if(!world.isValidHex(c, r))
++		{
++			System.err.println("Invalid world coordinates.");
++			return;
++		}
++		
++		SimpleCritter sc;
++		int hexAnalysis = world.analyzeHex(c, r);
++		if(hexAnalysis <= 0)
++			terrainInfo(hexAnalysis);
++		
++		sc = world.analyzeCritter(c, r);
++		if(sc == null)
++			return;
++		
++		critterInfo(sc.getName(), sc.getMemoryCopy(), sc.getProgram().toString(), sc.getLastRule());
++	}
++
++	/* =========================== */
++	/* DO NOT EDIT BELOW THIS LINE */
++	/* =========================== */
++
++	/**
++	 * Be sure to call this function, we will override it to grade.
++	 *
++	 * @param numSteps
++	 *            The number of steps that have passed in the world.
++	 * @param crittersAlive
++	 *            The number of critters currently alive.
++	 */
++	protected void worldInfo(int numSteps, int crittersAlive)
++	{
++		out.println("steps: " + numSteps);
++		out.println("critters: " + crittersAlive);
++	}
++
++	/**
++	 * Be sure to call this function, we will override it to grade.
++	 *
++	 * @param species
++	 *            The species of the critter.
++	 * @param mem
++	 *            The memory of the critter.
++	 * @param program
++	 *            The program of the critter pretty printed as a String. This should
++	 *            be able to be parsed back to the same AST.
++	 * @param lastrule
++	 *            The last rule executed by the critter pretty printed as a String.
++	 *            This should be able to be parsed back to the same AST. If no rule
++	 *            has been executed, this parameter should be null.
++	 */
++	protected void critterInfo(String species, int[] mem, String program, String lastrule)
++	{
++		out.println("Species: " + species);
++		StringBuilder sbmem = new StringBuilder();
++		for (int i : mem)
++		{
++			sbmem.append(" ").append(i);
++		}
++		out.println("Memory:" + sbmem.toString());
++		out.println("Program: " + program);
++		out.println("Last rule: " + lastrule);
++	}
++
++	/**
++	 * Be sure to call this function, we will override it to grade.
++	 *
++	 * @param terrain
++	 *            0 is empty, -1 is rock, -X is (X-1) food
++	 */
++	protected void terrainInfo(int terrain)
++	{
++		if (terrain == 0)
++			out.println("Empty");
++		else if (terrain == -1)
++			out.println("Rock");
++		else
++			out.println("Food: " + (-terrain - 1));
++	}
++
++	/** Prints a list of possible commands to the standard output. */
++	public void printHelp()
++	{
++		out.println("new: start a new simulation with a random world");
++		out.println("load <world_file>: start a new simulation with " + "the world loaded from world_file");
++		out.println("critters <critter_file> <n>: add n critters " + "defined by critter_file randomly into the world");
++		out.println("step <n>: advance the world by n timesteps");
++		out.println("info: print current timestep, number of critters " + "living, and map of world");
++		out.println("hex <c> <r>: print contents of hex " + "at column c, row r");
++		out.println("exit: exit the program");
++	}
++
++	/** Constructs a new Console capable of reading a given input. */
++	public Console(InputStream in, PrintStream out)
++	{
++		this.out = out;
++		scan = new Scanner(in);
++		done = false;
++	}
++
++	/** Constructs a new Console capable of reading the standard input. */
++	public Console()
++	{
++		this(System.in, System.out);
++	}
++
++	/** Processes a single console command provided by the user. */
++	public void handleCommand()
++	{
++		out.print("Enter a command or \"help\" for a list of commands.\n> ");
++		String command = scan.next();
++		switch (command)
++		{
++			case "new":
++			{
++				newWorld();
++				break;
++			}
++			case "load":
++			{
++				String filename = scan.next();
++				loadWorld(filename);
++				break;
++			}
++			case "critters":
++			{
++				String filename = scan.next();
++				int n = scan.nextInt();
++				loadCritters(filename, n);
++				break;
++			}
++			case "step":
++			{
++				int n = scan.nextInt();
++				advanceTime(n);
++				break;
++			}
++			case "info":
++			{
++				worldInfo();
++				break;
++			}
++			case "hex":
++			{
++				int c = scan.nextInt();
++				int r = scan.nextInt();
++				hexInfo(c, r);
++				break;
++			}
++			case "help":
++			{
++				printHelp();
++				break;
++			}
++			case "exit":
++			{
++				done = true;
++				break;
++			}
++			default:
++				out.println(command + " is not a valid command.");
++		}
++	}
++
++	public static void main(String[] args)
++	{
++		Console console = new Console();
++		while (!console.done)
++		{
++			console.handleCommand();
++		}
++	}
+ 
+ }
+diff --git a/src/main/java/interpret/Interpreter.java b/src/main/java/interpret/Interpreter.java
+index e205039..1a57929 100644
+--- a/src/main/java/interpret/Interpreter.java
++++ b/src/main/java/interpret/Interpreter.java
+@@ -1,36 +1,52 @@
+ package interpret;
+ 
+-import ast.Condition;
+-import ast.Expr;
+-import ast.Program;
++import ast.BinaryCondition;
++import ast.Relation;
++import ast.BinaryExpr;
++import ast.UnaryExpr;
++import ast.Sensor;
+ 
+ /**
+  * An example interface for interpreting a critter program. This is just a starting
+  * point and may be changed as much as you like.
+  */
+-public interface Interpreter {
++public interface Interpreter
++{
++	/** Executes the results of one critter turn. */
++	public void simulateCritterTurn();
++
+     /**
+-     * Execute program {@code p} until either the maximum number of rules per
+-     * turn is reached or some rule whose command contains an action is
+-     * executed.
+-     * @param p
+-     * @return a result containing the action to be performed;
+-     * the action may be null if the maximum number of rules
+-     * per turn was exceeded.
++     * Evaluates the given binary condition.
++     * @param c
++     * @return a boolean that results from evaluating c.
+      */
+-    Outcome interpret(Program p);
+-
++    boolean eval(BinaryCondition c);
++    
+     /**
+-     * Evaluate the given condition.
++     * Evaluates the given relation.
+      * @param c
+      * @return a boolean that results from evaluating c.
+      */
+-    boolean eval(Condition c);
++    boolean eval(Relation c);
+ 
+     /**
+-     * Evaluate the given expression.
++     * Evaluates the given binary expression.
++     * @param e
++     * @return an integer that results from evaluating e.
++     */
++    int eval(BinaryExpr e);
++    
++    /**
++     * Evaluates the given unary expression.
++     * @param e
++     * @return an integer that results from evaluating e.
++     */
++    int eval(UnaryExpr e);
++    
++    /**
++     * Evaluates the given sensor.
+      * @param e
+      * @return an integer that results from evaluating e.
+      */
+-    int eval(Expr e);
++    int eval(Sensor s);
+ }
+diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
+new file mode 100644
+index 0000000..18973a1
+--- /dev/null
++++ b/src/main/java/interpret/InterpreterImpl.java
+@@ -0,0 +1,265 @@
++package interpret;
++
++import ast.*;
++import ast.Action.ActType;
++import ast.Node.NodeType;
++import simulation.AbstractWorld;
++import simulation.SimpleCritter;
++
++import java.util.LinkedList;
++
++/** Interprets and executes the AST of a critter. */
++public class InterpreterImpl implements Interpreter
++{
++	/** The critter whose AST this Interpreter interprets. */
++	private SimpleCritter c;
++	/** The world in which the critter inhabits. */
++	private AbstractWorld world;
++	
++	/** Creates a new InterpreterImpl. */
++	public InterpreterImpl(SimpleCritter cr, AbstractWorld aw)
++	{
++		c = cr;
++		world = aw;
++	}
++	
++	/** Executes the results of one critter turn. */
++	public void simulateCritterTurn()
++	{
++		Action a = interpret(c.getProgram());
++		executeAction(a);
++	}
++	
++	/**
++     * Execute program {@code p} until either the maximum number of rules per turn is reached or some rule
++     * whose command contains an action is executed.
++     * @param p
++     * @return the action to be performed
++     */
++	private Action interpret(Program p)
++	{
++		LinkedList<Rule> rl = p.getRulesList();
++		Action a = null;
++		boolean actionInterpreted = false;
++		while (!actionInterpreted && c.readMemory(5) < world.getMaxRules())
++		{
++			for (Rule r : rl)
++			{
++				boolean ruleCondition = r.getCond().acceptEvaluation(this);
++				if(ruleCondition)
++				{
++					Command ruleCommand = r.getComm();
++					for(Update u : ruleCommand.getUpdateList())
++						applyUpdate(u);
++					if(ruleCommand.getLast().getType() == NodeType.ACTION)
++					{
++						a = (Action) ruleCommand.getLast();
++						actionInterpreted = true;
++					}
++					else
++						applyUpdate((Update) ruleCommand.getLast());
++					c.setLastRule(r.toString());
++					break;
++				}
++			}
++			c.incrementPass();
++		}
++		c.setMemory(0, 5);
++		
++		if(a == null)
++			a = new Action(ActType.WAIT);
++		return a;
++	}
++	
++	/** Executes an action returned by the {@code interpret} method. */
++	private void executeAction(Action a)
++	{
++		int val = 0;
++		if(a.getVal() != null)
++			val = a.getVal().acceptEvaluation(this);
++		
++		switch(a.getActType())
++		{
++			case FORWARD:
++				world.moveCritter(c, true);
++				break;
++			case BACKWARD:
++				world.moveCritter(c, false);
++				break;
++			case LEFT:
++				world.turnCritter(c, false);
++				break;
++			case RIGHT:
++				world.turnCritter(c, true);
++				break;
++			case EAT:
++				world.critterEat(c);
++				break;
++			case ATTACK:
++				world.critterBattle(c);
++				break;
++			case GROW:
++				world.growCritter(c);
++				break;
++			case BUD:
++				world.critterBud(c);
++				break;
++			case MATE:
++				world.critterMate(c);
++				break;
++			case TAG:
++				world.critterTag(c, val);
++				break;
++			case SERVE:
++				world.critterServe(c, val);
++				break;
++			case WAIT:
++				world.critterSoakEnergy(c);
++				break;
++		}
++	}
++	/** Applies the effects of a single update to a critter. */
++	private void applyUpdate(Update u)
++	{
++		int index = u.getMemIndex().acceptEvaluation(this);
++		int val = u.getValue().acceptEvaluation(this);
++		c.setMemory(val, index);
++	}
++
++	@Override
++	public boolean eval(BinaryCondition c)
++	{
++		boolean result = false;
++		boolean left = c.getLeft().acceptEvaluation(this);
++		boolean right = c.getRight().acceptEvaluation(this);
++		switch(c.getOp())
++		{
++			case AND:
++				result = left && right;
++				break;
++			case OR:
++				result = left || right;
++				break;
++		}
++		return result;
++	}
++	
++	@Override
++	public boolean eval(Relation r)
++	{
++		boolean result = false;
++		if(r.getCond() != null)
++		{
++			result = r.getCond().acceptEvaluation(this);
++			return result;
++		}
++		int left = r.getLeft().acceptEvaluation(this);
++		int right = r.getRight().acceptEvaluation(this);
++		switch(r.getRelOp())
++		{
++			case LESS:
++				result = left < right;
++				break;
++			case LESSOREQ:
++				result = left <= right;
++				break;
++			case GREATER:
++				result = left > right;
++				break;
++			case GREATEROREQ:
++				result = left >= right;
++				break;
++			case EQUAL:
++				result = left == right;
++				break;
++			case NOTEQUAL:
++				result = left != right;
++				break;
++			case ISCOND:
++				result = r.getCond().acceptEvaluation(this);
++				break;
++		}
++		return result;
++	}
++	
++	@Override
++	public int eval(BinaryExpr e)
++	{
++		int result = 0;
++		int left = e.getLeft().acceptEvaluation(this);
++		int right = e.getRight().acceptEvaluation(this);
++		switch(e.getOperator())
++		{
++			case ADD:
++				result = left + right;
++				break;
++			case SUBTRACT:
++				result = left - right;
++				break;
++			case MULTIPLY:
++				result = left * right;
++				break;
++			case DIVIDE:
++				if(right != 0)
++					result = left / right;
++				break;
++			case MOD:
++				if(right != 0)
++					result = left % right;
++				break;
++		}
++		return result;
++	}
++	
++	@Override
++	public int eval(UnaryExpr e)
++	{
++		int result = 0;
++		switch(e.getExprType())
++		{
++			case CONSTANT:
++				result = e.getValue();
++				break;
++			case MEMORYVAL:
++				int index = e.getExp().acceptEvaluation(this);
++				result = c.readMemory(index);
++				if(result == Integer.MIN_VALUE)
++					result = 0;
++				break;
++			case EXPRESSION:
++				result = e.getExp().acceptEvaluation(this);
++				break;
++			case NEGATION:
++				result = -1 * e.getExp().acceptEvaluation(this);
++				break;
++		}
++		return result;
++	}
++	
++	@Override
++	public int eval(Sensor s)
++	{
++		int result = 0;
++		int index;
++		switch(s.getSensorType())
++		{
++			case NEARBY:
++				index = s.getSensorIndex().acceptEvaluation(this);
++				result = world.searchNearby(c, index);
++				break;
++			case AHEAD:
++				index = s.getSensorIndex().acceptEvaluation(this);
++				result = world.searchAhead(c, index);
++				break;
++			case RANDOM:
++				index = s.getSensorIndex().acceptEvaluation(this);
++				if(index < 2)
++					result = 0;
++				else
++					result = (int) (Math.random() * index);
++			case SMELL:
++				result = 0;
++		}
++		return result;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/interpret/Outcome.java b/src/main/java/interpret/Outcome.java
+deleted file mode 100644
+index 6f6ea20..0000000
+--- a/src/main/java/interpret/Outcome.java
++++ /dev/null
+@@ -1,9 +0,0 @@
+-package interpret;
+-
+-/**
+- * An example interface for representing an outcome of interpreting
+- * a critter program.
+- */
+-public interface Outcome {
+-    // TODO define appropriate operations
+-}
+diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
+index a702d28..0d04293 100644
+--- a/src/main/java/parse/ParserImpl.java
++++ b/src/main/java/parse/ParserImpl.java
+@@ -18,10 +18,10 @@ class ParserImpl implements Parser {
+ 	public Program parse(Reader r) {
+ 		this.tokens = new Tokenizer(r);
+ 		try {
+-			this.programAST = parseProgram(tokens);
+-		} catch (SyntaxError e) {
+-			System.out.println("The program inputted does not have the proper syntax.");
+-			System.exit(0);
++			programAST = parseProgram(tokens);
++		}
++		catch (SyntaxError e) {
++			programAST = null;
+ 		}
+ 
+ 		return this.programAST;
+@@ -39,7 +39,9 @@ class ParserImpl implements Parser {
+ 	public static ProgramImpl parseProgram(Tokenizer t) throws SyntaxError {
+ 		LinkedList<Rule> RuleList = new LinkedList<Rule>();
+ 		while (t.hasNext()) {
+-			RuleList.add(parseRule(t));
++			Rule r = parseRule(t);
++			RuleList.add(r);
++			
+ 		}
+ 		return new ProgramImpl(RuleList);
+ 	}
+@@ -49,7 +51,6 @@ class ParserImpl implements Parser {
+ 		consume(t, TokenType.ARR);
+ 		Command command = parseCommand(t);
+ 		consume(t, TokenType.SEMICOLON);
+-		//System.out.println((new Rule(condition, command)).toString()); //TODO remove when done tesing
+ 		return new Rule(condition, command);
+ 	}
+ 	
+@@ -174,7 +175,6 @@ class ParserImpl implements Parser {
+ 		Condition conj = parseConjunction(t);
+ 		while (t.peek().getType() == TokenType.OR) {
+ 			consume(t, TokenType.OR);
+-			//System.out.println((new BinaryCondition(conj, Operator.OR, parseConjunction(t)).toString())); //TODO remove when done
+ 			return new BinaryCondition(conj, Operator.OR, parseConjunction(t));
+ 		}
+ 		return conj;
+@@ -186,7 +186,6 @@ class ParserImpl implements Parser {
+ 			consume(t, TokenType.AND);
+ 			return new BinaryCondition(rel, Operator.AND, parseRelation(t));
+ 		}
+-		//System.out.println(condition.toString());
+ 		return rel;
+ 	}
+ 	public static Relation parseRelation(Tokenizer t) throws SyntaxError {
+@@ -200,8 +199,6 @@ class ParserImpl implements Parser {
+ 		}
+ 		
+ 		Expr expression = parseExpression(t);
+-		//System.out.println(expression.toString());
+-		//Condition condition;
+ 		if (t.peek().getType().category() == TokenCategory.RELOP) {
+ 			String relationOperator = t.peek().toString();
+ 			consume(t, t.peek().getType());
+diff --git a/src/main/java/parse/Token.java b/src/main/java/parse/Token.java
+index a1f023e..2ba46cf 100644
+--- a/src/main/java/parse/Token.java
++++ b/src/main/java/parse/Token.java
+@@ -186,8 +186,8 @@ class Token {
+ 		 * Constructs a new error token containing the value {@code v}.
+ 		 * @param v - String value for this error token.
+ 		 */
+-		ErrorToken(String v) {
+-			super(TokenType.ERROR, -1);
++		ErrorToken(String v, int lineNo) {
++			super(TokenType.ERROR, lineNo);
+ 			value = v;
+ 		}
+ 
+diff --git a/src/main/java/parse/Tokenizer.java b/src/main/java/parse/Tokenizer.java
+index 384ab04..8547ada 100644
+--- a/src/main/java/parse/Tokenizer.java
++++ b/src/main/java/parse/Tokenizer.java
+@@ -1,510 +1,460 @@
+ package parse;
+ 
++import static parse.TokenType.ARR;
++import static parse.TokenType.ASSIGN;
++import static parse.TokenType.DIV;
++import static parse.TokenType.EQ;
++import static parse.TokenType.GE;
++import static parse.TokenType.GT;
++import static parse.TokenType.LBRACE;
++import static parse.TokenType.LBRACKET;
++import static parse.TokenType.LE;
++import static parse.TokenType.LPAREN;
++import static parse.TokenType.LT;
++import static parse.TokenType.MINUS;
++import static parse.TokenType.MUL;
++import static parse.TokenType.NE;
++import static parse.TokenType.PLUS;
++import static parse.TokenType.RBRACE;
++import static parse.TokenType.RBRACKET;
++import static parse.TokenType.RPAREN;
++import static parse.TokenType.SEMICOLON;
++
+ import java.io.BufferedReader;
+ import java.io.IOException;
+ import java.io.Reader;
+ import java.util.Iterator;
+ 
++import parse.Token.EOFToken;
++import parse.Token.ErrorToken;
++import parse.Token.NumToken;
++
+ /**
+  * A Tokenizer turns a Reader into a stream of tokens that can be iterated over
+  * using a {@code for} loop.
+  */
+ public class Tokenizer implements Iterator<Token> {
+ 
+-	/**
+-	 * BufferedReader to read from the {@code Reader} provided in the constructor,
+-	 * not {@code null}.
+-	 */
+-	private final BufferedReader br;
+-
+-	/** Builder to store read characters. */
+-	private final StringBuilder sb;
+-
+-	/**
+-	 * The number of the line being parsed from the reader. Starts at 1 and always
+-	 * equals 1 + the number of new line characters encountered.
+-	 */
+-	private int lineNo;
+-
+-	/**
+-	 * {@code tokenReady} is {@code false} if a token is not immediately available
+-	 * to be returned from {@code next()}, and {@code true} if a token is
+-	 * immediately ready to be returned from {@code next()}.
+-	 */
+-	private boolean tokenReady;
+-
+-	/**
+-	 * The most recent token processed by this Tokenizer, or an error token. Not
+-	 * {@code null}.
+-	 */
+-	private Token curTok;
+-
+-	/**
+-	 * {@code false} if the EOF has not been encountered, {@code true} if it has
+-	 * been encountered
+-	 */
+-	private boolean atEOF;
+-
+-	/**
+-	 * Create a Tokenizer that reads from the specified reader
+-	 * 
+-	 * @param r
+-	 *            - The source from which the Tokenizer lexes input into Tokens
+-	 */
+-	public Tokenizer(Reader r) {
+-		br = new BufferedReader(r);
+-		sb = new StringBuilder();
+-		lineNo = 1;
+-		tokenReady = false;
+-		curTok = new Token.ErrorToken("Tokenizer has not yet begun reading");
+-		atEOF = false;
+-	}
+-
+-	/**
+-	 * Returns {@code true} if the iteration has more meaningful elements. (In other
+-	 * words, returns {@code true} if {@link #next} would return a non-EOF element
+-	 * rather than throwing an exception or returning EOF.)
+-	 *
+-	 * @return {@code true} if the iteration has more meaningful elements
+-	 */
+-	@Override
+-	public boolean hasNext() {
+-		if (!tokenReady) {
+-			try {
+-				lexOneToken();
+-			} catch (IOException e) {
+-				throw new TokenizerIOException(e);
+-			} catch (EOFException e) {
+-				return false;
+-			}
+-		}
+-		return true;
+-	}
+-
+-	@Override
+-	public Token next() throws TokenizerIOException {
+-		Token tok = peek();
+-		tokenReady = false;
+-		return tok;
+-	}
+-
+-	/**
+-	 * Return the next token in the program without consuming the token.
+-	 *
+-	 * @return the next token, without consuming it
+-	 * @throws IOException
+-	 *             if an IOException was thrown while trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF was encountered while trying to lex the next token
+-	 */
+-	public Token peek() throws TokenizerIOException {
+-		if (!tokenReady && !atEOF) {
+-			try {
+-				lexOneToken();
+-			} catch (IOException e) {
+-				throw new TokenizerIOException(e);
+-			} catch (EOFException e) {
+-				// EOFException is thrown by encounteredEOF(), which should set
+-				// curTok to an EOFToken, so this catch block should be empty.
+-			}
+-		}
+-		return curTok;
+-	}
+-
+-	@Override
+-	public void remove() {
+-		tokenReady = false;
+-	}
+-
+-	/** Close the reader opened by this tokenizer. */
+-	void close() {
+-		try {
+-			br.close();
+-		} catch (IOException e) {
+-			System.out.println("IOException:");
+-			System.out.println(e.getMessage());
+-			e.printStackTrace();
+-		}
+-	}
+-
+-	/**
+-	 * Read one token from the reader. One token is always produced if the end of
+-	 * file is not encountered, but that token may be an error token.
+-	 *
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexOneToken() throws IOException, EOFException {
+-		setBuilderToFirstMeaningfulChar();
+-		char c = sb.charAt(0);
+-
+-		switch (c) {
+-		case '[':
+-			setNextTokenAndReset(TokenType.LBRACKET);
+-			break;
+-		case ']':
+-			setNextTokenAndReset(TokenType.RBRACKET);
+-			break;
+-		case '(':
+-			setNextTokenAndReset(TokenType.LPAREN);
+-			break;
+-		case ')':
+-			setNextTokenAndReset(TokenType.RPAREN);
+-			break;
+-		case '{':
+-			setNextTokenAndReset(TokenType.LBRACE);
+-			break;
+-		case '}':
+-			setNextTokenAndReset(TokenType.RBRACE);
+-			break;
+-		case ';':
+-			setNextTokenAndReset(TokenType.SEMICOLON);
+-			break;
+-		case '=':
+-			setNextTokenAndReset(TokenType.EQ);
+-			break;
+-		case '+':
+-			setNextTokenAndReset(TokenType.PLUS);
+-			break;
+-		case '*':
+-			setNextTokenAndReset(TokenType.MUL);
+-			break;
+-		case '/':
+-			if (consume('/')) {
+-				br.readLine();
+-				resetStringBuilder();
+-				setBuilderToFirstMeaningfulChar();
+-			} else {
+-				setNextTokenAndReset(TokenType.DIV);
+-			}
+-			break;
+-		case '<':
+-			lexLAngle();
+-			break;
+-		case '>':
+-			lexRAngle();
+-			break;
+-		case '-':
+-			lexDash();
+-			break;
+-		case ':':
+-			if (consume('='))
+-				setNextTokenAndReset(TokenType.ASSIGN);
+-			break;
+-		case '!':
+-			if (consume('='))
+-				setNextTokenAndReset(TokenType.NE);
+-			break;
+-		default:
+-			if (Character.isLetter(c))
+-				lexIdentifier();
+-			else if (Character.isDigit(c))
+-				lexNum();
+-			else
+-				unexpected();
+-		}
+-	}
+-
+-	/**
+-	 * Consumes whitespace up until the first non-whitespace character, and sets the
+-	 * builder to that character
+-	 *
+-	 * @throws IOException
+-	 *             if an IOException is encountered while reading from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void setBuilderToFirstMeaningfulChar() throws IOException, EOFException {
+-		// Make sure there isn't any leftover from a previous lexing operation
+-		assert sb.length() <= 1;
+-		char c = sb.length() == 1 ? c = sb.charAt(0) : getNextCharAndAppend();
+-
+-		// consume whitespace
+-		while (Character.isWhitespace(c)) {
+-			if (c == '\n')
+-				++lineNo;
+-			c = getNextCharAndAppend();
+-		}
+-
+-		resetBuilderWith(c);
+-	}
+-
+-	/**
+-	 * Lexes a left angle bracket. May be called only when the previously read
+-	 * character is '<'.
+-	 * 
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexLAngle() throws IOException, EOFException {
+-		int c = nextChar(false);
+-		if (c == -1) {
+-			setNextTokenAndReset(TokenType.LT);
+-		} else {
+-			char cc = (char) c;
+-			sb.append(cc);
+-			if (cc == '=')
+-				setNextTokenAndReset(TokenType.LE);
+-			else
+-				setNextTokenAndResetWith(TokenType.LT, cc);
+-		}
+-	}
+-
+-	/**
+-	 * Lexes a right angle bracket. May be called only when the previously read
+-	 * character '>'.
+-	 * 
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexRAngle() throws IOException, EOFException {
+-		int c = nextChar(false);
+-		if (c == -1) {
+-			setNextTokenAndReset(TokenType.GT);
+-		} else {
+-			char cc = (char) c;
+-			sb.append(cc);
+-			if (cc == '=')
+-				setNextTokenAndReset(TokenType.GE);
+-			else
+-				setNextTokenAndResetWith(TokenType.GT, cc);
+-		}
+-	}
+-
+-	/**
+-	 * Lexes a dash character. If a dash is followed by another dash, then it is
+-	 * part of an arrow. Otherwise it must represent a minus sign.
+-	 * 
+-	 * May only be called when the previously read char is a dash '-'.
+-	 * 
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexDash() throws IOException, EOFException {
+-		int c = nextChar(false);
+-		if (c == -1) {
+-			setNextTokenAndReset(TokenType.MINUS);
+-		} else {
+-			char cc = (char) c;
+-			sb.append(cc);
+-			if (cc == '-') {
+-				if (consume('>'))
+-					setNextTokenAndReset(TokenType.ARR);
+-			} else
+-				setNextTokenAndResetWith(TokenType.MINUS, cc);
+-		}
+-	}
+-
+-	/**
+-	 * Lexes an identifier. May be called only when the previously read character is
+-	 * a letter.
+-	 * 
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexIdentifier() throws IOException, EOFException {
+-		int c;
+-		for (c = nextChar(false); c != -1 && Character.isLetter(c); c = nextChar(false))
+-			sb.append((char) c);
+-
+-		String id = sb.toString();
+-		TokenType tt = TokenType.getTypeFromString(id);
+-		if (tt != null)
+-			setNextTokenAndReset(tt);
+-		else
+-			unexpected();
+-
+-		if (c != -1)
+-			sb.append((char) c);
+-	}
+-
+-	/**
+-	 * Lexes a number. May be called only when the previously read character is a
+-	 * digit.
+-	 * 
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and a token cannot be produced.
+-	 */
+-	private void lexNum() throws IOException, EOFException {
+-		int c;
+-		for (c = nextChar(false); c != -1 && Character.isDigit(c); c = nextChar(false))
+-			sb.append((char) c);
+-
+-		try {
+-			String num = sb.toString();
+-			int val = Integer.parseInt(num);
+-			curTok = new Token.NumToken(val, lineNo);
+-			tokenReady = true;
+-			resetStringBuilder();
+-			if (c != -1)
+-				sb.append((char) c);
+-		} catch (NumberFormatException e) {
+-			unexpected();
+-		}
+-	}
+-
+-	/**
+-	 * Read the next character from the reader, treating EOF as an error. If
+-	 * successful, append the character to the buffer.
+-	 *
+-	 * @return The next character
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read the next char
+-	 * @throws EOFException
+-	 *             if EOF is encountered
+-	 */
+-	private char getNextCharAndAppend() throws IOException, EOFException {
+-		char c = (char) nextChar(true);
+-		sb.append(c);
+-		return c;
+-	}
+-
+-	/**
+-	 * Read the next character from the reader. If {@code exceptionOnEOF}, treat EOF
+-	 * as an error. If successful, append the character to the buffer.
+-	 *
+-	 * @param exceptionOnEOF
+-	 *            {@code true} if EOF should be treated as an error
+-	 * @return The integer representation of the next character
+-	 * @throws IOException
+-	 *             if an {@code IOException} is thrown when trying to read from the
+-	 *             source Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered and isEOFerror is true
+-	 */
+-	private int nextChar(boolean exceptionOnEOF) throws IOException, EOFException {
+-		int c = br.read(); // returns -1 if the stream's end has been reached
+-		if (exceptionOnEOF && c == -1)
+-			encounteredEOF();
+-		return c;
+-	}
+-
+-	/**
+-	 * Sets the next token to be a token of {@code tokenType} and clears the
+-	 * {@code StringBuilder}.
+-	 * 
+-	 * @param tokenType
+-	 *            - the type of the token to set, not {@code null}
+-	 */
+-	private void setNextTokenAndReset(TokenType tokenType) {
+-		curTok = new Token(tokenType, lineNo);
+-		tokenReady = true;
+-		resetStringBuilder();
+-	}
+-
+-	/**
+-	 * Sets the next token to be a token of {@code tokenType}, clears the
+-	 * {@code StringBuilder}, and inserts {@code c} to begin the next string.
+-	 * 
+-	 * @param tokenType
+-	 *            - the type of the token to set, not {@code null}
+-	 * @param c
+-	 *            - the character to use at the start of the string builder
+-	 */
+-	private void setNextTokenAndResetWith(TokenType tokenType, char c) {
+-		setNextTokenAndReset(tokenType);
+-		sb.append(c);
+-	}
+-
+-	/**
+-	 * Resets the StringBuilder and starts a new string with {@code c}.
+-	 * 
+-	 * @param c
+-	 *            - the character with which to start a new string
+-	 */
+-	private void resetBuilderWith(char c) {
+-		resetStringBuilder();
+-		sb.append(c);
+-	}
+-
+-	/** Resets the StringBuilder {@code sb} to clear its string. */
+-	private void resetStringBuilder() {
+-		sb.setLength(0);
+-	}
+-
+-	/**
+-	 * Read the next character and determine whether it is the expected character.
+-	 * If not, the current buffer is an error
+-	 *
+-	 * @param expected
+-	 *            - The expected next character
+-	 * @return true if the next character is as expected
+-	 * @throws IOException
+-	 *             if an IOException was thrown when trying to read from the source
+-	 *             Reader
+-	 * @throws EOFException
+-	 *             if EOF is encountered
+-	 */
+-	private boolean consume(char expected) throws IOException, EOFException {
+-		int c = getNextCharAndAppend();
+-		if (c == expected)
+-			return true;
+-		unexpected();
+-		return false;
+-	}
+-
+-	/**
+-	 * Makes the current token an error token with the current contents of the
+-	 * buffer.
+-	 */
+-	private void unexpected() {
+-		curTok = new Token.ErrorToken(sb.toString());
+-		tokenReady = true;
+-		resetStringBuilder();
+-	}
+-
+-	/**
+-	 * Make the contents of the current buffer into an EOFToken, clearing the buffer
+-	 * in the process, set atEOF to true, and set the current token to the newly
+-	 * generated EOFToken, setting tokenReady in the process
+-	 */
+-	private void encounteredEOF() throws EOFException {
+-		curTok = new Token.EOFToken(sb.toString(), lineNo);
+-		resetStringBuilder();
+-		atEOF = true;
+-		tokenReady = true;
+-		throw new EOFException();
+-	}
+-
+-	/** "Helper" exception to indicate that EOF was reached */
+-	static class EOFException extends Exception {
+-		/** Unique serial version ID. @see Serializable#serialVersionUID */
+-		private static final long serialVersionUID = -7333947165525391472L;
+-	}
+-
+-	/** "Helper" exception to indicate an IO exception while tokenizing. */
+-	static class TokenizerIOException extends RuntimeException {
+-		/** Unique serial version ID. @see Serializable#serialVersionUID */
+-		private static final long serialVersionUID = 8014027094822746940L;
+-
+-		/**
+-		 * Constructs a new {@code TokenizerIOException} caused by {@code cause}.
+-		 * 
+-		 * @param cause
+-		 *            - the cause of the IOException
+-		 */
+-		TokenizerIOException(Throwable cause) {
+-			super(cause);
+-		}
+-	}
+-}
++    private final BufferedReader br;
++    private final StringBuilder buf;
++    private int lineNo;
++    /**
++     * {@code tokenReady} is {@code false} if a token is not immediately
++     * available to be returned from {@code next()}, and {@code true} if a token
++     * is immediately ready to be returned from {@code next()}.
++     */
++    private boolean tokenReady = false;
++    private Token curTok =
++            new ErrorToken("Tokenizer has not yet begun reading", -1);
++    private boolean atEOF = false;
++
++    /**
++     * Create a Tokenizer that reads from the specified reader
++     * 
++     * @param r
++     *            The source from which the Tokenizer lexes input into Tokens
++     */
++    Tokenizer(Reader r) {
++        br = new BufferedReader(r);
++        buf = new StringBuilder();
++        lineNo = 1;
++    }
++
++    /**
++     * Returns {@code true} if the iteration has more meaningful elements. (In
++     * other words, returns {@code true} if {@link #next} would return a non-EOF
++     * element rather than throwing an exception or returning EOF.)
++     *
++     * @return {@code true} if the iteration has more meaningful elements
++     */
++    @Override
++    public boolean hasNext() {
++        if (!tokenReady) {
++            try {
++                lexOneToken();
++            }
++            catch (IOException e) {
++                throw new TokenizerIOException(e);
++            }
++            catch (EOFException e) {
++                return false;
++            }
++        }
++        return true;
++    }
++
++    @Override
++    public Token next() throws TokenizerIOException {
++        Token tok = peek();
++        tokenReady = false;
++        return tok;
++    }
++
++    /**
++     * Return the next token in the program without consuming the token.
++     * 
++     * @return the next token, without consuming it
++     * @throws IOException
++     *             if an IOException was thrown while trying to read from the
++     *             source Reader
++     * @throws EOFException
++     *             if EOF was encountered while trying to lex the next token
++     */
++    public Token peek() throws TokenizerIOException {
++        if (!tokenReady && !atEOF) try {
++            lexOneToken();
++        }
++        catch (IOException e) {
++            throw new TokenizerIOException(e);
++        }
++        catch (EOFException e) {
++            // EOFException is thrown by encounteredEOF(), which should set
++            // curTok to an EOFToken
++        }
++        return curTok;
++    }
++
++    @Override
++    public void remove() {
++        throw new UnsupportedOperationException();
++    }
++
++    /**
++     * Close the reader opened by this tokenizer.
++     */
++    void close() {
++        try {
++            br.close();
++        }
++        catch (IOException e) {
++            System.out.println("IOException:");
++            System.out.println(e.getMessage());
++            e.printStackTrace();
++        }
++    }
++
++    /**
++     * Read one token from the reader. One token is always produced if the end
++     * of file is not encountered, but that token may be an error token.
++     * 
++     * @throws IOException
++     *             if an IOException was thrown when trying to read from the
++     *             source Reader
++     * @throws EOFException
++     *             if EOF is encountered and a token cannot be produced.
++     */
++    private void lexOneToken() throws IOException, EOFException {
++        setBufToFirstMeaningfulChar();
++        char c = buf.charAt(0);
++
++        switch (c) {
++        case '[':
++            setNextTokenAndReset(LBRACKET);
++            break;
++        case ']':
++            setNextTokenAndReset(RBRACKET);
++            break;
++        case '(':
++            setNextTokenAndReset(LPAREN);
++            break;
++        case ')':
++            setNextTokenAndReset(RPAREN);
++            break;
++        case '{':
++            setNextTokenAndReset(LBRACE);
++            break;
++        case '}':
++            setNextTokenAndReset(RBRACE);
++            break;
++        case ';':
++            setNextTokenAndReset(SEMICOLON);
++            break;
++        case '=':
++            setNextTokenAndReset(EQ);
++            break;
++        case '+':
++            setNextTokenAndReset(PLUS);
++            break;
++        case '*':
++            setNextTokenAndReset(MUL);
++            break;
++        case '/':
++            lexSlash();
++            break;
++        case '<':
++            lexLAngle();
++            break;
++        case '>':
++            lexRAngle();
++            break;
++        case '-':
++            lexDash();
++            break;
++        case ':':
++            if (consume('=')) setNextTokenAndReset(ASSIGN);
++            break;
++        case '!':
++            if (consume('=')) setNextTokenAndReset(NE);
++            break;
++        default:
++            if (Character.isLetter(c))
++                lexIdentifier();
++            else if (Character.isDigit(c))
++                lexNum();
++            else unexpected();
++        }
++    }
++
++    /**
++     * Consumes whitespace up until the first non-whitespace character, and sets
++     * the buffer to that character
++     * 
++     * @throws IOException
++     *             if an IOException is encountered while reading from the
++     *             source Reader
++     */
++    private void setBufToFirstMeaningfulChar() throws IOException, EOFException {
++        // Make sure there isn't any leftover from a previous lexing operation
++        assert buf.length() <= 1;
++        char c = buf.length() == 1 ? c = buf.charAt(0) : getNextCharAndAppend();
++
++        // consume whitespaces
++        while (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
++            if (c == '\n') lineNo++;
++            c = getNextCharAndAppend();
++        }
++
++        resetBufferWith(c);
++    }
++
++    private void lexSlash() throws IOException, EOFException {
++        int c = nextChar(false);
++        if (c == -1)
++            setNextTokenAndReset(DIV);
++        else {
++            char cc = (char) c;
++            buf.append(cc);
++            if (cc == '/') {
++                // rest-of-line comment
++                while (cc != '\n')
++                    cc = getNextCharAndAppend();
++                resetBufferWith(cc);
++                setBufToFirstMeaningfulChar();
++            }
++            else setNextTokenAndResetWith(DIV, cc);
++        }
++    }
++
++    private void lexLAngle() throws IOException, EOFException {
++        int c = nextChar(false);
++        if (c == -1)
++            setNextTokenAndReset(LT);
++        else {
++            char cc = (char) c;
++            buf.append(cc);
++            if (cc == '=')
++                setNextTokenAndReset(LE);
++            else setNextTokenAndResetWith(LT, cc);
++        }
++    }
++
++    private void lexRAngle() throws IOException, EOFException {
++        int c = nextChar(false);
++        if (c == -1)
++            setNextTokenAndReset(GT);
++        else {
++            char cc = (char) c;
++            buf.append(cc);
++            if (cc == '=')
++                setNextTokenAndReset(GE);
++            else setNextTokenAndResetWith(GT, cc);
++        }
++    }
++
++    private void lexDash() throws IOException, EOFException {
++        int[] cs = peekReader(2);
++        if (cs[0] == -1) {
++            consume('-'); // Dash already in the system
++            setNextTokenAndReset(MINUS);
++        }
++        else { // Have one dash, what's next
++               // If dash #2
++            if ((char) cs[0] == '-') {
++                // If >
++                if ((char) cs[1] == '>') { // It's an arrow!
++                    consume('-');
++                    consume('>');
++                    setNextTokenAndReset(ARR);
++                }
++                else {
++                    consume('-');
++                    setNextTokenAndResetWith(MINUS, '-');
++                }
++            }
++            else { // No dash #2
++                setNextTokenAndReset(MINUS);
++            }
++        }
++    }
++
++    private void lexIdentifier() throws IOException, EOFException {
++        int c;
++        for (c = nextChar(false); c != -1 && Character.isLetter(c); c =
++                nextChar(false))
++            buf.append((char) c);
++
++        String id = buf.toString();
++        TokenType tt = TokenType.getTypeFromString(id);
++        if (tt != null) {
++            setNextTokenAndReset(tt);
++        }
++        else {
++            unexpected();
++        }
++
++        if (c != -1) buf.append((char) c);
++    }
++
++    private void lexNum() throws IOException, EOFException {
++        int c;
++        for (c = nextChar(false); c != -1 && Character.isDigit(c); c =
++                nextChar(false))
++            buf.append((char) c);
++
++        try {
++            String num = buf.toString();
++            int val = Integer.parseInt(num);
++            curTok = new NumToken(val, lineNo);
++            tokenReady = true;
++            buf.setLength(0);
++            if (c != -1) buf.append((char) c);
++        }
++        catch (NumberFormatException e) {
++            unexpected();
++        }
++    }
++
++    /**
++     * Read the next character from the reader, treating EOF as an error. If
++     * successful, append the character to the buffer.
++     * 
++     * @return The next character
++     * @throws IOException
++     *             if an IOException was thrown when trying to read the next
++     *             char
++     * @throws EOFException
++     *             if EOF is encountered
++     */
++    private char getNextCharAndAppend() throws IOException, EOFException {
++        char c = (char) nextChar(true);
++        buf.append(c);
++        return c;
++    }
++
++    /**
++     * Read the next character from the reader. If isEOFerror, treat EOF as an
++     * error. If successful, append the character to the buffer.
++     * 
++     * @param exceptionOnEOF
++     * @return The integer representation of the next character
++     * @throws IOException
++     *             if an {@code IOException} is thrown when trying to read from
++     *             the source Reader
++     * @throws EOFException
++     *             if EOF is encountered and isEOFerror is true
++     */
++    private int nextChar(boolean exceptionOnEOF) throws IOException,
++            EOFException {
++        int c = br.read();
++        if (exceptionOnEOF && c == -1) encounteredEOF();
++        return c;
++    }
++
++    private void setNextTokenAndReset(TokenType tokenType) {
++        curTok = new Token(tokenType, lineNo);
++        tokenReady = true;
++        buf.setLength(0);
++    }
++
++    private void setNextTokenAndResetWith(TokenType tokenType, char c) {
++        setNextTokenAndReset(tokenType);
++        buf.append(c);
++    }
++
++    private void resetBufferWith(char c) {
++        buf.setLength(0);
++        buf.append(c);
++    }
++
++    /**
++     * Read the next character and determine whether it is the expected
++     * character. If not, the current buffer is an error
++     * 
++     * @param expected
++     *            The expected next character
++     * @return true if the next character is as expected
++     * @throws IOException
++     *             if an IOException was thrown when trying to read from the
++     *             source Reader
++     * @throws EOFException
++     *             if EOF is encountered
++     */
++    private boolean consume(char expected) throws IOException, EOFException {
++        int c = getNextCharAndAppend();
++        if (c != expected) {
++            unexpected();
++            return false;
++        }
++        return true;
++    }
++
++    /**
++     * Make the current token an error token with the current contents of the
++     * buffer
++     */
++    private void unexpected() {
++        curTok = new ErrorToken(buf.toString(), lineNo);
++        tokenReady = true;
++        buf.setLength(0);
++    }
++
++    private final int[] charBuf = new int[3];
++
++    private int[] peekReader(int distance) throws IOException {
++        assert distance <= 3 && distance > 0;
++        br.mark(distance + 1);
++        for (int i = 0; i < distance; i++) {
++            charBuf[i] = br.read();
++        }
++        br.reset();
++        return charBuf;
++    }
++
++    /**
++     * Make the contents of the current buffer into an EOFToken, clearing the
++     * buffer in the process, set atEOF to true, and set the current token to
++     * the newly generated EOFToken, setting tokenReady in the process
++     */
++    private void encounteredEOF() throws EOFException {
++        curTok = new EOFToken(buf.toString(), lineNo);
++        buf.setLength(0);
++        atEOF = true;
++        tokenReady = true;
++        throw new EOFException();
++    }
++
++    /**
++     * "Helper" exception to indicate that EOF was reached
++     */
++    static class EOFException extends Exception {
++        private static final long serialVersionUID = -7333947165525391472L;
++    }
++
++    static class TokenizerIOException extends RuntimeException {
++        private static final long serialVersionUID = 8014027094822746940L;
++
++        TokenizerIOException(Throwable cause) {
++            super(cause);
++        }
++    }
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
+new file mode 100644
+index 0000000..a58087f
+--- /dev/null
++++ b/src/main/java/simulation/AbstractWorld.java
+@@ -0,0 +1,170 @@
++package simulation;
++
++import java.util.HashMap;
++import java.util.LinkedList;
++
++import interpret.Interpreter;
++import interpret.InterpreterImpl;
++
++public abstract class AbstractWorld implements SimpleWorld
++{
++	/** A compilation of all the constants needed for world creation. */
++	protected HashMap<String, Double> CONSTANTS;
++	/** Stores all the critters present in the world, in the order in which they were created. */
++	protected LinkedList<SimpleCritter> critterList;
++	/** The number of time steps passed since this world's genesis. */
++	protected int timePassed;
++	
++	@Override
++	public int getMinMemory()
++	{
++		return CONSTANTS.get("MIN_MEMORY").intValue();
++	}
++
++	@Override
++	public int getMaxRules()
++	{
++		return CONSTANTS.get("MAX_RULES_PER_TURN").intValue();
++	}
++
++	@Override
++	public int numRemainingCritters()
++	{
++		return critterList.size();
++	}
++	
++	@Override
++	public int getTimePassed()
++	{
++		return timePassed;
++	}
++	
++	@Override
++	@SuppressWarnings("unchecked")
++	public void advanceOneTimeStep()
++	{
++		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
++		for(int i = 0; i < clone.size(); i++)
++		{
++			SimpleCritter sc = clone.get(i);
++			Interpreter im = new InterpreterImpl(sc, this);
++			im.simulateCritterTurn();
++		}
++		
++		for(int i = 0; i < clone.size(); i++)
++		{
++			SimpleCritter sc = clone.get(i);
++			sc.toggleMatingPheromones(false);
++}
++		
++		timePassed++;
++	}
++
++	@Override
++	public abstract void loadCritters(String filename, int n, int direction);
++	
++	@Override
++	public abstract StringBuilder printGrid();
++	
++	/* ========================================= */
++	/* ----------- Critter Sensors ------------- */
++	/* ========================================= */
++	
++	/**
++	 * Looks at the contents of a hex adjacent to a critter.
++	 * @param sc : the critter who is observing its surroundings
++	 * @param dir : the direction in which to look
++	 * @return an integer value based on the contents of the observed hex, determined by the {@code WorldObject}
++	 * 		   method {@code getAppearance()}.
++	 */
++	public abstract int searchNearby(SimpleCritter sc, int dir);
++
++	/**
++	 * Looks at the contents of a hex ahead of a critter.
++	 * @param sc : the critter who is observing its surroundings
++	 * @param index : how far ahead to look
++	 * @return an integer value based on the contents of the observed hex, following the same scheme as {@code searchNearby}.
++	 */
++	public abstract int searchAhead(SimpleCritter sc, int index);
++
++	/* ========================================= */
++	/* ----------- Critter Actions ------------- */
++	/* ========================================= */
++	
++	/* 
++	  A NOTE ON ACTIONS: all critter actions except WAIT expend energy. Most of them expend the same amount of energy whether
++	  they succeed or not. If a critter tries to execute an action that requires more energy than it currently has, it will 
++	  die without executing that action. If a critter has just enough energy to perform an action (i.e. the energy required
++	  to perform that action is equal to the energy it currently has, it will execute that action and promptly die afterwards.
++	*/
++	
++	/**
++	 * Moves a critter, if there is nothing in the way and critter will not move off the world bounds.
++	 * @param sc : the moving critter
++	 * @param forward : whether or not the critter is moving forward or backward
++	 */
++	public abstract void moveCritter(SimpleCritter sc, boolean forward);
++	
++	/**
++	 * Turns a critter.
++	 * @param sc : the turning critter
++	 * @param forward : whether or not the critter is turning clockwise or counterclockwise
++	 */
++	public abstract void turnCritter(SimpleCritter sc, boolean clockwise);
++
++	/**
++	 * Forces a critter to eat, if there is food in the hex directly in front of it. This action replenishes energy
++	 * equal to the caloric content of the food eaten.
++	 * @param sc : the feasting critter
++	 */
++	public abstract void critterEat(SimpleCritter sc);
++
++	/**
++	 * Grows a critter by one size.
++	 * @param sc : the growing critter
++	 */
++	public abstract void growCritter(SimpleCritter sc);
++
++	/** 
++	 * Simulates the results of one critter attacking another.
++	 * @param attacker
++	 */
++	public abstract void critterBattle(SimpleCritter attacker);
++	
++	
++	/** 
++	 * Executes the result of one critter attempting to bud. The newly created offspring will appear directly behind
++	 * the parent critter, unless there is something already in that hex (in which case no reproduction will occur).
++	 * @param sc : the budding critter
++	 */
++	public abstract void critterBud(SimpleCritter sc);
++	
++	/**
++	 * Executes the result of one critter attempting to mate with another critter. The other critter must be directly in
++	 * front of the first critter and facing the first critter. The newly created offspring will appear directly behind
++	 * one of the parent critters, unless there is something already in that hex (in which case no reproduction will occur).
++	 * @param sc
++	 */
++	public abstract void critterMate(SimpleCritter sc);
++	
++	/**
++	 * One critter "tags" another critter by setting its "tag" attribute in memory equal to the value of {@code index}.
++	 * @param sc
++	 * @param index
++	 */
++	public abstract void critterTag(SimpleCritter sc, int index);
++	
++	/**
++	 * One critter severs a part of its soul (its energy) and places it on the hex in front of it in the form of food. It is
++	 * possible for the critter to serve all of its remaining energy, killing it in the process
++	 * @param sc : the overly generous critter
++	 * @param index : the amount of food to serve
++	 */
++	public abstract void critterServe(SimpleCritter sc, int index);
++	
++	/**
++	 * A critter does nothing but sit in the sun. It replenishes some energy in the process.
++	 * @param sc
++	 */
++	public abstract void critterSoakEnergy(SimpleCritter sc);
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/Critter.java b/src/main/java/simulation/Critter.java
+new file mode 100644
+index 0000000..a414aab
+--- /dev/null
++++ b/src/main/java/simulation/Critter.java
+@@ -0,0 +1,298 @@
++package simulation;
++
++import ast.Program;
++import java.util.Arrays;
++
++/** A critter is a creature that inhabits CritterWorld. */
++public class Critter implements SimpleCritter
++{
++	/** The set of rules for this critter. */
++	private Program prog;
++	/** The memory of this critter, which stores important attributes of the critter. */
++	private int[] memory;
++	/** The length of this critter's memory. Must be at least 8. */
++	private int memLength;
++	/** The direction this critter is facing. */
++	private Direction orientation;
++	/** Whether or not this critter wants to mate. */
++	private boolean readyToMingle;
++	/** The name of this critter, used for identification purposes. */
++	private String name;
++	/** A string containing information about the last rule this critter completed. */
++	private String lastRuleCompleted;
++	
++	/**
++	 * Creates a new Critter with a specified ruleset, memory, orientation, and name.
++	 * @param p
++	 * @param mem
++	 * @param dir
++	 * @param s
++	 */
++	public Critter(Program p, int[] mem, String s, int dir)
++	{
++		prog = p;
++		memory = mem;
++		memLength = mem[0];
++		name = s;
++		readyToMingle = false;
++		lastRuleCompleted = null;
++		
++		orientation = Direction.constructDir(dir);
++	}
++	
++	/**
++	 * Creates a new Critter with a specified ruleset, memory, name, and a random orientation.
++	 * @param p
++	 * @param mem
++	 * @param s
++	 */
++	public Critter(Program p, int[] mem, String s)
++	{
++		prog = p;
++		memory = mem;
++		memLength = mem[0];
++		name = s;
++		readyToMingle = false;
++		lastRuleCompleted = null;
++		
++		int rand = (int) (Math.random() * 6);
++		orientation = Direction.constructDir(rand);
++	}
++	
++	@Override
++	public int size()
++	{
++		return memory[3];
++	}
++	
++	@Override
++	public int getMemLength()
++	{
++		return memLength;
++	}
++	
++	@Override
++	public Program getProgram()
++	{
++		return prog;
++	}
++	
++	@Override
++	public int getOrientation()
++	{
++		return orientation.getValue();
++	}
++	
++	@Override
++	public String getLastRule()
++	{
++		return lastRuleCompleted;
++	}
++	@Override
++	public void setLastRule(String s)
++	{
++		lastRuleCompleted = s;
++	}
++	
++	@Override
++	public int readMemory(int index)
++	{
++		if(index < 0 || index >= memLength)
++			return Integer.MIN_VALUE;
++		return memory[index];
++	}
++	
++	@Override
++	public boolean setMemory(int val, int index)
++	{
++		//this method does nothing if it tries to alter an index of less than 7, or if the index is out of memory's bounds
++		if(index < 7 || index >= memLength)
++			return false;
++		//the value of mem[7] must be in the range [0, 99] so attempting to set it to something else also has no effect
++		if(index == 7 && !(val <= 99 && val >= 0))
++			return false;
++		
++		memory[index] = val;
++		return true;
++	}
++	
++	@Override
++	public String getName()
++	{
++		return name;
++	}
++	
++	@Override
++	public int getEnergy()
++	{
++		return memory[4];
++	}
++	
++	@Override
++	public void updateEnergy(int amount, int maxEnergyPerSize)
++	{
++		memory[4] += amount;
++		if(memory[4] > maxEnergyPerSize * size())
++			memory[4] = maxEnergyPerSize * size();
++	}
++	
++	@Override
++	public void incrementPass()
++	{
++		if(memory[5] < 999)
++			memory[5]++;
++	}
++	
++	@Override
++	public void turn(boolean counterclockwise)
++	{
++		int curDir = orientation.getValue();
++		int change = counterclockwise ? 1 : -1;
++		
++		int newDir = curDir + change;
++		if(newDir > 5)
++			newDir -= 6;
++		else if(newDir < 0)
++			newDir += 6;
++		orientation = Direction.constructDir(newDir);
++	}
++	
++	@Override
++	public String toString()
++	{
++		return "" + orientation.getValue();
++	}
++	
++	@Override
++	public boolean wantsToMate()
++	{
++		return readyToMingle;
++	}
++	
++	@Override
++	public void toggleMatingPheromones(boolean b)
++	{
++		readyToMingle = b;
++	}
++	
++	@Override
++	public int complexity(int ruleCost, int abilityCost)
++	{
++		return prog.getRulesList().size() * ruleCost + (memory[1] + memory[2]) * abilityCost;
++	}
++	
++	@Override
++	public int getAppearance()
++	{
++		return memory[3] * 100000 + memory[6] * 1000 + memory[7] * 10 + orientation.getValue();
++	}
++
++	@Override
++	public int[] changeInPosition(boolean forward, int dir)
++	{
++		int[] result = new int[2];
++		Direction d = Direction.constructDir(dir);
++		switch(d)
++		{
++			case NORTH:
++				result[0] = 0;
++				result[1] = 1;
++				break;
++			case NORTHEAST:
++				result[0] = 1;
++				result[1] = 1;
++				break;
++			case SOUTHEAST:
++				result[0] = 1;
++				result[1] = 0;
++				break;
++			case SOUTH:
++				result[0] = 0;
++				result[1] = -1;
++				break;
++			case SOUTHWEST:
++				result[0] = -1;
++				result[1] = -1;
++				break;
++			case NORTHWEST:
++				result[0] = -1;
++				result[1] = 0;
++				break;			
++		}
++		if(!forward)
++		{
++			result[0] *= -1;
++			result[1] *= -1;
++		}
++		return result;
++	}
++	
++	@Override
++	public int[] getMemoryCopy()
++	{
++		return Arrays.copyOf(memory, memLength);
++	}
++	
++	/** An enumeration of all the possible directions a critter can be facing. */
++	public enum Direction
++	{
++		NORTH, NORTHEAST, SOUTHEAST, SOUTH, SOUTHWEST, NORTHWEST;
++		
++		/** 
++		 * Returns an integer value of this direction based on an arbitrary numbering system that sets NORTH to 0 and 
++		 * goes counterclockwise until it stops at NORTHEAST.
++		 */
++		public int getValue()
++		{
++			int result = 0;
++			switch(this)
++			{
++				case NORTH:
++					result = 0;
++					break;
++				case NORTHEAST:
++					result = 1;
++					break;
++				case SOUTHEAST:
++					result = 2;
++					break;
++				case SOUTH:
++					result = 3;
++					break;
++				case SOUTHWEST:
++					result = 4;
++					break;
++				case NORTHWEST:
++					result = 5;
++					break;
++			}
++			return result;
++		}
++		
++		/**
++		 * Returns a direction from an integer based on the aforementioned numbering system.
++		 * @param n
++		 * @return a direction that depends on the integer entered. If {@code n} is not in [0, 5], returns NORTH.
++		 */
++		public static Direction constructDir(int n)
++		{
++			switch(n)
++			{
++				case 0:
++					return NORTH;
++				case 1:
++					return NORTHEAST;
++				case 2:
++					return SOUTHEAST;
++				case 3:
++					return SOUTH;
++				case 4:
++					return SOUTHWEST;
++				case 5:
++					return NORTHWEST;
++				default:
++					return NORTH;
++			}
++		}
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/FileParser.java b/src/main/java/simulation/FileParser.java
+new file mode 100644
+index 0000000..95dbc6b
+--- /dev/null
++++ b/src/main/java/simulation/FileParser.java
+@@ -0,0 +1,183 @@
++package simulation;
++
++import java.io.*;
++import java.util.HashMap;
++
++import ast.Program;
++import parse.Parser;
++import parse.ParserFactory;
++
++/** This class supplies several static methods that may be useful for parsing files needed for world creation and modification. */
++public class FileParser
++{
++	/**
++	 * Constructs a critter from a file.
++	 * @param br : a BufferedReader containing the file to be read
++	 * @param minMemory : the minimum memory size for a critter
++	 * @param direction : the direction the critter will be facing
++	 * @return A SimpleCritter object made from the parsed file, or null if the program contains syntax errors
++	 */
++	public static SimpleCritter parseCritter(BufferedReader br, int minMemory, int direction)
++	{
++		String[] parsed = parseAttributes(br);
++		String name = parsed[0].equals("") ? "Untitled #" : parsed[0];
++		int[] critMem = FileParser.makeCritterMemory(parsed, minMemory);
++		
++		//parses the critter program. If the program isn't syntactically valid, returns null
++		Parser p = ParserFactory.getParser();
++		Program prog = p.parse(br);
++		if(prog == null)
++			return null;
++		
++		if((direction < 0 || direction > 5))
++			return new Critter(prog, critMem, name);
++		return new Critter(prog, critMem, name, direction);
++	}
++	
++	/**
++	 * Parses the attributes for a critter from a file into a String array.
++	 * @param br : a BufferedReader containing the file to be read
++	 * @return a String array containing the memory attributes needed to create the critter.
++	 */
++	public static String[] parseAttributes(BufferedReader br)
++	{
++		String name = parseAttributeFromLine(br, "species: ");
++		String memsize = parseAttributeFromLine(br, "memsize: ");
++		String defense = parseAttributeFromLine(br, "defense: ");
++		String offense = parseAttributeFromLine(br, "offense: ");
++		String size = parseAttributeFromLine(br, "size: ");
++		String energy = parseAttributeFromLine(br, "energy: ");
++		String posture = parseAttributeFromLine(br, "posture: ");
++		
++		return new String[] {name, memsize, defense, offense, size, energy, posture};
++	}
++	
++	/**
++	 * Given a BufferedReader, parses one attribute line from a file and returns a string containing only the attribute by
++	 * trimming out a specified substring {@code substringToCut}. If {@code substringToCut} is not present in the line or the end
++	 * of the file is reached, returns an empty string.
++	 * 
++	 * @param b : the BufferedReader to read lines from
++	 * @param : substringToCut the substring to trim
++	 * @return A string containing only the attribute given on the line
++	 */
++	public static String parseAttributeFromLine(BufferedReader b, String substringToCut)
++	{
++		String result = "";
++		try
++		{
++			String line = b.readLine();
++			int len = substringToCut.length();
++			if(line != null && line.startsWith(substringToCut) && len < line.length())
++				result = line.substring(len);
++		}
++		catch (IOException e)
++		{
++			return "";
++		}
++		return result;
++	}
++	
++	/**
++	 * Prepares an int array to be used as critter memory, based on a string array.<br>
++	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
++	 * @param strs : an array of strings created by the method {@code FileParser.parseAttributes(filename)}
++	 * @param minMemory : the minimum memory size for a critter
++	 * @return an int array, ready to be used as critter memory. Returns a default set of memory if {@code strs} is not compatible.
++	 */
++	private static int[] makeCritterMemory(String[] strs, int minMemory)
++	{
++		//if the strs array is less than 7, then we revert to a default set of memory
++		if(strs.length < 7)
++			return new int[] {minMemory, 3, 3, 1, 500, 0, 0, 0};
++		
++		int[] critterAttributes;
++		
++		int memsize = parseIntFromString(strs[1]);
++		if(memsize < minMemory)
++			memsize = minMemory;
++		critterAttributes = new int[memsize];
++		critterAttributes[0] = memsize;
++		
++		int defense = parseIntFromString(strs[2]);
++		if(defense < 0)
++			defense = 3;
++		critterAttributes[1] = defense;
++		
++		int offense = parseIntFromString(strs[3]);
++		if(offense < 0)
++		offense = 3;
++		critterAttributes[2] = offense;
++		
++		int size = parseIntFromString(strs[4]);
++		if(size < 0)
++			size = 1;
++		critterAttributes[3] = size;
++		
++		int energy = parseIntFromString(strs[5]);
++		if(energy < 0)
++			energy = 500;
++		critterAttributes[4] = energy;
++		
++		int pass = 0;
++		critterAttributes[5] = pass;
++		
++		int tag = 0;
++		critterAttributes[6] = tag;
++		
++		int posture = parseIntFromString(strs[6]);
++		if(posture < 0 || posture > 99)
++			posture = 0;
++		critterAttributes[7] = posture;
++		
++		for(int i = 8; i < memsize; i++)
++			critterAttributes[i] = 0;
++		
++		return critterAttributes;
++	}
++	/**
++	 * Parses an integer value from a given string, or returns -1 if no integer was found.
++	 * @param s : the string to parse
++	 * @return the int parsed from the string, or -1 if no integer was found
++	 */
++	private static int parseIntFromString(String s)
++	{
++		try
++		{
++			return Integer.parseInt(s);
++		}
++		catch (NumberFormatException n)
++		{
++			return -1;
++		}
++	}
++	
++	/**
++	 * Parses constants from a file and returns them in the form of a HashMap. Assumes that the file adheres to the format
++	 * specified by the <a href="http://www.cs.cornell.edu/courses/cs2112/2017fa/project/constants.txt">constants file given
++	 * to us</a>.
++	 * @param b : a BufferedReader containing the file to be read.
++	 * @return a HashMap containing the names of constants mapped to their values.
++	 * @throws IllegalArgumentException if the file is not valid.
++	 */
++	public static HashMap<String, Double> parseConstants(BufferedReader b) throws IllegalArgumentException
++	{
++		HashMap<String, Double> result = new HashMap<String, Double>();
++		try
++		{
++			String line = b.readLine();
++			while(line != null)
++			{
++				String[] constant = line.split(" ");
++				result.put(constant[0], Double.parseDouble(constant[1]));
++				line = b.readLine();
++			}
++		}
++		//If the constants file has any irregularities,
++		catch (Exception e)
++		{
++			throw new IllegalArgumentException();
++		}
++		return result;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/Food.java b/src/main/java/simulation/Food.java
+new file mode 100644
+index 0000000..ecc2e6f
+--- /dev/null
++++ b/src/main/java/simulation/Food.java
+@@ -0,0 +1,31 @@
++package simulation;
++
++/** A piece of food that can be present on one world hex. */
++public class Food implements WorldObject
++{
++	/** The caloric value of this piece of food. */
++	private int calories;
++	
++	/** Creates a new Food object with the specified amount of calories. */
++	public Food(int amt)
++	{
++		calories = amt;
++	}
++	
++	/** Returns the amount of calories in this piece of food. */
++	public int getCalories()
++	{
++		return calories;
++	}
++	
++	public String toString()
++	{
++		return "F";
++	}
++
++	@Override
++	public int getAppearance()
++	{
++		return -1 * (calories + 1);
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/Hex.java b/src/main/java/simulation/Hex.java
+new file mode 100644
+index 0000000..cd3bd91
+--- /dev/null
++++ b/src/main/java/simulation/Hex.java
+@@ -0,0 +1,81 @@
++package simulation;
++
++/** Stores the information for one hex in the world grid. */
++public class Hex
++{
++	/** The column index of this Hex. */
++	private int colIndex;
++	/** The row index of this Hex. */
++	private int rowIndex;
++	/** What this hex contains. May be null if there is nothing on this hex. */
++	private WorldObject content;
++	
++	/** Creates a new empty Hex object with the specified rowIndex and colIndex. */
++	public Hex(int c, int r)
++	{
++		colIndex = c;
++		rowIndex = r;
++		content = null;
++	}
++	
++	/** Returns the column index of this Hex. */
++	public int getColumnIndex()
++	{
++		return colIndex;
++	}
++	
++	/** Returns the row index of this Hex. */
++	public int getRowIndex()
++	{
++		return rowIndex;
++	}
++	
++	/**
++	 * Adds a world object to this hex, if it is empty.
++	 * @param wo the object to add
++	 * @return whether or not {@code wo} was able to be added to this hex.
++	 */
++	public boolean addContent(WorldObject wo)
++	{
++		if(isEmpty())
++		{
++			content = wo;
++			return true;
++		}
++		return false;
++	}
++	
++	/** Removes the content on this hex. */
++	public void removeContent()
++	{
++		content = null;
++	}
++	
++	public WorldObject getContent()
++	{
++		return content;
++	}
++	/** Returns {@code true} if and only if {@code content == null}. */
++	public boolean isEmpty()
++	{
++		return content == null;
++	}
++	
++	/**
++	 * Returns an integer representing how this hex appears to a critter. If this hex is empty, this integer is 0,
++	 * but otherwise, this value is determined by {@code content.getAppearance()}, which follows the numbering scheme
++	 * described in the interface {@code WorldObject}.
++	 */
++	public int hexAppearance()
++	{
++		return isEmpty() ? 0 : content.getAppearance();
++	}
++	
++	@Override
++	public String toString()
++	{
++		if(content == null)
++			return "-";
++		return content.toString();
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/Rock.java b/src/main/java/simulation/Rock.java
+new file mode 100644
+index 0000000..fd7ac7f
+--- /dev/null
++++ b/src/main/java/simulation/Rock.java
+@@ -0,0 +1,17 @@
++package simulation;
++
++/** This is a <a href = "https://en.wikipedia.org/wiki/Rock_(geology)">rock</a>. */
++public class Rock implements WorldObject
++{
++	@Override
++	public String toString()
++	{
++		return "#";
++	}
++
++	@Override
++	public int getAppearance()
++	{
++		return -1;
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/SimpleCritter.java b/src/main/java/simulation/SimpleCritter.java
+new file mode 100644
+index 0000000..0bfb0f2
+--- /dev/null
++++ b/src/main/java/simulation/SimpleCritter.java
+@@ -0,0 +1,80 @@
++package simulation;
++
++import ast.Program;
++
++public interface SimpleCritter extends WorldObject
++{
++	/** Returns the ruleset of this critter. */
++	public Program getProgram();
++	
++	/** Returns the size of this critter. */
++	public int size();
++	
++	/** Returns the memory length of this critter. */
++	public int getMemLength();
++	
++	/** Returns the orientation of this critter. */
++	public int getOrientation();
++	
++	/** Returns the current energy level of this critter. */
++	public int getEnergy();
++	
++	/** Updates the critter's energy by the amount specified. */
++	public void updateEnergy(int amount, int maxEnergyPerSize);
++	
++	/** 
++	 * Returns the value of {@code memory[index]}.
++	 * @param index
++	 * @return the value of this critter's memory at the specified index, or {@code Integer.MIN_VALUE} if the index lies out-of-bounds
++	 */
++	public int readMemory(int index);
++	
++	/**
++	 * Sets the memory at index to val. Does nothing if {@code index} is an out-of-bounds or unassignable index
++	 * or if {@code val} is not within the restrictions of that array index.
++	 * @param val
++	 * @param index
++	 * @return Whether or not the memory array was actually altered
++	 */
++	public boolean setMemory(int val, int index);
++	
++	@Override
++	public int getAppearance();
++	
++	/** Returns a copy of the memory. */
++	public int[] getMemoryCopy();
++	
++	/** Returns the species name of this critter. */
++	public String getName();
++	
++	/** Returns a string representation of the last rule executed by this critter. */
++	public String getLastRule();
++	
++	/** Sets the last rule executed. */
++	public void setLastRule(String s);
++	
++	/** Increments the pass number of this critter (memory index 5) by one, if it is less than 999. */
++	public void incrementPass();
++	
++	/**
++	 * Turns this critter in the direction specified.
++	 * @param counterclockwise
++	 */
++	public void turn(boolean clockwise);
++	
++	/**
++	 * Returns an array of length 2 that symbolizes the change in position of a critter if it moves one hex in the specified direction.
++	 * @param forward : whether or not the hex will be accessed by moving forward or backward
++	 * @param dir : the direction the hex is in
++	 */
++	public int[] changeInPosition(boolean forward, int dir);
++	
++	/** Whether or not this critter wants to mate. */
++	public boolean wantsToMate();
++	
++	/** Turns mating signals of this critter on or off. */
++	public void toggleMatingPheromones(boolean b);
++	
++	/** Returns an integer value representing this critter's complexity. */
++	public int complexity(int ruleCost, int abilityCost);
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
+new file mode 100644
+index 0000000..ac97405
+--- /dev/null
++++ b/src/main/java/simulation/SimpleWorld.java
+@@ -0,0 +1,51 @@
++package simulation;
++
++/** An interface containing the basic functions of the world. */
++public interface SimpleWorld
++{
++	/** Returns the minimum critter memory size for this world. Cannot be less than 8. */
++	int getMinMemory();
++	
++	/** Returns the maximum number of rules that may be executed per turn for this world. */
++	int getMaxRules();
++	
++	/** Returns the number of living critters currently in the simulation. */
++	int numRemainingCritters();
++	
++	/** Returns the amount of time passed since this world's genesis. */
++	int getTimePassed();
++	
++	/**
++	 * Loads critters of following a set pattern into this world.
++	 * @param filename the file containing the critter information
++	 * @param n the number of critters to load
++	 * @param direction the orientation of the critter. If this value is less than 0, a critter orientation
++	 * 					will be chosen at random.
++	 */
++	void loadCritters(String filename, int n, int direction);
++	
++	/** Advances the world state by a single time step. */
++	void advanceOneTimeStep();
++	
++	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
++	boolean isValidHex(int c, int r);
++	
++	/**
++	 * Returns information about a hex. Assumes that the 
++	 * @param c
++	 * @param r
++	 * @return
++	 */
++	int analyzeHex(int c, int r);
++	
++	/**
++	 * 
++	 * @param c
++	 * @param r
++	 * @return
++	 */
++	SimpleCritter analyzeCritter(int c, int r);
++
++	/** Returns a StringBuilder containing the printed version of the world grid. */
++	StringBuilder printGrid();
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
+new file mode 100644
+index 0000000..ae9bd56
+--- /dev/null
++++ b/src/main/java/simulation/World.java
+@@ -0,0 +1,845 @@
++package simulation;
++
++import java.io.BufferedReader;
++import java.io.FileNotFoundException;
++import java.io.FileReader;
++import java.io.InputStream;
++import java.io.InputStreamReader;
++import java.util.HashMap;
++import java.util.LinkedList;
++import java.util.Random;
++
++import ast.Program;
++import ast.ProgramImpl;
++import ast.Rule;
++
++/** A class to simulate the world state. */
++public class World extends AbstractWorld
++{
++	/** The name of this world. */
++	private String worldname;
++	/** Contains the hex grid of the world. */
++	private Hex[][] grid;
++	/** Maps each critter to a location in the world */
++	private HashMap<SimpleCritter, Hex> critterMap;
++	/** The number of columns in the world grid. */
++	private int columns;
++	/** The number of rows in the world grid. */
++	private int rows;
++	/** The number of hexes that lie on the world grid. */
++	private int numValidHexes;
++
++	/**
++	 * Loads a world based on a world description file.
++	 * 
++	 * @param filename The name of the file that contains world information.
++	 * @throws FileNotFoundException if the world file could not be found
++	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
++	 */
++	public World(String filename) throws FileNotFoundException, IllegalArgumentException
++	{
++		// sets constants and initializes instance fields
++		super();
++		setConstants();
++		critterMap = new HashMap<SimpleCritter, Hex>();
++		super.critterList = new LinkedList<SimpleCritter>();
++		super.timePassed = 0;
++
++		BufferedReader bf = new BufferedReader(new FileReader(filename));
++
++		// parses the world name, and if no valid one is parsed, supplies a default one
++		worldname = FileParser.parseAttributeFromLine(bf, "name ");
++		if (worldname.equals(""))
++			worldname = "Arrakis";
++
++		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
++		try
++		{
++			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
++			String[] dim = worldDimensions.split(" ");
++			columns = Integer.parseInt(dim[0]);
++			rows = Integer.parseInt(dim[1]);
++
++			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
++			{
++				columns = CONSTANTS.get("COLUMNS").intValue();
++				rows = CONSTANTS.get("ROWS").intValue();
++			}
++		}
++		catch (Exception e)
++		{
++			columns = CONSTANTS.get("COLUMNS").intValue();
++			rows = CONSTANTS.get("ROWS").intValue();
++		}
++		numValidHexes = 0;
++
++		// initializes world grid
++		grid = new Hex[columns][rows];
++		for (int i = 0; i < grid.length; i++)
++			for (int j = 0; j < grid[0].length; j++)
++				if (isValidHex(i, j))
++				{
++					grid[i][j] = new Hex(i, j);
++					numValidHexes++;
++				}
++
++		try
++		{
++			// loads in world objects from file
++			String line = bf.readLine();
++			while (line != null)
++			{
++				String[] info = line.split(" ");
++				switch (info[0])
++				{
++					case "rock":
++						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
++						break;
++					case "food":
++						Food f = new Food(Integer.parseInt(info[3]));
++						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
++						break;
++					case "critter":
++						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
++						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
++								Integer.parseInt(info[4]));
++						if(sc == null)
++						{
++							System.err.println("The critter file " + filename + " does not have the right syntax, so it was not loaded.");
++							break;
++						}
++							
++						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
++						break;
++				}
++				line = bf.readLine();
++			}
++		}
++		catch (Exception e)
++		{
++			return;
++		}
++	}
++
++	/**
++	 * Generates a default size world containing nothing but randomly placed rocks.
++	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
++	 */
++	public World() throws IllegalArgumentException
++	{
++		// sets constants and initializes instance fields
++		super();
++		worldname = "Arrakis";
++		setConstants();
++		critterMap = new HashMap<SimpleCritter, Hex>();
++		critterList = new LinkedList<SimpleCritter>();
++		timePassed = 0;
++
++		super.critterList = new LinkedList<SimpleCritter>();
++		super.timePassed = 0;
++
++		columns = CONSTANTS.get("COLUMNS").intValue();
++		rows = CONSTANTS.get("ROWS").intValue();
++		numValidHexes = 0;
++
++		grid = new Hex[columns][rows];
++		for (int i = 0; i < grid.length; i++)
++			for (int j = 0; j < grid[0].length; j++)
++			{
++				if (isValidHex(i, j))
++				{
++					grid[i][j] = new Hex(i, j);
++					numValidHexes++;
++				}
++			}
++
++		// randomly fills about 1/40 of the hexes in the world with rocks
++		int c = (int) (Math.random() * columns);
++		int r = (int) (Math.random() * rows);
++		int n = 0;
++		while (n < numValidHexes / 40)
++		{
++			c = (int) (Math.random() * columns);
++			r = (int) (Math.random() * rows);
++			if (isValidHex(c, r))
++			{
++				grid[c][r].addContent(new Rock());
++				n++;
++			}
++		}
++	}
++
++	/**
++	 * Parses the constants file in the project directory and stores the constants in the CONSTANTS field.
++	 * @throws IllegalArgumentException if the constants file couldn't be found or is improperly formatted
++	 */
++	private void setConstants() throws IllegalArgumentException
++	{
++		InputStream in = World.class.getResourceAsStream("constants.txt");
++		if(in == null)
++		{ 
++			System.err.println("The constants.txt file could not be found in bin/simulation.");
++			System.exit(0);
++		}
++		
++		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
++		CONSTANTS = FileParser.parseConstants(bf);
++	}
++
++	@Override
++	public boolean isValidHex(int c, int r)
++	{
++		if (c < 0 || r < 0)
++			return false;
++		else if (c >= columns || r >= rows)
++			return false;
++		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
++			return false;
++		return true;
++	}
++
++	@Override
++	public void loadCritters(String filename, int n, int direction)
++	{
++		try
++		{
++			BufferedReader br = new BufferedReader(new FileReader(filename));
++			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
++
++			for (int i = 0; i < n; i++)
++			{
++
++				int randc = (int) (Math.random() * columns);
++				int randr = (int) (Math.random() * rows);
++				while (!isValidHex(randc, randr))
++				{
++					randc = (int) (Math.random() * columns);
++					randr = (int) (Math.random() * rows);
++				}
++
++				if (isValidHex(randc, randr))
++					loadOneCritter(sc, randc, randr);
++			}
++		}
++		catch (FileNotFoundException e)
++		{
++			System.err.println("Critter file not found.");
++			return;
++		}
++	}
++
++	/**
++	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
++	 * the hex is not within the world boundaries, or if there is something already present at the hex.
++	 * 
++	 * @param sc the critter to add
++	 * @param c the column index of the hex where the critter will be added
++	 * @param r the row index of the hex where the critter will be added
++	 */
++	private void loadOneCritter(SimpleCritter sc, int c, int r)
++	{
++		if (!isValidHex(c, r))
++			return;
++		boolean added = grid[c][r].addContent(sc);
++		if (added)
++		{
++			critterList.add(sc);
++			critterMap.put(sc, grid[c][r]);
++		}
++	}
++
++	/**
++	 * Loads a single non-critter world object into the world at the specified coordinates, if possible.
++	 * Does nothing if the hex is not within the world boundaries or if there is something already present at
++	 * the hex. This method cannot be used to add critters into the world. Use the method
++	 * {@code loadCritter(SimpleCritter sc, int c, int r)} instead.
++	 * 
++	 * @param sc the object to add
++	 * @param c the column index of the hex where the object will be added
++	 * @param r the row index of the hex where the object will be added
++	 */
++	private void addNonCritterObject(WorldObject wo, int c, int r)
++	{
++		if (wo instanceof Critter)
++			return;
++		if (!isValidHex(c, r))
++			return;
++		grid[c][r].addContent(wo);
++	}
++
++	/* ========================================= */
++	/* ----------- Critter Sensors ------------- */
++	/* ========================================= */
++
++	@Override
++	public int searchNearby(SimpleCritter sc, int dir)
++	{
++		//determines the row and column coordinates of the critter
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++		
++		// finds the hex to look in, based on the value of dir
++		if (dir < 0)
++			dir = 0;
++		else if (dir > 6)
++			dir %= 6;
++		int nearbyc = c + sc.changeInPosition(true, dir)[0];
++		int nearbyr = r + sc.changeInPosition(true, dir)[1];
++
++		// critters see rock when they look off the edge of the world
++		if (!isValidHex(nearbyc, nearbyr))
++			return -1;
++		Hex nearby = grid[nearbyc][nearbyr];
++		return nearby.hexAppearance();
++	}
++
++	@Override
++	public int searchAhead(SimpleCritter sc, int index)
++	{
++		//determines the row and column coordinates of the critter
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++		
++		if (index < 0)
++			index = 0;
++		int aheadc = c + sc.changeInPosition(true, sc.getOrientation())[0] * index;
++		int aheadr = r + sc.changeInPosition(true, sc.getOrientation())[1] * index;
++
++		if (!isValidHex(aheadc, aheadr))
++			return -1;
++		Hex nearby = grid[aheadc][aheadr];
++		return nearby.hexAppearance();
++	}
++
++	/* ========================================= */
++	/* ----------- Critter Actions ------------- */
++	/* ========================================= */
++
++	@Override
++	public void moveCritter(SimpleCritter sc, boolean forward)
++	{
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		int cost = CONSTANTS.get("MOVE_COST").intValue() * sc.size();
++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		// if the critter did not have enough energy to complete this action, kills the critter
++		if (sc.getEnergy() < 0)
++		{
++			kill(sc);
++			return;
++		}
++
++		int[] changeInCoords = sc.changeInPosition(forward, sc.getOrientation());
++		int newc = c + changeInCoords[0];
++		int newr = r + changeInCoords[1];
++
++		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
++		{
++			if (sc.getEnergy() == 0)
++				kill(sc);
++			return;
++		}
++		grid[c][r].removeContent();
++		critterMap.remove(sc);
++		grid[newc][newr].addContent(sc);
++		critterMap.put(sc, grid[newc][newr]);
++		if (sc.getEnergy() == 0)
++			kill(sc);
++	}
++
++	@Override
++	public void turnCritter(SimpleCritter sc, boolean clockwise)
++	{
++		int cost = sc.size();
++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		// if the critter did not have enough energy to complete this action, kills the critter
++		if (sc.getEnergy() < 0)
++		{
++			kill(sc);
++			return;
++		}
++
++		sc.turn(clockwise);
++		if (sc.getEnergy() == 0)
++			kill(sc);
++	}
++
++	@Override
++	public void critterEat(SimpleCritter sc)
++	{
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		int cost = sc.size();
++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		// if the critter did not have enough energy to complete this action, kills the critter
++		if (sc.getEnergy() < 0)
++		{
++			kill(sc);
++			return;
++		}
++
++		int newc = c + sc.changeInPosition(true, sc.getOrientation())[0];
++		int newr = r + sc.changeInPosition(true, sc.getOrientation())[1];
++		if (!isValidHex(newc, newr))
++		{
++			if (sc.getEnergy() == 0)
++				kill(sc);
++			return;
++		}
++
++		Hex directlyInFront = grid[newc][newr];
++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof Food)
++		{
++			Food nourishment = (Food) directlyInFront.getContent();
++			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++			directlyInFront.removeContent();
++		}
++		if (sc.getEnergy() == 0)
++			kill(sc);
++	}
++
++	@Override
++	public void growCritter(SimpleCritter sc)
++	{
++		int cost = sc.size()
++				* sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
++		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		// if the critter did not have enough energy to complete this action, kills the critter
++		if (sc.getEnergy() < 0)
++		{
++			kill(sc);
++			return;
++		}
++
++		int currentSize = sc.readMemory(3);
++		sc.setMemory(currentSize + 1, 3);
++	}
++
++	@Override
++	public void critterBattle(SimpleCritter attacker)
++	{
++		Hex location = critterMap.get(attacker);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		int cost = attacker.size() * CONSTANTS.get("ATTACK_COST").intValue();
++		attacker.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		//if the critter did not have enough energy to complete this action, kills the critter
++		if (attacker.getEnergy() < 0)
++		{
++			kill(attacker);
++			return;
++		}
++
++		int newc = c + attacker.changeInPosition(true, attacker.getOrientation())[0];
++		int newr = r + attacker.changeInPosition(true, attacker.getOrientation())[1];
++		if (!isValidHex(newc, newr))
++		{
++			if (attacker.getEnergy() == 0)
++				kill(attacker);
++			return;
++		}
++
++		Hex directlyInFront = grid[newc][newr];
++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
++		{
++			// Calculates the damage dealt to the target critter
++			SimpleCritter target = (SimpleCritter) (directlyInFront.getContent());
++			int baseDamage = CONSTANTS.get("BASE_DAMAGE").intValue();
++			double dmgMultiplier = CONSTANTS.get("DAMAGE_INC").doubleValue();
++			int dmgBeforeScaling = (attacker.size() * attacker.readMemory(2)) - (target.size() * target.readMemory(1));
++			int damage = baseDamage * attacker.size() * logisticFunction(dmgMultiplier * (double)dmgBeforeScaling);
++
++			// kills the target if it took damage greater than or equal to its current energy
++			target.updateEnergy(-1 * damage, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++			if (target.getEnergy() <= 0)
++				kill(target);
++		}
++
++		if (attacker.getEnergy() == 0)
++			kill(attacker);
++	}
++
++	/** Performs the logistic function 1 / (1 + e^-x), floored to an integer value. */
++	private int logisticFunction(double x)
++	{
++		double exponent = -1 * x;
++		return (int) (1 / (1 + Math.exp(exponent)));
++	}
++
++	@Override
++	public void critterBud(SimpleCritter sc)
++	{
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		int complexity = sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
++		sc.updateEnergy(-1 * CONSTANTS.get("BUD_COST").intValue() * complexity,
++				CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		//if the critter did not have enough energy to complete this action, kills the critter
++		if (sc.getEnergy() < 0)
++		{
++			kill(sc);
++			return;
++		}
++
++		int newc = c + sc.changeInPosition(false, sc.getOrientation())[0];
++		int newr = r + sc.changeInPosition(false, sc.getOrientation())[1];
++		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
++		{
++			if (sc.getEnergy() == 0)
++				kill(sc);
++			return;
++		}
++
++		//Constructs the baby critter's memory, copying memory length, offense, and defense from the parent
++		int[] babymem = new int[sc.getMemLength()];
++		babymem[0] = sc.getMemLength();
++		babymem[1] = sc.readMemory(1);
++		babymem[2] = sc.readMemory(2);
++		babymem[3] = 1;
++		babymem[4] = 250;
++		for (int i = 5; i < babymem.length; i++)
++			babymem[i] = 0;
++
++		String name = sc.getName() + " Jr.";
++		Program prog = sc.getProgram();
++		int numMutations = numberMutations();
++		for (int i = 0; i < numMutations; i++)
++			prog = prog.mutate();
++
++		SimpleCritter baby = new Critter(prog, babymem, name, sc.getOrientation());
++		loadOneCritter(baby, newc, newr);
++
++		if (sc.getEnergy() == 0)
++			kill(sc);
++	}
++
++	@Override
++	public void critterMate(SimpleCritter sc)
++	{
++		sc.toggleMatingPheromones(true);
++		Hex location = critterMap.get(sc);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++		int behindColumnParent1 = c + sc.changeInPosition(false, sc.getOrientation())[0];
++		int behindRowParent1 = r + sc.changeInPosition(false, sc.getOrientation())[1];
++		if (!isValidHex(behindColumnParent1, behindRowParent1))
++		{
++			sc.toggleMatingPheromones(false);
++			return;
++		}
++		// coordinates of Parent 2
++		int columnParent2 = c + sc.changeInPosition(true, sc.getOrientation())[0];
++		int rowParent2 = r + sc.changeInPosition(true, sc.getOrientation())[1];
++		if (!isValidHex(columnParent2, rowParent2))
++		{
++			sc.toggleMatingPheromones(false);
++			return;
++		}
++		Hex directlyInFront = grid[columnParent2][rowParent2];
++		if (!(directlyInFront.getContent() instanceof SimpleCritter))
++		{
++			sc.toggleMatingPheromones(false);
++			return;
++		}
++		SimpleCritter parent2 = (SimpleCritter) (directlyInFront.getContent());
++		int behindColumnParent2 = columnParent2 + sc.changeInPosition(false, sc.getOrientation())[0];
++		int behindRowParent2 = rowParent2 + sc.changeInPosition(false, sc.getOrientation())[1];
++		if (!isValidHex(behindColumnParent2, behindRowParent2))
++		{
++			sc.toggleMatingPheromones(false);
++			return;
++		}
++		// checks if Parent 2 wants to mate
++		if (!parent2.wantsToMate())
++			return;
++		int parent1Direction = sc.getOrientation();
++		int parent2Direction = parent2.getOrientation();
++
++		// direction checking
++		if (!(Math.abs(parent1Direction - parent2Direction) == 3))
++		{
++			sc.toggleMatingPheromones(false);
++			return;
++		}
++
++		// energy calculation
++		sc.updateEnergy(-sc.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++		parent2.updateEnergy(-parent2.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++		if (sc.getEnergy() < 0 || parent2.getEnergy() < 0)
++		{
++			if (sc.getEnergy() < 0)
++				kill(sc);
++			if (parent2.getEnergy() < 0)
++				kill(parent2);
++			return;
++		}
++		initiateMatingProcess(sc, parent2);
++	}
++
++	/** Randomly determines the number of mutations that will occur during mating or budding. */
++	private int numberMutations()
++	{
++		double randomNumber = Math.random();
++		int returnValue = 0;
++		double temp = 0.25;
++
++		for (int i = 0; i < 10; i++)
++		{
++			if (randomNumber < temp)
++				returnValue++;
++			temp = Math.pow(0.25, i + 1);
++		}
++		return returnValue;
++	}
++
++	/** Executes the mating process, as long as there is one empty hex around the two critters. */
++	private void initiateMatingProcess(SimpleCritter sc1, SimpleCritter sc2)
++	{
++		Random random = new Random();
++		// energy calculation
++		int complexity1 = sc1.complexity(CONSTANTS.get("RULE_COST").intValue(),
++				CONSTANTS.get("ABILITY_COST").intValue());
++		int complexity2 = sc2.complexity(CONSTANTS.get("RULE_COST").intValue(),
++				CONSTANTS.get("ABILITY_COST").intValue());
++		sc1.updateEnergy(-5 * complexity1, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++		sc2.updateEnergy(-5 * complexity2, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++		if (sc1.getEnergy() < 0 || sc2.getEnergy() < 0)
++		{
++			if (sc1.getEnergy() < 0)
++				kill(sc1);
++			if (sc2.getEnergy() < 0)
++				kill(sc2);
++			return;
++		}
++
++		// generating RuleSet
++		LinkedList<Rule> babyRules = new LinkedList<Rule>();
++		int ruleSetSize = 0;
++		if (random.nextBoolean())
++			ruleSetSize = sc1.getProgram().getRulesList().size();
++		else
++			ruleSetSize = sc2.getProgram().getRulesList().size();
++		for (int i = 0; i < ruleSetSize; i++)
++		{
++			if (random.nextBoolean())
++			{
++				if (i >= sc1.getProgram().getRulesList().size())
++					babyRules.add(sc2.getProgram().getRulesList().get(i));
++				else
++					babyRules.add(sc1.getProgram().getRulesList().get(i));
++			}
++			else
++			{
++				if (i >= sc2.getProgram().getRulesList().size())
++					babyRules.add(sc1.getProgram().getRulesList().get(i));
++				else
++					babyRules.add(sc2.getProgram().getRulesList().get(i));
++			}
++		}
++		Program prog = new ProgramImpl(babyRules);
++
++		//generating memory
++		int[] babymem = null;
++		if (random.nextBoolean())
++		{
++			babymem = new int[sc1.getMemLength()];
++			babymem[0] = sc1.getMemLength();
++		}
++		else
++		{
++			babymem = new int[sc2.getMemLength()];
++			babymem[0] = sc2.getMemLength();
++		}
++		for (int i = 1; i <= 2; i++)
++		{
++			if (random.nextBoolean())
++				babymem[i] = sc1.readMemory(i);
++			else
++				babymem[i] = sc2.readMemory(i);
++		}
++		babymem[3] = 1;
++		babymem[4] = 250;
++		for (int i = 5; i < babymem.length; i++)
++			babymem[i] = 0;
++
++		// coordinate Generation
++		int babyColumn = 0;
++		int babyRow = 0;
++		if (random.nextBoolean())
++		{
++			Hex location = critterMap.get(sc1);
++			babyColumn = location.getColumnIndex() + sc1.changeInPosition(false, sc1.getOrientation())[0];
++			babyRow = location.getRowIndex() + sc1.changeInPosition(false, sc1.getOrientation())[1];
++		}
++		else
++		{
++			Hex location = critterMap.get(sc2);
++			babyColumn = location.getColumnIndex() + sc2.changeInPosition(false, sc2.getOrientation())[0];
++			babyRow = location.getRowIndex() + sc2.changeInPosition(false, sc2.getOrientation())[1];
++		}
++
++		int numMutations = numberMutations();
++		for (int i = 0; i < numMutations; i++)
++			prog = prog.mutate();
++		String name = sc1.getName() + sc2.getName() + " Jr.";
++		SimpleCritter baby = new Critter(prog, babymem, name, 0);
++		loadOneCritter(baby, babyColumn, babyRow);
++
++		if (sc1.getEnergy() == 0 || sc2.getEnergy() == 0)
++		{
++			if (sc1.getEnergy() == 0)
++				kill(sc1);
++			if (sc2.getEnergy() == 0)
++				kill(sc2);
++			return;
++		}
++		sc1.toggleMatingPheromones(false);
++		sc2.toggleMatingPheromones(false);
++	}
++
++	@Override
++	public void critterTag(SimpleCritter tagger, int val)
++	{
++		Hex location = critterMap.get(tagger);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		tagger.updateEnergy(-1 * tagger.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		//if the critter did not have enough energy to complete this action, kills the critter
++		if (tagger.getEnergy() < 0)
++		{
++			kill(tagger);
++			return;
++		}
++
++		int newc = c + tagger.changeInPosition(true, tagger.getOrientation())[0];
++		int newr = r + tagger.changeInPosition(true, tagger.getOrientation())[1];
++		if (!isValidHex(newc, newr))
++		{
++			if (tagger.getEnergy() == 0)
++				kill(tagger);
++			return;
++		}
++
++		Hex directlyInFront = grid[newc][newr];
++		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
++		{
++			SimpleCritter taggee = (SimpleCritter) (directlyInFront.getContent());
++			if (!(val < 0 || val > 99))
++				taggee.setMemory(val, 6);
++		}
++
++		if (tagger.getEnergy() == 0)
++			kill(tagger);
++	}
++
++	@Override
++	public void critterServe(SimpleCritter donator, int index)
++	{
++		Hex location = critterMap.get(donator);
++		int c = location.getColumnIndex();
++		int r = location.getRowIndex();
++
++		if (index < 0)
++			index = 0;
++		else if(index > donator.getEnergy() + donator.size())
++			index = donator.getEnergy() + donator.size();
++
++		donator.updateEnergy(-1 * (donator.size() + index), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++
++		//if the critter did not have enough energy to complete this action, kills the critter
++		if (donator.getEnergy() < 0)
++		{
++			kill(donator);
++			return;
++		}
++
++		int newc = c + donator.changeInPosition(true, donator.getOrientation())[0];
++		int newr = r + donator.changeInPosition(true, donator.getOrientation())[1];
++		if (!isValidHex(newc, newr))
++		{
++			if (donator.getEnergy() == 0)
++				kill(donator);
++			return;
++		}
++
++		Hex directlyInFront = grid[newc][newr];
++		if (directlyInFront.isEmpty())
++		{
++			Food f = new Food(index);
++			directlyInFront.addContent(f);
++		}
++		if (donator.getEnergy() == 0)
++			kill(donator);
++	}
++
++	@Override
++	public void critterSoakEnergy(SimpleCritter sc)
++	{
++		sc.updateEnergy(CONSTANTS.get("SOLAR_FLUX").intValue(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
++	}
++
++	/** Kills a critter and removes it from any lists or mappings of critters. Rest in peace, buddy. */
++	private void kill(SimpleCritter sc)
++	{
++		Hex location = critterMap.get(sc);
++		location.removeContent();
++		critterMap.remove(sc);
++		critterList.remove(sc);
++
++		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
++		location.addContent(remnant);
++	}
++
++	@Override
++	public StringBuilder printGrid()
++	{	
++		StringBuilder result = new StringBuilder();
++		for(int i = 0; i < 2 * rows - columns; i++)
++		{
++			StringBuilder sb = new StringBuilder();
++			if(i % 2 != 0)
++				sb.append("  ");
++			for(int c = i % 2, r = (int) Math.ceil(i / 2.0); c < columns && r < rows; c += 2, r++)
++			{
++				if(isValidHex(c, r))
++					sb.append("" + grid[c][r].toString() + "   ");
++			}
++			result.insert(0, sb.toString() + "\n");
++		}
++		result.insert(0, "World name: " + worldname + "\n");
++		return result;
++	}
++	
++	@Override
++	public int analyzeHex(int c, int r)
++	{
++		if(!isValidHex(c, r))
++			return Integer.MIN_VALUE;
++		return grid[c][r].hexAppearance();
++	}
++	
++	@Override
++	public SimpleCritter analyzeCritter(int c, int r)
++	{
++		if(!isValidHex(c, r) || !(grid[c][r].getContent() instanceof SimpleCritter))
++			return null;
++		return (SimpleCritter) (grid[c][r].getContent());
++	}
++}
+\ No newline at end of file
+diff --git a/src/main/java/simulation/WorldObject.java b/src/main/java/simulation/WorldObject.java
+new file mode 100644
+index 0000000..4b03632
+--- /dev/null
++++ b/src/main/java/simulation/WorldObject.java
+@@ -0,0 +1,16 @@
++package simulation;
++
++public interface WorldObject
++{
++	/** Returns the ASCII art representation of this object. */
++	public String toString();
++	
++	/** 
++	 * Returns an integer value based on this world object. This value depends on the type of this object:
++	 * 		   <ul><li>If this object is a critter, the value will be a positive integer equal to the critter's
++	 * 				   appearance, as determined by {@code SimpleCritter.getAppearance()}.</li>
++	 * 		   <li>If this object is a rock, the value will be -1.</li>
++	 * 		   <li>If the hex contains food, the value will be {@code -1 * ([food calories] + 1)}.</li.</ul>
++	 */
++	public int getAppearance();
++}
+\ No newline at end of file
+diff --git a/src/main/resources/constants.txt b/src/main/resources/constants.txt
+new file mode 100644
+index 0000000..52649f0
+--- /dev/null
++++ b/src/main/resources/constants.txt
+@@ -0,0 +1,19 @@
++BASE_DAMAGE 100 {The multiplier for all damage done by attacking}
++DAMAGE_INC 0.2 {Controls how quickly increased offensive or defensive ability affects damage}
++ENERGY_PER_SIZE 500 {How much energy a critter can have per point of size}
++FOOD_PER_SIZE 200 {How much food is created per point of size when a critter dies}
++MAX_SMELL_DISTANCE 10 {Maximum distance at which food can be sensed}
++ROCK_VALUE -1 {The value reported when a rock is sensed}
++COLUMNS 50 {Default number of columns in the world map}
++ROWS 68 {Default number of rows in the world map}
++MAX_RULES_PER_TURN 999 {The maximum number of rules that can be run per critter turn}
++SOLAR_FLUX 1 {Energy gained from sun by doing nothing}
++MOVE_COST 3 {Energy cost of moving (per unit size)}
++ATTACK_COST 5 {Energy cost of attacking (per unit size)}
++GROW_COST 1 {Energy cost of growing (per size and complexity)}
++BUD_COST 9 {Energy cost of budding (per unit complexity)}
++MATE_COST 5 {Energy cost of successful mating (per unit complexity)}
++RULE_COST 2 {Complexity cost of having a rule}
++ABILITY_COST 25 {Complexity cost of having an ability point}
++INITIAL_ENERGY 250 {Energy of a newly birthed critter}
++MIN_MEMORY 8 {Minimum number of memory entries in a critter}
+\ No newline at end of file
+diff --git a/src/main/resources/world.txt b/src/main/resources/world.txt
+new file mode 100644
+index 0000000..91bdd68
+--- /dev/null
++++ b/src/main/resources/world.txt
+@@ -0,0 +1,14 @@
++name Small world
++size 10 15
++rock 2 2
++rock 3 6
++rock 9 10
++
++// Some food
++food 4 4 500
++food 1 3 1000
++
++// example-critter.txt should be in the working directory
++critter example-critter.txt 2 5 3
++critter example-critter.txt 4 3 1
++critter example-critter.txt 4 4 2
+diff --git a/src/test/java/asttests/RemoveTest.java b/src/test/java/asttests/RemoveTest.java
+deleted file mode 100644
+index 86ace0d..0000000
+--- a/src/test/java/asttests/RemoveTest.java
++++ /dev/null
+@@ -1,118 +0,0 @@
+-package asttests;
+-
+-import static org.junit.Assert.*;
+-
+-import java.util.LinkedList;
+-import org.junit.Test;
+-
+-import ast.*;
+-import ast.BinaryCondition.Operator;
+-import ast.BinaryExpr.MathOp;
+-import ast.Relation.RelOp;
+-import ast.UnaryExpr.ExprType;
+-
+-/**
+- * 
+- * RemoveTest tests the remove function for the different Node types.
+- *
+- */
+-public class RemoveTest
+-{	
+-	@Test
+-	public void testUpdate1()
+-	{
+-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
+-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
+-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
+-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
+-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
+-		Command c = new Command(ll, u6);
+-		
+-		int previousSize = c.size();
+-		u2.acceptMutation(new MutationRemove(true));
+-		assertTrue(previousSize > c.size());
+-		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
+-	}
+-	
+-	@Test
+-	public void testUpdate2()
+-	{
+-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		ll.add(u);
+-		Command c = new Command(ll, u2);
+-		
+-		int previousSize = c.size();
+-		u2.acceptMutation(new MutationRemove(true));
+-		assertTrue(previousSize > c.size());
+-		assertTrue(c.toString().equals(u.toString()));
+-	}
+-	
+-	@Test
+-	public void testUpdate3()
+-	{
+-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		ll.add(u);
+-		Command c = new Command(ll, u2);
+-		
+-		int previousSize = c.size();
+-		u.acceptMutation(new MutationRemove(true));
+-		assertTrue(previousSize > c.size());
+-		assertTrue(c.toString().equals(u2.toString()));
+-	}
+-	@Test
+-	public void testChildlessUnaryExpr()
+-	{
+-		UnaryExpr ue = new UnaryExpr(3);
+-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+-		String before = be.toString();
+-		ue.acceptMutation(new MutationRemove(true));
+-		assertTrue(before.equals(be.toString()));
+-	}
+-	
+-	@Test
+-	public void testUnaryExpr()
+-	{
+-		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
+-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+-		
+-		int previousSize = be.size();
+-		String before = be.toString();
+-		ue.acceptMutation(new MutationRemove(true));
+-		assertTrue(previousSize > be.size());
+-		assertTrue("3 + 2".equals(be.toString()));
+-	}
+-	
+-	@Test
+-	public void testCondition()
+-	{
+-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
+-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+-		UnaryExpr e1 = new UnaryExpr(2);
+-		UnaryExpr e2 = new UnaryExpr(12);
+-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
+-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
+-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
+-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		LinkedList<Update> ll = new LinkedList<Update>();
+-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+-		ll.add(u2);
+-		ll.add(u3);
+-		ll.add(u4);
+-		Command c = new Command(ll, u);
+-		Rule rule = new Rule(con, c);
+-		
+-		con.acceptMutation(new MutationRemove(true));
+-		Rule predictedMutatedRule = new Rule(r1, c);
+-		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
+-	}
+-}
+\ No newline at end of file
+diff --git a/src/test/java/interpretertests/EvalSensingTest.java b/src/test/java/interpretertests/EvalSensingTest.java
+new file mode 100644
+index 0000000..ac1c857
+--- /dev/null
++++ b/src/test/java/interpretertests/EvalSensingTest.java
+@@ -0,0 +1,120 @@
++package interpretertests;
++
++import static org.junit.Assert.*;
++
++import org.junit.Before;
++
++import ast.*;
++import ast.BinaryCondition.Operator;
++import ast.BinaryExpr.MathOp;
++import ast.Relation.RelOp;
++import ast.UnaryExpr.ExprType;
++import console.Console;
++import interpret.Interpreter;
++import interpret.InterpreterImpl;
++import simulation.Critter;
++import simulation.World;
++
++import org.junit.Test;
++
++public class EvalSensingTest
++{
++	int[] arr = {3, 5};
++	Interpreter i;
++	
++	@Before
++	public void setUp()
++	{
++		i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
++	}
++	
++	@Test
++	public void testEvalBinaryCondition()
++	{
++		UnaryExpr e1 = new UnaryExpr(2);
++		UnaryExpr e2 = new UnaryExpr(12);
++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
++		
++		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
++		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
++		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
++		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
++		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
++		
++		assertTrue(new BinaryCondition(r1, Operator.AND, r2).acceptEvaluation(i));
++		assertTrue(new BinaryCondition(r1, Operator.OR, r2).acceptEvaluation(i));
++		assertTrue(new BinaryCondition(r1, Operator.OR, r3).acceptEvaluation(i));
++		assertFalse(new BinaryCondition(r1, Operator.AND, r3).acceptEvaluation(i));
++		assertFalse(new BinaryCondition(r3, Operator.AND, r4).acceptEvaluation(i));
++		assertFalse(new BinaryCondition(r5, Operator.OR, r3).acceptEvaluation(i));
++	}
++
++	@Test
++	public void testEvalRelation()
++	{
++		int[] arr = {3, 5};
++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
++		UnaryExpr e1 = new UnaryExpr(2);
++		UnaryExpr e2 = new UnaryExpr(12);
++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
++		
++		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
++		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
++		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
++		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
++		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
++		assertTrue(r1.acceptEvaluation(i));
++		assertTrue(r2.acceptEvaluation(i));
++		assertFalse(r3.acceptEvaluation(i));
++		assertTrue(r4.acceptEvaluation(i));
++		assertFalse(r5.acceptEvaluation(i));
++	}
++
++	@Test
++	public void testEvalBinaryExpr()
++	{
++		int[] arr = {3, 5};
++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
++		UnaryExpr e1 = new UnaryExpr(2);
++		UnaryExpr e2 = new UnaryExpr(12);
++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
++		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
++		
++		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
++		assertEquals(e3.acceptEvaluation(i), 24);
++		assertEquals(e4.acceptEvaluation(i), -24);
++		assertEquals(e5.acceptEvaluation(i), 73);
++		assertEquals(e6.acceptEvaluation(i), -3);
++	}
++
++	@Test
++	public void testEvalUnaryExpr()
++	{
++		int[] arr = {3, 5};
++		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
++		
++		UnaryExpr e1 = new UnaryExpr(123123);
++		UnaryExpr e2 = new UnaryExpr(253);
++		
++		assertEquals(123123, e1.acceptEvaluation(i));
++		assertEquals(253, e2.acceptEvaluation(i));
++	}
++	
++	@Test
++	/** If the critter in this world senses the world boundary, it will backup. */
++	public void testSenseWorldEdge()
++	{
++		Console c = new Console();
++		c.loadWorld("src/test/resources/simulationTests/SensingWorld.txt");
++		c.worldInfo();
++		c.advanceTime(1);
++		c.worldInfo();
++	}
++}
+\ No newline at end of file
+diff --git a/src/test/java/mutationtests/TestMutateDuplicate.java b/src/test/java/mutationtests/TestMutateDuplicate.java
+index 3bc10ca..5d75a27 100644
+--- a/src/test/java/mutationtests/TestMutateDuplicate.java
++++ b/src/test/java/mutationtests/TestMutateDuplicate.java
+@@ -13,13 +13,11 @@ import ast.MutationReplace;
+ import ast.Program;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ 
+ /**
+- * 
+  * This test class essentially tests the Duplicate Mutation by applying the Duplicate Mutation to random nodes 
+  * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
+- *
+  */
+ public class TestMutateDuplicate {
+ 
+@@ -27,7 +25,7 @@ public class TestMutateDuplicate {
+ 
+ 	@Before
+ 	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+ 		Reader r = new BufferedReader(new InputStreamReader(in));
+ 		Parser p = ParserFactory.getParser();
+ 		prog = p.parse(r);
+diff --git a/src/test/java/mutationtests/TestMutateInsert.java b/src/test/java/mutationtests/TestMutateInsert.java
+index 7e07e96..e1a07bd 100644
+--- a/src/test/java/mutationtests/TestMutateInsert.java
++++ b/src/test/java/mutationtests/TestMutateInsert.java
+@@ -19,7 +19,7 @@ import ast.Sensor;
+ import ast.UnaryExpr;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ 
+ /**
+  * 
+@@ -32,7 +32,7 @@ public class TestMutateInsert {
+ 	Program prog;
+ 	@Before
+ 	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+         Reader r = new BufferedReader(new InputStreamReader(in));
+         Parser p = ParserFactory.getParser();
+         prog = p.parse(r);
+diff --git a/src/test/java/mutationtests/TestMutateRemove.java b/src/test/java/mutationtests/TestMutateRemove.java
+index 6128c76..f20e9c7 100644
+--- a/src/test/java/mutationtests/TestMutateRemove.java
++++ b/src/test/java/mutationtests/TestMutateRemove.java
+@@ -1,48 +1,164 @@
+ package mutationtests;
+ 
++import static org.junit.Assert.assertTrue;
++
+ import java.io.BufferedReader;
+ import java.io.InputStream;
+ import java.io.InputStreamReader;
+ import java.io.Reader;
++import java.util.LinkedList;
+ 
+ import org.junit.Before;
+ import org.junit.Test;
+ 
+ import ast.BinaryCondition;
++import ast.BinaryExpr;
++import ast.Command;
++import ast.Condition;
+ import ast.MutationRemove;
+ import ast.Program;
++import ast.Relation;
+ import ast.Rule;
++import ast.UnaryExpr;
+ import ast.Update;
++import ast.BinaryCondition.Operator;
++import ast.BinaryExpr.MathOp;
++import ast.Relation.RelOp;
++import ast.UnaryExpr.ExprType;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ 
+ /**
+- * 
+- * This test class essentially tests the Remove Mutation by applying the Random Mutation to random nodes 
+- * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
+- *
++ * This test class essentially tests the Remove Mutation by applying the mutation to random nodes in the
++ * program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
+  */
+-public class TestMutateRemove {
++public class TestMutateRemove
++{
+ 	Program prog;
+ 
+ 	@Before
+-	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++	public void setup()
++	{
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+ 		Reader r = new BufferedReader(new InputStreamReader(in));
+ 		Parser p = ParserFactory.getParser();
+ 		prog = p.parse(r);
+ 	}
+ 	
+ 	@Test
+-	public void testMutate() {
++	public void testRandom()
++	{
+ 		int n = 0;
+ 		for (int i = 0; i < prog.size(); i++)
++		{
+ 			n = (int) (Math.random() * (prog.size()));
+-			try {
++			try 
++			{
+ 				System.out.println(prog.mutate(n, new MutationRemove(true)).toString());
+-			} catch (NullPointerException e) {
++			}
++			catch (NullPointerException e)
++			{
+ 				 System.out.println("Incompatible node type");
+ 			}
++		}
++	}
++	
++	@Test
++	public void testUpdate1()
++	{
++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
++		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
++		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
++		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
++		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++		LinkedList<Update> ll = new LinkedList<Update>();
++		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
++		Command c = new Command(ll, u6);
++		
++		int previousSize = c.size();
++		u2.acceptMutation(new MutationRemove(true));
++		assertTrue(previousSize > c.size());
++		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
++	}
++	
++	@Test
++	public void testUpdate2()
++	{
++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++		LinkedList<Update> ll = new LinkedList<Update>();
++		ll.add(u);
++		Command c = new Command(ll, u2);
++		
++		int previousSize = c.size();
++		u2.acceptMutation(new MutationRemove(true));
++		assertTrue(previousSize > c.size());
++		assertTrue(c.toString().equals(u.toString()));
++	}
++	
++	@Test
++	public void testUpdate3()
++	{
++		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
++		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
++		LinkedList<Update> ll = new LinkedList<Update>();
++		ll.add(u);
++		Command c = new Command(ll, u2);
++		
++		int previousSize = c.size();
++		u.acceptMutation(new MutationRemove(true));
++		assertTrue(previousSize > c.size());
++		assertTrue(c.toString().equals(u2.toString()));
++	}
++	@Test
++	public void testChildlessUnaryExpr()
++	{
++		UnaryExpr ue = new UnaryExpr(3);
++		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
++		String before = be.toString();
++		ue.acceptMutation(new MutationRemove(true));
++		assertTrue(before.equals(be.toString()));
++	}
++	
++	@Test
++	public void testUnaryExpr()
++	{
++		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
++		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
++		
++		int previousSize = be.size();
++		String before = be.toString();
++		ue.acceptMutation(new MutationRemove(true));
++		assertTrue(previousSize > be.size());
++		assertTrue("3 + 2".equals(be.toString()));
++	}
++	
++	@Test
++	public void testCondition()
++	{
++		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
++		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
++		UnaryExpr e1 = new UnaryExpr(2);
++		UnaryExpr e2 = new UnaryExpr(12);
++		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
++		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
++		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
++		Condition con = new BinaryCondition(r1, Operator.AND, r2);
++		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
++		LinkedList<Update> ll = new LinkedList<Update>();
++		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
++		ll.add(u2);
++		ll.add(u3);
++		ll.add(u4);
++		Command c = new Command(ll, u);
++		Rule rule = new Rule(con, c);
++		
++		con.acceptMutation(new MutationRemove(true));
++		Rule predictedMutatedRule = new Rule(r1, c);
++		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
+ 	}
+ }
+diff --git a/src/test/java/mutationtests/TestMutateReplace.java b/src/test/java/mutationtests/TestMutateReplace.java
+index 22513a6..5f70bb3 100644
+--- a/src/test/java/mutationtests/TestMutateReplace.java
++++ b/src/test/java/mutationtests/TestMutateReplace.java
+@@ -13,7 +13,7 @@ import ast.MutationTransform;
+ import ast.Program;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ 
+ /**
+  * 
+@@ -27,7 +27,7 @@ public class TestMutateReplace {
+ 
+ 	@Before
+ 	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+ 		Reader r = new BufferedReader(new InputStreamReader(in));
+ 		Parser p = ParserFactory.getParser();
+ 		prog = p.parse(r);
+diff --git a/src/test/java/mutationtests/TestMutateSwap.java b/src/test/java/mutationtests/TestMutateSwap.java
+index 3e4206a..d5b046b 100644
+--- a/src/test/java/mutationtests/TestMutateSwap.java
++++ b/src/test/java/mutationtests/TestMutateSwap.java
+@@ -17,7 +17,7 @@ import ast.MutationInsert;
+ import ast.BinaryExpr.*;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ import ast.MutationSwap;
+ import ast.Program;
+ import ast.UnaryExpr;
+@@ -34,7 +34,7 @@ public class TestMutateSwap {
+ 	Program prog;
+ 	@Before
+ 	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+         Reader r = new BufferedReader(new InputStreamReader(in));
+         Parser p = ParserFactory.getParser();
+         prog = p.parse(r);
+diff --git a/src/test/java/mutationtests/TestMutateTransform.java b/src/test/java/mutationtests/TestMutateTransform.java
+index ee87cca..4011203 100644
+--- a/src/test/java/mutationtests/TestMutateTransform.java
++++ b/src/test/java/mutationtests/TestMutateTransform.java
+@@ -23,7 +23,7 @@ import ast.UnaryExpr;
+ import ast.Update;
+ import parse.Parser;
+ import parse.ParserFactory;
+-import parsertests.ParserTest;
++import parsertests.ASTParserTest;
+ 
+ /**
+  * 
+@@ -37,7 +37,7 @@ public class TestMutateTransform {
+ 
+ 	@Before
+ 	public void setup() {
+-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
++		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
+ 		Reader r = new BufferedReader(new InputStreamReader(in));
+ 		Parser p = ParserFactory.getParser();
+ 		prog = p.parse(r);
+diff --git a/src/test/java/parsertests/ParserTest.java b/src/test/java/parsertests/ASTParserTest.java
+similarity index 92%
+rename from src/test/java/parsertests/ParserTest.java
+rename to src/test/java/parsertests/ASTParserTest.java
+index 4d3711c..2789d73 100644
+--- a/src/test/java/parsertests/ParserTest.java
++++ b/src/test/java/parsertests/ASTParserTest.java
+@@ -15,19 +15,19 @@ import parse.ParserFactory;
+ import parse.Tokenizer;
+ 
+ /** This class contains tests for the Critter parser. */
+-public class ParserTest
++public class ASTParserTest
+ {
+     /** Checks that a valid critter program is not {@code null} when parsed. 
+      * Different test cases were run using this same method by changing the filename for the input stream
+      * This methodology was implemented because the program terminates elsewhere in the program, so the 
+      * remainder of the tests cannot be performed. A key of the filename and the type of error it tests is included
+      * in the overview.
+-     * */
++     */
+ 	
+     @Test
+     public void testProgramIsNotNull()
+     {
+-        InputStream in = ParserTest.class.getResourceAsStream("draw_critter.txt");
++        InputStream in = ASTParserTest.class.getResourceAsStream("draw_critter.txt");
+         Reader r = new BufferedReader(new InputStreamReader(in));
+         Parser p = ParserFactory.getParser();
+         Program prog = p.parse(r);
+diff --git a/src/test/java/parsertests/FileParserTest.java b/src/test/java/parsertests/FileParserTest.java
+new file mode 100644
+index 0000000..52571a2
+--- /dev/null
++++ b/src/test/java/parsertests/FileParserTest.java
+@@ -0,0 +1,149 @@
++package parsertests;
++
++import static org.junit.Assert.*;
++import java.io.*;
++import org.junit.Test;
++
++import ast.Program;
++import parse.Parser;
++import parse.ParserFactory;
++import simulation.Critter;
++import simulation.FileParser;
++import simulation.SimpleCritter;
++
++public class FileParserTest
++{
++
++	@Test
++	public void testParseAttributes1()
++	{
++		try
++		{
++			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/example-critter.txt")));
++			
++			assertEquals(test.length, 7);
++			assertTrue(test[0].equals("example"));
++			assertTrue(test[1].equals("9"));
++			assertTrue(test[2].equals("2"));
++			assertTrue(test[3].equals("3"));
++			assertTrue(test[4].equals("1"));
++			assertTrue(test[5].equals("500"));
++			assertTrue(test[6].equals("17"));
++		}
++		catch (FileNotFoundException e)
++		{
++			fail();
++		}
++	}
++	
++	@Test
++	public void testParseAttributes2()
++	{
++		try
++		{
++			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/failure-example-critter1.txt")));
++			
++			assertEquals(test.length, 7);
++			assertTrue(test[0].equals(""));
++			assertTrue(test[1].equals(""));
++			assertTrue(test[2].equals(""));
++			assertTrue(test[3].equals(""));
++			assertTrue(test[4].equals(""));
++			assertTrue(test[5].equals(""));
++			assertTrue(test[6].equals(""));
++		}
++		catch (FileNotFoundException e)
++		{
++			fail();
++		}
++	}
++	
++	@Test
++	public void testConsoleLoad() //TODO remove when done testing
++	{
++		try
++		{
++			BufferedReader br = new BufferedReader(new FileReader("examples/example-critter.txt"));
++			String[] parsed = FileParser.parseAttributes(br);
++			String name = parsed[0].equals("") ? "Untitled" : parsed[0];
++			int[] critAttr = makeCritterAttributes(parsed);
++			
++			Parser p = ParserFactory.getParser();
++			Program prog = p.parse(br);
++			
++			SimpleCritter sc = new Critter(prog, critAttr, name, -1);
++		}
++		catch (FileNotFoundException e)
++		{
++			System.err.println("Critter file not found.");
++			return;
++		}
++	}
++	
++	/**
++	 * Prepares an int array to be used as critter memory, based on a string array.<br>
++	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
++	 * @param strs an array of strings created by the method {@code FileParser.parseAttributes(filename)}
++	 * @return an int array, ready to be used as critter memory
++	 */
++	private int[] makeCritterAttributes(String[] strs)
++	{
++		int[] critterAttributes;
++		
++		int memsize = parseIntFromString(strs[1]);
++		if(memsize < 8)
++			memsize = 8;
++		critterAttributes = new int[memsize];
++		critterAttributes[0] = memsize;
++		
++		int defense = parseIntFromString(strs[2]);
++		if(defense < 0)
++			defense = 3;
++		critterAttributes[1] = defense;
++		
++		int offense = parseIntFromString(strs[3]);
++		if(offense < 0)
++		offense = 3;
++		critterAttributes[2] = offense;
++		
++		int size = parseIntFromString(strs[4]);
++		if(size < 0)
++			size = 1;
++		critterAttributes[3] = size;
++		
++		int energy = parseIntFromString(strs[5]);
++		if(energy < 0)
++			energy = 500;
++		critterAttributes[4] = energy;
++		
++		int pass = 0;
++		critterAttributes[5] = pass;
++		
++		int tag = 0;
++		critterAttributes[6] = tag;
++		
++		int posture = parseIntFromString(strs[6]);
++		if(posture < 0 || posture > 99)
++			posture = 0;
++		critterAttributes[7] = posture;
++		
++		return critterAttributes;
++	}
++	
++	/**
++	 * Parses an integer value from a given string, or returns -1 if no integer was found.
++	 * @param s the string to parse
++	 * @return the int parsed from the string, or -1 if no integer was found
++	 */
++	private int parseIntFromString(String s)
++	{
++		try
++		{
++			return Integer.parseInt(s);
++		}
++		catch (NumberFormatException n)
++		{
++			return -1;
++		}
++	}
++}
+\ No newline at end of file
+diff --git a/src/test/java/simulationTests/AttackTests.java b/src/test/java/simulationTests/AttackTests.java
+new file mode 100644
+index 0000000..2859cb7
+--- /dev/null
++++ b/src/test/java/simulationTests/AttackTests.java
+@@ -0,0 +1,28 @@
++package simulationTests;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class AttackTests {
++
++	Console console1 = null;
++	
++	@Before
++	 public void setup() {
++		 console1 = new Console();
++		 console1.loadWorld("src/test/resources/simulationTests/AttackWorld.txt");
++	 }
++	
++	/**
++	 * testBasicAttack tests attack by having a massive critter attack a tiny critter. The smaller critter
++	 * should die.
++	 */
++	@Test
++	public void testBasicAttack() {
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++	}
++}
+diff --git a/src/test/java/simulationTests/BudTest.java b/src/test/java/simulationTests/BudTest.java
+new file mode 100644
+index 0000000..e24891d
+--- /dev/null
++++ b/src/test/java/simulationTests/BudTest.java
+@@ -0,0 +1,67 @@
++package simulationTests;
++
++import static org.junit.Assert.*;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class BudTest {
++
++	Console console1 = null;
++	Console console2 = null;
++	Console console3 = null;
++
++	@Before
++	public void setup() {
++		console1 = new Console();
++		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
++		console2 = new Console();
++		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
++		console3 = new Console();
++		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
++	}
++
++	/**
++	 * testBasicBud checks to see if a critter can bud under normal circumstances.
++	 */
++	@Test
++	public void testBasicBud() {
++		System.out.println("testBasicBud");
++		int initialNumCritters = console1.crittersAlive();
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++		assertEquals(initialNumCritters + 1, console1.crittersAlive());
++	}
++
++	/**
++	 * testBudWithRock checks to see that a critter does not bud when there is a
++	 * rock behind it.
++	 */
++	@Test
++	public void testBudWithRock() {
++		System.out.println("testBudWithRock");
++		int initialNumCritters = console2.crittersAlive();
++		console2.worldInfo();
++		console2.advanceTime(1);
++		console2.worldInfo();
++		assertEquals(initialNumCritters, console2.crittersAlive());
++	}
++
++	/**
++	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
++	 * It also tests to see if critter death properly adds a food object onto the site of death.
++	 */
++	@Test
++	public void testBudNoEnergy() {
++		System.out.println("testBudNoEnergy");
++		int initialNumCritters = console3.crittersAlive();
++		console3.worldInfo();
++		console3.advanceTime(1);
++		console3.worldInfo();
++		assertEquals(initialNumCritters - 1, console3.crittersAlive());
++	}
++
++}
+diff --git a/src/test/java/simulationTests/MateTest.java b/src/test/java/simulationTests/MateTest.java
+new file mode 100644
+index 0000000..7c6efad
+--- /dev/null
++++ b/src/test/java/simulationTests/MateTest.java
+@@ -0,0 +1,83 @@
++package simulationTests;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class MateTest {
++	Console console1 = null;
++	Console console2 = null;
++	Console console3 = null;
++	Console console4 = null;
++	
++	@Before
++	public void setUp()
++	{
++		console1 = new Console();
++		console1.loadWorld("src/test/resources/simulationTests/MateWorld.txt");
++		console2 = new Console();
++		console2.loadWorld("src/test/resources/simulationTests/MateWorldRock.txt");
++		console3 = new Console();
++		console3.loadWorld("src/test/resources/simulationTests/MateWorldLittleEnergy.txt");
++		console4 = new Console();
++		console4.loadWorld("src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt");
++	}
++	
++	/**
++	 * simpleTest tests to see if two critters who want to mate can mate and create an offspring.
++	 */
++	
++	
++	@Test
++	public void simpleTest() {
++		System.out.println("simpleTest");
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++	}
++	
++	
++	/**
++	 * mateWithRock tests to see what happens when a couple of critters tries to mate but with a rock behind one of
++	 * them. The mating works if the baby is put behind the critter that is not in front of the rock, and the baby dies
++	 * if it is placed on the rock. 
++	 */
++	
++	@Test
++	public void mateWithRock() {
++		System.out.println("mateWithRock");
++		console2.worldInfo();
++		console2.advanceTime(1);
++		console2.worldInfo();
++	}
++	
++	/**
++	 * mateLittleEnergy checks to see what happens to the parents when they try to mate when they
++	 * do not have enough energy. The parents then die. 
++	 */
++	@Test
++	public void mateLittleEnergy() {
++		System.out.println("mateLittleEnergy");
++		console3.worldInfo();
++		console3.advanceTime(1);
++		console3.worldInfo();
++	}
++	
++	
++	
++	/**
++	 * mateDifferentTimeStep checks to see what happens when two parents want to mate, but they
++	 * want to mate on different time steps. While one of the parents wants to mate, the other one waits
++	 * and vice versa. As a result, the parents should not be able to mate. During this test, wait is also
++	 * tested in this test.
++	 */
++	@Test
++	public void mateDifferentTimeStep() {
++		System.out.println("mateDifferentTimeStep");
++		console4.worldInfo();
++		console4.advanceTime(17);
++		console4.worldInfo();
++	}
++	
++}
+diff --git a/src/test/java/simulationTests/MovingTest.java b/src/test/java/simulationTests/MovingTest.java
+new file mode 100644
+index 0000000..18ff962
+--- /dev/null
++++ b/src/test/java/simulationTests/MovingTest.java
+@@ -0,0 +1,74 @@
++package simulationTests;
++
++import static org.junit.Assert.*;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class MovingTest
++{
++	Console console1 = null;
++	Console console2 = null;
++	Console console3 = null;
++	Console console4 = null;
++	
++	@Before
++	public void setUp()
++	{
++		console1 = new Console();
++		console1.loadWorld("src/test/resources/simulationTests/MovingWorld.txt");
++		console2 = new Console();
++		console2.loadWorld("src/test/resources/simulationTests/MovingWorldFileRock.txt");
++		console3 = new Console();
++		console3.loadWorld("src/test/resources/simulationTests/MovingWorldThree.txt");
++		console4 = new Console();
++		console4.loadWorld("src/test/resources/simulationTests/MovingWorldFour.txt");
++		
++	}
++	/**
++	 * testNormalMove tests to see if moving forward normally works.
++	 */
++	@Test
++	public void testNormalMove()
++	{
++		System.out.println("testNormalMove");
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++	}
++	
++	/**
++	 * testMoveWithRock tests to see that critter won't move when there is a rock in front of it.
++	 */
++	@Test
++	public void testMoveWithRock() {
++		System.out.println("testMoveWithRock");
++		console2.worldInfo();
++		console2.advanceTime(1);
++		console2.worldInfo();
++	}
++	
++	/**
++	 * testMovingWithNoEnergy tests to see that a critter without enough energy to move dies.
++	 */
++	@Test
++	public void testMovingWithNoEnergy() {
++		System.out.println("testMovingWithNoEnergy");
++		console3.worldInfo();
++		console3.advanceTime(1);
++		console3.worldInfo();
++	}
++
++	/**
++	 * testMoveInvalidLocation checks to see if a critter does not move to an invalid location
++	 */
++	@Test
++	public void testMovingInvalidLocation() {
++		System.out.println("testMovingInvalidLocation");
++		console4.worldInfo();
++		console4.advanceTime(1);
++		console4.worldInfo();
++	}
++}
+diff --git a/src/test/java/simulationTests/SpiralCritterTest.java b/src/test/java/simulationTests/SpiralCritterTest.java
+new file mode 100644
+index 0000000..18af1b3
+--- /dev/null
++++ b/src/test/java/simulationTests/SpiralCritterTest.java
+@@ -0,0 +1,29 @@
++package simulationTests;
++
++import org.junit.Test;
++
++import console.Console;
++
++public class SpiralCritterTest
++{
++
++	@Test
++	/** 
++	 * There isn't really any world functionality that allows us to perform automated testing for the spiral critter in any
++	 * practical way, so we just used this simple test and analyzed the successive printouts of the world grid after each
++	 * successive turn.
++	 */
++	public void test()
++	{
++		Console c = new Console();
++		c.loadWorld("src/test/resources/simulationTests/SpiralCritterWorld.txt");
++		c.worldInfo();
++		
++		for(int i = 0; i < 60; i++)
++		{
++			c.advanceTime(1);
++			c.worldInfo();
++		}
++	}
++
++}
+diff --git a/src/test/java/simulationTests/TurnAndNearbyTests.java b/src/test/java/simulationTests/TurnAndNearbyTests.java
+new file mode 100644
+index 0000000..a1aa66a
+--- /dev/null
++++ b/src/test/java/simulationTests/TurnAndNearbyTests.java
+@@ -0,0 +1,48 @@
++package simulationTests;
++
++import org.junit.Before;
++import org.junit.Test;
++
++import console.Console;
++
++public class TurnAndNearbyTests {
++
++	Console console1 = null;
++	Console console2 = null;
++	Console console3 = null;
++	Console console4 = null;
++
++	@Before
++	public void setUp() {
++		console1 = new Console();
++		console1.loadWorld("src/test/resources/simulationTests/TurnWorldTwo.txt");
++		console2 = new Console();
++		console2.loadWorld("src/test/resources/simulationTests/TurnNearbyWorld.txt");
++
++	}
++
++	/**
++	 * simpleTurn checks to see if a critter can turn right and left properly
++	 */
++	@Test
++	public void simpleTurn() {
++		System.out.println("simpleTurn");
++		console1.worldInfo();
++		console1.advanceTime(1);
++		console1.worldInfo();
++	}
++
++	/**
++	 * turnIfFood tests to see if a critter can turn if there is food right next to it. Nearby was
++	 * also tested by placing the food at different points around the critter and having the critter turn if
++	 * it can sense it. As a result, this test covers both functionalities. 
++	 */
++	
++	@Test
++	public void turnIfFood() {
++		System.out.println("turnIfFood");
++		console2.worldInfo();
++		console2.advanceTime(1);
++		console2.worldInfo();
++	}
++}
+diff --git a/src/test/resources/simulationTests/AttackCritter1.txt b/src/test/resources/simulationTests/AttackCritter1.txt
+new file mode 100644
+index 0000000..efa20bd
+--- /dev/null
++++ b/src/test/resources/simulationTests/AttackCritter1.txt
+@@ -0,0 +1,8 @@
++species: Attack Critter 2
++memsize: 11
++defense: 2
++offense: 3000
++size: 50
++energy: 50000
++posture: 17
++3 = 3 --> attack;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/AttackCritter2.txt b/src/test/resources/simulationTests/AttackCritter2.txt
+new file mode 100644
+index 0000000..5b14f81
+--- /dev/null
++++ b/src/test/resources/simulationTests/AttackCritter2.txt
+@@ -0,0 +1,8 @@
++species: Attack Critter 2
++memsize: 11
++defense: 1
++offense: 3
++size: 1
++energy: 5
++posture: 17
++3 = 3 --> wait;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/AttackWorld.txt b/src/test/resources/simulationTests/AttackWorld.txt
+new file mode 100644
+index 0000000..d1151bb
+--- /dev/null
++++ b/src/test/resources/simulationTests/AttackWorld.txt
+@@ -0,0 +1,5 @@
++name Attack World 
++size 5 10
++
++critter src/test/resources/simulationTests/AttackCritter1.txt 3 4 0
++critter src/test/resources/simulationTests/AttackCritter2.txt 3 5 3
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/BudCritter.txt b/src/test/resources/simulationTests/BudCritter.txt
+new file mode 100644
+index 0000000..18fcd09
+--- /dev/null
++++ b/src/test/resources/simulationTests/BudCritter.txt
+@@ -0,0 +1,8 @@
++species: example
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 5000000
++posture: 17
++3 = 3 --> bud;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/BudCritterNoEnergy.txt b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
+new file mode 100644
+index 0000000..f289ce6
+--- /dev/null
++++ b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
+@@ -0,0 +1,8 @@
++species: example
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 200
++posture: 17
++3 = 3 --> bud;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/BudWorld.txt b/src/test/resources/simulationTests/BudWorld.txt
+new file mode 100644
+index 0000000..f606bf2
+--- /dev/null
++++ b/src/test/resources/simulationTests/BudWorld.txt
+@@ -0,0 +1,4 @@
++name Bud World 1
++size 5 10
++
++critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/BudWorld3.txt b/src/test/resources/simulationTests/BudWorld3.txt
+new file mode 100644
+index 0000000..aea4f1b
+--- /dev/null
++++ b/src/test/resources/simulationTests/BudWorld3.txt
+@@ -0,0 +1,4 @@
++name Bud World 3
++size 5 10
++
++critter src/test/resources/simulationTests/BudCritterNoEnergy.txt 3 5 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/BudWorldRock.txt b/src/test/resources/simulationTests/BudWorldRock.txt
+new file mode 100644
+index 0000000..e3bed1c
+--- /dev/null
++++ b/src/test/resources/simulationTests/BudWorldRock.txt
+@@ -0,0 +1,4 @@
++name Bud World 2
++size 5 10
++rock 3 4
++critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MateWorld.txt b/src/test/resources/simulationTests/MateWorld.txt
+new file mode 100644
+index 0000000..62ea1a2
+--- /dev/null
++++ b/src/test/resources/simulationTests/MateWorld.txt
+@@ -0,0 +1,5 @@
++name Mate World 
++size 5 10
++
++critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
++critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
+new file mode 100644
+index 0000000..127dfcd
+--- /dev/null
++++ b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
+@@ -0,0 +1,5 @@
++name Mate World Different Time Steps
++size 5 10
++
++critter src/test/resources/simulationTests/MatingParent5.txt 3 4 0
++critter src/test/resources/simulationTests/MatingParent6.txt 3 5 3
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MateWorldLittleEnergy.txt b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
+new file mode 100644
+index 0000000..7fe7a11
+--- /dev/null
++++ b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
+@@ -0,0 +1,5 @@
++name Mate World Little Energy
++size 5 10
++
++critter src/test/resources/simulationTests/MatingParent3.txt 3 4 0
++critter src/test/resources/simulationTests/MatingParent4.txt 3 5 3
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MateWorldRock.txt b/src/test/resources/simulationTests/MateWorldRock.txt
+new file mode 100644
+index 0000000..5c3b717
+--- /dev/null
++++ b/src/test/resources/simulationTests/MateWorldRock.txt
+@@ -0,0 +1,5 @@
++name Mate World Rock
++size 5 10
++rock 3 6
++critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
++critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent1.txt b/src/test/resources/simulationTests/MatingParent1.txt
+new file mode 100644
+index 0000000..f64bca0
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent1.txt
+@@ -0,0 +1,8 @@
++species: Parent 1
++memsize: 11
++defense: 2
++offense: 3
++size: 5
++energy: 50000
++posture: 17
++3 = 3 --> mate;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent2.txt b/src/test/resources/simulationTests/MatingParent2.txt
+new file mode 100644
+index 0000000..15b068a
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent2.txt
+@@ -0,0 +1,8 @@
++species: Parent 2
++memsize: 11
++defense: 2
++offense: 3
++size: 5
++energy: 50000
++posture: 17
++3 = 3 --> mate;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent3.txt b/src/test/resources/simulationTests/MatingParent3.txt
+new file mode 100644
+index 0000000..1944f06
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent3.txt
+@@ -0,0 +1,8 @@
++species: Parent 3
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 50000
++posture: 17
++3 = 3 --> mate;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent4.txt b/src/test/resources/simulationTests/MatingParent4.txt
+new file mode 100644
+index 0000000..e740384
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent4.txt
+@@ -0,0 +1,8 @@
++species: Parent 4
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 50000
++posture: 17
++3 = 3 --> mate;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent5.txt b/src/test/resources/simulationTests/MatingParent5.txt
+new file mode 100644
+index 0000000..6f0890a
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent5.txt
+@@ -0,0 +1,9 @@
++species: Parent 5
++memsize: 11
++defense: 2
++offense: 3
++size: 5
++energy: 50000
++posture: 17
++mem[8] = 0 --> mem[8] := 1 wait;
++mem[8] = 1 --> mem[8] := 0 mate;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MatingParent6.txt b/src/test/resources/simulationTests/MatingParent6.txt
+new file mode 100644
+index 0000000..b112422
+--- /dev/null
++++ b/src/test/resources/simulationTests/MatingParent6.txt
+@@ -0,0 +1,9 @@
++species: Parent 6
++memsize: 11
++defense: 2
++offense: 3
++size: 5
++energy: 50000
++posture: 17
++mem[8] = 0 --> mem[8] := 1 mate;
++mem[8] = 1 --> mem[8] := 0 wait;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MovingCritter.txt b/src/test/resources/simulationTests/MovingCritter.txt
+new file mode 100644
+index 0000000..3bb2486
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingCritter.txt
+@@ -0,0 +1,8 @@
++species: example
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 500
++posture: 17
++3 = 3 --> forward;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
+new file mode 100644
+index 0000000..1dc3af5
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
+@@ -0,0 +1,8 @@
++species: example
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 2
++posture: 17
++3 = 3 --> forward;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MovingWorld.txt b/src/test/resources/simulationTests/MovingWorld.txt
+new file mode 100644
+index 0000000..6f1baea
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingWorld.txt
+@@ -0,0 +1,4 @@
++name Moving World
++size 5 10
++
++critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MovingWorldFileRock.txt b/src/test/resources/simulationTests/MovingWorldFileRock.txt
+new file mode 100644
+index 0000000..845f953
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingWorldFileRock.txt
+@@ -0,0 +1,4 @@
++name Moving World2
++size 5 10
++rock 3 6
++critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
+diff --git a/src/test/resources/simulationTests/MovingWorldFour.txt b/src/test/resources/simulationTests/MovingWorldFour.txt
+new file mode 100644
+index 0000000..c9a3ea8
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingWorldFour.txt
+@@ -0,0 +1,4 @@
++name Moving World 4
++size 5 10
++
++critter src/test/resources/simulationTests/MovingCritter.txt 4 9 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/MovingWorldThree.txt b/src/test/resources/simulationTests/MovingWorldThree.txt
+new file mode 100644
+index 0000000..322aa54
+--- /dev/null
++++ b/src/test/resources/simulationTests/MovingWorldThree.txt
+@@ -0,0 +1,4 @@
++name Moving World 3
++size 5 10
++
++critter src/test/resources/simulationTests/MovingCritterLittleEnergy.txt 3 5 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/SensingCritter.txt b/src/test/resources/simulationTests/SensingCritter.txt
+new file mode 100644
+index 0000000..dcb097b
+--- /dev/null
++++ b/src/test/resources/simulationTests/SensingCritter.txt
+@@ -0,0 +1,9 @@
++species: Sensing Critter
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 500
++posture: 17
++
++ahead[1] = -1 --> backward;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
+new file mode 100644
+index 0000000..5abacf0
+--- /dev/null
++++ b/src/test/resources/simulationTests/SensingWorld.txt
+@@ -0,0 +1,4 @@
++name Sensing World 1
++size 5 10
++
++critter SensingCritter.txt 4 9 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
+new file mode 100644
+index 0000000..7102f96
+--- /dev/null
++++ b/src/test/resources/simulationTests/SpiralCritterWorld.txt
+@@ -0,0 +1,3 @@
++name Spiral World
++size 11 13
++critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/TurnNearbyWorld.txt b/src/test/resources/simulationTests/TurnNearbyWorld.txt
+new file mode 100644
+index 0000000..64bb6c2
+--- /dev/null
++++ b/src/test/resources/simulationTests/TurnNearbyWorld.txt
+@@ -0,0 +1,4 @@
++name Turn World 1
++size 5 10
++food 3 3 500
++critter src/test/resources/simulationTests/Turner1.txt 3 4 0
+diff --git a/src/test/resources/simulationTests/TurnWorldTwo.txt b/src/test/resources/simulationTests/TurnWorldTwo.txt
+new file mode 100644
+index 0000000..d53c1bb
+--- /dev/null
++++ b/src/test/resources/simulationTests/TurnWorldTwo.txt
+@@ -0,0 +1,3 @@
++name Turn World 1
++size 5 10
++critter src/test/resources/simulationTests/Turner2.txt 3 4 0
+diff --git a/src/test/resources/simulationTests/Turner1.txt b/src/test/resources/simulationTests/Turner1.txt
+new file mode 100644
+index 0000000..1647100
+--- /dev/null
++++ b/src/test/resources/simulationTests/Turner1.txt
+@@ -0,0 +1,8 @@
++species: Turner 1
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 50000
++posture: 17
++nearby[3] < -1 --> right;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/Turner2.txt b/src/test/resources/simulationTests/Turner2.txt
+new file mode 100644
+index 0000000..56f98be
+--- /dev/null
++++ b/src/test/resources/simulationTests/Turner2.txt
+@@ -0,0 +1,8 @@
++species: Turner 1
++memsize: 11
++defense: 2
++offense: 3
++size: 1
++energy: 50000
++posture: 17
++3 = 3  --> left;
+\ No newline at end of file
+diff --git a/src/test/resources/simulationTests/spiral_critter.txt b/src/test/resources/simulationTests/spiral_critter.txt
+new file mode 100644
+index 0000000..8da44ad
+--- /dev/null
++++ b/src/test/resources/simulationTests/spiral_critter.txt
+@@ -0,0 +1,21 @@
++species: Spiral
++memsize: 12
++defense: 2
++offense: 3
++size: 1
++energy: 500
++posture: 17
++
++//ensures that the critter has enough energy, and will eat food in its way
++ENERGY <= SIZE * 3 --> wait;
++ahead[1] < -1 --> eat;
++
++mem[9] = 0 --> mem[8] := mem[8] + 1 mem[9] := 1 forward;
++
++mem[9] = 1 and mem[10] = 0 --> mem[10] := mem[10] + 1 right;
++mem[10] = 1 and mem[11] < mem[8] - 1 --> mem[11] := mem[11] + 1 forward;
++mem[10] = 1 and mem[11] = mem[8] - 1 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
++
++mem[11] < mem[8] --> mem[11] := mem[11] + 1 forward;
++mem[11] = mem[8] and mem[10] < 6 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
++mem[10] = 6 and mem[9] = 1 --> mem[9] := 0 mem[10] := 0 mem[11] := 0;
+\ No newline at end of file
+diff --git a/world.txt b/world.txt
+new file mode 100644
+index 0000000..91bdd68
+--- /dev/null
++++ b/world.txt
+@@ -0,0 +1,14 @@
++name Small world
++size 10 15
++rock 2 2
++rock 3 6
++rock 9 10
++
++// Some food
++food 4 4 500
++food 1 3 1000
++
++// example-critter.txt should be in the working directory
++critter example-critter.txt 2 5 3
++critter example-critter.txt 4 3 1
++critter example-critter.txt 4 4 2
diff --git a/log.txt b/log.txt
index 7aedfce..c324f63 100644
--- a/log.txt
+++ b/log.txt
@@ -1,122 +1,147 @@
-[33mcommit fce536fec1b6d39c94b8eb25247226e99b89f023[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
+commit 06cb727814873d6888a15d8da8ad12d94cb8e408
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 23:26:00 2017 -0400
+
+    Testing Finished
+
+commit 0536fee80bfb57c1dac79b65123fbaa29a995502
+Merge: 221e8ca cb93ef2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 23:09:59 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 221e8cafbb3634896fea5fd40c47cb06e9eb8172
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 23:09:32 2017 -0400
+
+    Attack Tests
+
+commit cb93ef26d11bd86c1a934f2a1b9d46993bb0cb53
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 22:49:26 2017 -0400
+
+    fix merge
+
+commit fce536fec1b6d39c94b8eb25247226e99b89f023
 Merge: faaae27 41fe28e
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 22:47:22 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit faaae27e8751ae57808ad7b3b0819f7624e3e782[m
+commit faaae27e8751ae57808ad7b3b0819f7624e3e782
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 22:46:48 2017 -0400
 
     Final tests
 
-[33mcommit 41fe28e826698ca5cf3e31913bdf54842644b50c[m
+commit 41fe28e826698ca5cf3e31913bdf54842644b50c
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 22:44:40 2017 -0400
 
     Testing Done
 
-[33mcommit 3f34641d080ef40ea4dbab4d1980324643736d26[m
+commit 3f34641d080ef40ea4dbab4d1980324643736d26
 Merge: 3631e4c 2e8bab8
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 21:38:55 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit 3631e4cef53d386e115ab7fa8364e9d22a95efe9[m
+commit 3631e4cef53d386e115ab7fa8364e9d22a95efe9
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 21:38:49 2017 -0400
 
     Turning Tests
 
-[33mcommit 2e8bab888d0b606f53dda0b449210c2f3996abdc[m
+commit 2e8bab888d0b606f53dda0b449210c2f3996abdc
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 21:35:36 2017 -0400
 
     More Tests
 
-[33mcommit 90fd50cc87b830aff15673e999c4cd22044a9543[m
+commit 90fd50cc87b830aff15673e999c4cd22044a9543
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 20:43:50 2017 -0400
 
     Tests!
 
-[33mcommit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5[m
+commit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 20:14:08 2017 -0400
 
     SpiralCritter works now
 
-[33mcommit 9bdbd6cc4f186af60209dce78176917924f76428[m
+commit 9bdbd6cc4f186af60209dce78176917924f76428
 Merge: 4c6c2ee 4892088
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 16:57:49 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51[m
+commit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 16:57:41 2017 -0400
 
     Minor fixes
 
-[33mcommit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac[m
+commit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 15:37:39 2017 -0400
 
     Mating Testing Final
 
-[33mcommit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3[m
+commit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 15:31:26 2017 -0400
 
     Mating Testing
 
-[33mcommit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460[m
+commit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460
 Merge: d3b6060 753823a
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 14:59:59 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit d3b60607e47ccc71ddb9a8a65f249e65e127bb22[m
+commit d3b60607e47ccc71ddb9a8a65f249e65e127bb22
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 14:58:53 2017 -0400
 
     Mate Test Change
 
-[33mcommit 9ca82f204cd008b0e3449775ebc042e96557f9a4[m
+commit 9ca82f204cd008b0e3449775ebc042e96557f9a4
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 14:57:30 2017 -0400
 
     File Parser Update
 
-[33mcommit ecdea17320fd143cf698fc9faa53d5b39131f071[m
+commit ecdea17320fd143cf698fc9faa53d5b39131f071
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 14:57:00 2017 -0400
 
     Mate Testing Done and Bug Fixed
 
-[33mcommit b669ff85cd406986cb387789b43c622d2fd53366[m
+commit b669ff85cd406986cb387789b43c622d2fd53366
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 13:11:19 2017 -0400
 
     Mate Testing
 
-[33mcommit b24dcaeecb0961141406915da0977e58847259c1[m
+commit b24dcaeecb0961141406915da0977e58847259c1
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 13:01:45 2017 -0400
 
     Testing
 
-[33mcommit d9804214694a1287b36387ab5096161119fb7d2a[m
+commit d9804214694a1287b36387ab5096161119fb7d2a
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 13:00:32 2017 -0400
 
     Testing2
 
-[33mcommit 760b3702d46d973fc51fdfe2988e1365e553c229[m
+commit 760b3702d46d973fc51fdfe2988e1365e553c229
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 12:59:02 2017 -0400
 
@@ -124,25 +149,25 @@ Date:   Tue Oct 31 12:59:02 2017 -0400
     
     This reverts commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28.
 
-[33mcommit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28[m
+commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 12:54:41 2017 -0400
 
     Testing
 
-[33mcommit 753823a1f154f70f6e374d0b5e88df5d8239cd1e[m
+commit 753823a1f154f70f6e374d0b5e88df5d8239cd1e
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 12:49:12 2017 -0400
 
     more fixes
 
-[33mcommit 086816869af82477368bfd3c77e6e9f1cff9e8fd[m
+commit 086816869af82477368bfd3c77e6e9f1cff9e8fd
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 12:46:23 2017 -0400
 
     Fixes
 
-[33mcommit a02473c4318c5f7012d276aed173e05a84fa7cfd[m
+commit a02473c4318c5f7012d276aed173e05a84fa7cfd
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 12:42:26 2017 -0400
 
@@ -151,121 +176,1232 @@ Date:   Tue Oct 31 12:42:26 2017 -0400
     This reverts commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b, reversing
     changes made to 21179a6b02c48db2457e6bdb649d6b4b581bd6e3.
 
-[33mcommit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b[m
+commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b
 Merge: 21179a6 8fc49a4
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 12:41:21 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3[m
+commit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 12:40:30 2017 -0400
 
     Stuff
 
-[33mcommit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24[m
+commit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 12:39:25 2017 -0400
 
     Tokenizer Has Been Updated With Correct Solution
 
-[33mcommit cebe8f1a5273b0a0a02553cd42f682511f53e186[m
+commit cebe8f1a5273b0a0a02553cd42f682511f53e186
 Merge: 0343510 878321e
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 09:16:26 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit 03435103759b26ede1d3b7c4215dd1f117cd927a[m
+commit 03435103759b26ede1d3b7c4215dd1f117cd927a
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Tue Oct 31 09:16:19 2017 -0400
 
     Bud Test
 
-[33mcommit 878321e363ceaa0b2d586c8be5b0102618d50634[m
+commit 878321e363ceaa0b2d586c8be5b0102618d50634
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 02:11:11 2017 -0400
 
     Documentation
 
-[33mcommit dc3812325cb76cf5af623bba64f907b01ca7e243[m
+commit dc3812325cb76cf5af623bba64f907b01ca7e243
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 01:31:22 2017 -0400
 
     Misc stuff
 
-[33mcommit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba[m
+commit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 01:09:31 2017 -0400
 
     Documentation + finishing up console
 
-[33mcommit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9[m
+commit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9
 Author: Andy <az389@cornell.edu>
 Date:   Tue Oct 31 00:01:43 2017 -0400
 
     More documentation
 
-[33mcommit 4c6783d0533f75d5d9b97742f61e7803f5aa4390[m
+commit 4c6783d0533f75d5d9b97742f61e7803f5aa4390
 Merge: c4f5689 adc8c91
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 23:51:40 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit c4f56899144a8923b956408256221a5e46fcc436[m
+commit c4f56899144a8923b956408256221a5e46fcc436
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 23:51:38 2017 -0400
 
     Documentation
 
-[33mcommit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b[m
+commit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b
 Merge: 88613b7 ef684b3
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Mon Oct 30 23:47:38 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2[m
+commit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Mon Oct 30 23:47:33 2017 -0400
 
     Moving Test Done
 
-[33mcommit ef684b37c2fe6924efcc416a45c716297c9f46d6[m
+commit ef684b37c2fe6924efcc416a45c716297c9f46d6
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 23:45:01 2017 -0400
 
     Fixes
 
-[33mcommit 067278303066953f1241de39755d7545b4cb4b1e[m
+commit 067278303066953f1241de39755d7545b4cb4b1e
 Merge: a6d2ead 5a4812d
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 23:43:56 2017 -0400
 
     Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
 
-[33mcommit a6d2eadf9badd7c0c163420549e66e2f9eaa2145[m
+commit a6d2eadf9badd7c0c163420549e66e2f9eaa2145
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 23:43:41 2017 -0400
 
     Spiral stuff
 
-[33mcommit 5a4812d93de841aed1720ee36c4a6e9304f368e0[m
+commit 5a4812d93de841aed1720ee36c4a6e9304f368e0
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Mon Oct 30 23:25:53 2017 -0400
 
     Moving Test Initial
 
-[33mcommit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c[m
+commit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c
 Author: Andy <az389@cornell.edu>
 Date:   Mon Oct 30 17:53:50 2017 -0400
 
     SpiralCritter stuff
 
-[33mcommit 200b419d4d5d2162ef30ddeb630491a180dd968d[m
+commit 200b419d4d5d2162ef30ddeb630491a180dd968d
 Author: sn438 <31802007+sn438@users.noreply.github.com>
 Date:   Mon Oct 30 17:35:38 2017 -0400
 
- 
\ No newline at end of file
+    SpiralCritter
+
+commit b4cab4286088176f2f7ee316592c66d85e0d54f5
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 16:49:55 2017 -0400
+
+    Misc documentation
+
+commit 4fe3d49e3f68f9dd82055f7a2ab67133fa85d7c3
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 13:45:54 2017 -0400
+
+    printGrid() done + documentation
+
+commit a8a0b4d970eb609ccdd7ca775bbd6be0f16e69e9
+Merge: 9c7dfe2 ccf4130
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 16:48:55 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 9c7dfe2312d03c62c5836b8bad57421da07b2bcc
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 16:48:52 2017 -0400
+
+    Fixing stuff
+
+commit ccf413096637d20c08578d5a8471d265917e5b91
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 29 15:51:11 2017 -0400
+
+    Revert "Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw""
+    
+    This reverts commit 1659d793a583869999bcf2ca34ff03cf3d7a0325.
+
+commit 1659d793a583869999bcf2ca34ff03cf3d7a0325
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 29 15:51:04 2017 -0400
+
+    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw"
+    
+    This reverts commit 1dc49ddf303427f10e7b9c582c9b300e915c92ee, reversing
+    changes made to 3c4e297b634c05eb3ff84b6914cc68f1249cdb62.
+
+commit 1dc49ddf303427f10e7b9c582c9b300e915c92ee
+Merge: 3c4e297 b95cc0d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 29 15:45:30 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3c4e297b634c05eb3ff84b6914cc68f1249cdb62
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 29 15:42:47 2017 -0400
+
+    Mate is Now Written
+
+commit b95cc0d1aea9e658efa280b562408048438a012a
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 14:34:45 2017 -0400
+
+    Documentation and misc fixes
+
+commit 2f35f14b524a751d259dba895bf349faeab53abf
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 12:55:05 2017 -0400
+
+    Bug fixes
+
+commit 39c7d863224537bf0cf67f30caec497663b95fae
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 02:19:48 2017 -0400
+
+    Minor changes
+
+commit 6634ef197704354faec0a7b034f6b247ca272555
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 29 01:33:02 2017 -0400
+
+    Everything except mate seems to be working
+
+commit 688c6243af2b3043fe323a82912db4a89029c96e
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 28 20:03:09 2017 -0400
+
+    Bug fixes
+
+commit e17d79d4e673173cee38ae77407ec73ccaaacef5
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 28 18:50:25 2017 -0400
+
+    Mutations Now Works For the Offspring
+
+commit 574213e79aa5e7cc53ae933330ba27746fa1cc0d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 28 17:45:31 2017 -0400
+
+    Bud Written Not Tested Yet
+
+commit d6b1f8e0753d0729480649d58fd6df8711f5e4cb
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 28 15:56:42 2017 -0400
+
+    More work on actions
+
+commit ba76d56c96f3cdaefab5a3f0f39e316eb5f4081c
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 28 14:05:44 2017 -0400
+
+    Bug fix
+
+commit 230d8656c6b125a062282412a7de04656dd53e7b
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 28 13:48:55 2017 -0400
+
+    Working on critter actions
+
+commit 6864476813997db576208179515867002b196da4
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 28 02:35:09 2017 -0400
+
+    Work on executing actions
+
+commit eded6017adc247fd6b87d6efeb51f9c53e4e9456
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 27 16:23:06 2017 -0400
+
+    Miscellaneous fixes for world creation
+
+commit 817e650e1e7db5b5331a4451d3e1bd84090b33f6
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 27 15:34:25 2017 -0400
+
+    We can parse and create worlds now!
+
+commit b85b3471c254a4ee7e833dcb0b0171cb6de01812
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 27 02:23:09 2017 -0400
+
+    Random world creation seems to work now
+
+commit 0505e11fa4626d992d410e1cb6bc4e4fe43169ce
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 26 13:16:13 2017 -0400
+
+    A5 grind
+
+commit ed8272a172cba17610fa47e1b46b9439929a40ed
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 25 00:44:21 2017 -0400
+
+    More A5 stuff!
+
+commit 026920b66cdbb1770bb68f357d95b2fd22ec9c01
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 24 22:47:15 2017 -0400
+
+    More stuff on A5!
+
+commit 99d68e420850d05d9909afc7a4dd3bd3a77f695f
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 23 14:29:41 2017 -0400
+
+    Finishing up interpreter
+
+commit 33f80a05f8d015b98f73df2d4472e38d083547eb
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 23 00:44:43 2017 -0400
+
+    A crap ton of work for A5
+
+commit 9644950902cbbc61d88496792a8b3f41b4bd01c9
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 22 00:32:16 2017 -0400
+
+    Beginning of A5
+
+commit 234a8439af7fdd86f54cef7019fc9988347a6b11
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 18 15:33:29 2017 -0400
+
+    Deleted old log
+
+commit 1d3a3be36fa9efdef8151b9499ffb94c9a963f2b
+Merge: 9e38ff4 815597a
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Tue Oct 17 07:59:37 2017 -0400
+
+    Merge branch 'master' of github.coecis.cornell.edu:cs2112-f17/a4-release
+
+commit 9e38ff4fbd847de76c423e16030186127ff61a09
+Merge: 539a973 b6b5f8a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 23:42:49 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 539a973e0a1f2fd93738bc8548010653f62d3dec
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 23:42:44 2017 -0400
+
+    Final Test Cases
+
+commit b6b5f8aeb7baf817366791f98bf13014fd5b7707
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 23:20:26 2017 -0400
+
+    More cleanup
+
+commit 1a1c3d3553c93eb032c45404eb36f35c72c7a24f
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 23:01:09 2017 -0400
+
+    Adding print statements
+
+commit 8a5f8d6866f15d8e16b2c9350d0c27aa40aa3861
+Merge: bd7441c 881c12e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 22:48:57 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit bd7441c49ab620dc59422d9581ffc0551b75b7f1
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 22:47:36 2017 -0400
+
+    Comments and Stuff
+
+commit 881c12e3a491495aa1cbbe61ec014c593153da90
+Merge: cdf51fe f2b31b9
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 22:39:06 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit cdf51fecb03134fd191148a1a1f0c8f06ee69dc2
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 22:39:04 2017 -0400
+
+    Miscellaneous changes
+
+commit f2b31b9cd307bbf907a39144dd1767f1d06d5833
+Merge: 0dde501 be7a6a2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 22:13:53 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 0dde5016b2473b3d613e3b1948602e10653c19ea
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 22:13:06 2017 -0400
+
+    Mutation Print Statements
+
+commit be7a6a2b421e718c7e3eea8350bd0acbb7531348
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 21:22:41 2017 -0400
+
+    Added findRoot method to AbstractMutation
+
+commit c3c23f9177547bc361c9ec616369dfd6ea77ef04
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 20:58:58 2017 -0400
+
+    Weird merge conflict stuff
+
+commit 80d565be7e0f32e0182148a87cac4ca258143483
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 20:55:46 2017 -0400
+
+    Weird merge stuff
+
+commit f26b34db1f30d59e2c56eef98676916f577339b7
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 20:50:37 2017 -0400
+
+    Fixing merge conflicts
+
+commit b4502b00fd077833f6575bebdbdac40c22a51a55
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 20:48:48 2017 -0400
+
+    More cleanup
+
+commit cab431590fb2de5ef7deb5d279f39ae118b7f252
+Merge: ac14d01 2aa663d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 20:29:09 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit ac14d0164cea23c7df5135484e9cd6d40011a1f4
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 20:29:00 2017 -0400
+
+    Some Tests
+
+commit 2aa663d222343983b171ec0e4fc96e99f8212812
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 20:21:33 2017 -0400
+
+    Cleanups and bug fixes
+
+commit 77c50a2f2d3ca7911530e09be609d7b16ff40e91
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 18:52:09 2017 -0400
+
+    Work on insert
+
+commit 052da7bfa11e0af2d724abd4bd13e7a10d117043
+Merge: 4348a7f 49143d7
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 16:36:52 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 4348a7fd47861e5aaa1a22107e0d666f82eb5b28
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 16:36:47 2017 -0400
+
+    Misc work and documentation
+
+commit 49143d7b6092206f2dab796946e131ff0ccfc1d4
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 16:35:11 2017 -0400
+
+    Test File
+
+commit 15bbc3900bca53f73ad3bb93098b38fefa10e330
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 15:20:10 2017 -0400
+
+    Some work with insert and transform
+
+commit adcfb0219416b5f91e935af7173dd4e7c08e3d87
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 14:40:50 2017 -0400
+
+    Fixes and testing
+
+commit 7f8a314e2ced238eac2adc978e9fe8ad62894119
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 14:40:22 2017 -0400
+
+    Testing Files
+
+commit 965e2c3c48b6c322c753bcab5e1622f2e1a3097c
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 14:33:15 2017 -0400
+
+    Commit Initial Insert Implementation
+
+commit 3a959f4ced103fd74673d3143364e34f4d7bff3c
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 13:39:31 2017 -0400
+
+    Fixed a bug in NodeAt
+
+commit c0fcbf70408211cdbde427b43ca0cb205254dcc7
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 12:37:22 2017 -0400
+
+    Debugging replace
+
+commit 2b2ef6c1b2244f0158abb886610f1444ad62c2cf
+Merge: 5579cb2 cf67aa2
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 03:24:25 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 5579cb28b24cfb8bced689e99425491f2c13a7fa
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 03:24:18 2017 -0400
+
+    MutateTransform Seems To Work
+
+commit cf67aa2c2c409216685336a0dbad683c23579e1f
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 02:33:39 2017 -0400
+
+    Work on MutationDuplicate
+
+commit f5077ecfad932393c2169603cabf21d4d212c5d4
+Merge: 3fb5b19 794d787
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 00:37:58 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 3fb5b19bc7b640015fb64e10a8f3cf378bc464a8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 16 00:37:54 2017 -0400
+
+    Merge Commit
+
+commit 794d787d96838141819c1a0c058ad517e4953e58
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 16 00:25:57 2017 -0400
+
+    Finished MutationRemove and added test
+
+commit 67d2fc084ce4f9255c8458739709060518916d2c
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 23:43:32 2017 -0400
+
+    Work with MutationRemove
+
+commit fce2eb0a237809e95033466be57fa074339ba33c
+Merge: dee740e 69ab4d9
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 20:50:35 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit dee740e95e3b8f21629e303d0b5ac5924f6163be
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 20:49:52 2017 -0400
+
+    More Cleanup
+
+commit 69ab4d9e8387ae53be31316f33f36c6a86777cad
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 20:47:49 2017 -0400
+
+    MergeSwap Now Works
+
+commit bcde017f3da5a46ebd5a3060e3d47eaba6f6bdef
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 20:37:07 2017 -0400
+
+    Mutation interface changes
+
+commit e22722cb347b4bd4597320b36c3e2d687b9329b1
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 20:34:00 2017 -0400
+
+    Start on searchChildrenForType
+
+commit 4890a5574cdfc395934203b490a71e9005c4bf8f
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 18:53:58 2017 -0400
+
+    Cleanup
+
+commit 3cf383381d9e20c46263215b7c53dd673660079d
+Merge: be1604c 5433934
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 18:46:22 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit be1604cea9b62399a5eb8d9a5fb2cb72fa7735f4
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 18:45:03 2017 -0400
+
+    Work on Mutations
+
+commit 5433934f070810b8dc4f55f12d6be122aa8ca303
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 18:43:22 2017 -0400
+
+    Tokenizer Bug Fix
+
+commit 815597af6fb9f775869ef2ba51bb5d6f66027c42
+Author: Shiyu <sw673@cornell.edu>
+Date:   Sun Oct 15 18:38:42 2017 -0400
+
+    update A5 README
+
+commit d31d9d429f0307d5ecb5b5d2498d5b406add1989
+Merge: 5433ba1 08798b1
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 18:11:20 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 5433ba10a88a3470d48feefb5100f6e8e70f4636
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 18:11:04 2017 -0400
+
+    Merge
+
+commit 08798b19810497041a9105b84cbdfcdc1a92851e
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 15:58:22 2017 -0400
+
+    Fixing merge gibberish
+
+commit ed7b982c359a0cf5028f3907ca2a366c9dc0487c
+Merge: 6198a3a 6bf1984
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 15:56:24 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 6198a3a2db240f566d1fe0a1395fbfc2f0ba04cb
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 15:56:21 2017 -0400
+
+    Added NodeType functionality
+
+commit 6bf1984c29bbb21a072ec9ab88e98af3b034ab2c
+Merge: cdbf211 d2ffb8d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 12:43:36 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit cdbf21130d6847eb62f3f09849e45138d0e86053
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sun Oct 15 12:43:17 2017 -0400
+
+    Merge
+
+commit d2ffb8dbde25f019f2e6121692a2c1093fbf7594
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 12:41:57 2017 -0400
+
+    Added parent pointers and some basic mutation stuff
+
+commit 11944723dbd966f12e45714c69d45eda8fe23af6
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 15 03:08:30 2017 -0400
+
+    Initial Mutation stuff
+
+commit c81daea79acf1103989b63f10af31fea388a1c80
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 14 18:23:03 2017 -0400
+
+    Cleanup
+
+commit 41775701fe1f4cd4e303419abde0f7cea7f50c06
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 14 17:16:23 2017 -0400
+
+    AST Now Understands Comments
+
+commit 364eada1687bb165343dc1308ecab6728bb28857
+Merge: f5e3749 4a58bfd
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 14 16:53:32 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit f5e3749e998d2d41338f7d078823fb27ea415b3e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 14 16:53:28 2017 -0400
+
+    Merge
+
+commit 4a58bfd50f953b609438bbc6bbb1964685051f63
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 14 16:52:18 2017 -0400
+
+    Added Deep Copy functionality (UNTESTED)
+
+commit d8c3aa8b584ede7a25e30f0ce44137271248f632
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Sat Oct 14 07:48:38 2017 -0400
+
+    Revert "Remove a4 main class"
+    
+    This reverts commit 620c7a43d207103c789c3fb1c4c2290bae429a95.
+
+commit 8903ca5826cbcffb5d969663e051fb3d949ed641
+Author: Shiyu <sw673@cornell.edu>
+Date:   Fri Oct 13 23:03:05 2017 -0400
+
+    added example world and critter
+
+commit 01683953258616d8f04a2a1a243b74bdae4fdfc3
+Author: Shiyu <sw673@cornell.edu>
+Date:   Fri Oct 13 22:54:15 2017 -0400
+
+    update main class in build.gradle
+
+commit 620c7a43d207103c789c3fb1c4c2290bae429a95
+Author: Shiyu <sw673@cornell.edu>
+Date:   Fri Oct 13 22:48:04 2017 -0400
+
+    Remove a4 main class
+
+commit e0892b69efdf555834a762fa1e1afcf557191e94
+Author: Shiyu <sw673@cornell.edu>
+Date:   Fri Oct 13 22:19:12 2017 -0400
+
+    Initial commit for A5
+
+commit a1b0c9a25c1d72d5515a5f710187730fb5cc3212
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 13 13:16:17 2017 -0400
+
+    Cleanups
+
+commit d2cf11bbe6b8d6c36003611c02d76551ee31a446
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Fri Oct 13 01:27:54 2017 -0400
+
+    Example Failing Test Case
+
+commit 033ac4142a2e18462f1bb8bb7d96d9cdc3057ee5
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 13 00:53:51 2017 -0400
+
+    Garbage push
+
+commit 75f7148b8470b3f597517da1e261da53ca76ad4d
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 13 00:51:07 2017 -0400
+
+    Completed Parser? Need to test more
+
+commit ba48d2d9dc0cfee34bca14de6a24ae305076c74b
+Merge: a27ded0 45e3d2d
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 23:32:43 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a27ded04f3377f3ac5c0f3b206837f30efdd88e1
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 23:32:41 2017 -0400
+
+    Finished parseCommand and parseUpdate and parseAction
+
+commit 45e3d2d5f5c2616c5ee58cacad3c68b9d7a347ba
+Merge: d386876 e95541a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Oct 12 23:14:38 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit e95541ad13e483b8c30e3409b9eec240ff9a70fb
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 23:07:02 2017 -0400
+
+    Some progress on parseCommand
+
+commit d3868761baad8d335305a4e91c28a86889a836f8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Oct 12 22:55:48 2017 -0400
+
+    Tiniest Bug Fix Possible
+
+commit 5b6b5dea06ff0fc7f29a750e2bd36f767e612d55
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 20:50:01 2017 -0400
+
+    Cleanup
+
+commit 91c94e87e37f76410ccf4101db475ebe47d58020
+Merge: 8e6f5e2 8cf5213
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Oct 12 20:45:21 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 8e6f5e292e1bc5ef54b26a136b449802d5514b4d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Thu Oct 12 20:44:58 2017 -0400
+
+    Why Dis Class So Hard Man Why?
+
+commit 8cf521393c289017de01457c5e0ded53f4e22941
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 20:42:01 2017 -0400
+
+    Please work
+
+commit a7ff5c820d294545869aa282db3b5114cabd9cc6
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 11:47:24 2017 -0400
+
+    Cleanup
+
+commit 969d32c75a5faf0c28a1617be5eb52066a3d3b7a
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 11:47:03 2017 -0400
+
+    Fixed null pointer exception
+
+commit fd04c2d04013628a89e5bb5412c731c1d01caa73
+Author: Andy <az389@cornell.edu>
+Date:   Thu Oct 12 00:53:40 2017 -0400
+
+    nodeAt (haven't tested yet)
+
+commit 3a1dda2498a8d6bb6b87a91cb8c867f14eb52326
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 22:30:07 2017 -0400
+
+    Misc cleanups and nodeAt
+
+commit 466b9b9a08343fb7921d06495253c19e53cbd300
+Merge: 903080a af51dd6
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 22:01:12 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 903080a857fcbc75d73630f33da1784c05539f7c
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 22:00:44 2017 -0400
+
+    Beginning work on nodeAt
+
+commit af51dd6f4ed60fcbc5caa0996d3d3c2caee47e47
+Merge: 54b7d39 eee15a8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 21:47:27 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 54b7d3996d9c29b7bfac734a9a66f855d0ddfca6
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 21:47:19 2017 -0400
+
+    Merge Commit
+
+commit eee15a85f8b493a6be97175f53db9e3b95752016
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 21:30:38 2017 -0400
+
+    Fixed reading negative factors
+
+commit ddf500da2295a4719b474d3d6b379d811fdc6ddc
+Merge: d63d441 c501e26
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 20:29:20 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit d63d4411597c35f42363e0a75a3d632aa2200184
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 20:29:18 2017 -0400
+
+    Cleaning up messy switch statements
+
+commit c501e26957402726c65b8b4300ec505a0b66c0a3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 20:28:49 2017 -0400
+
+    Terrible Implementation
+
+commit e933565781f0b5707a5446ecdbc0fdccdfbd3ff2
+Merge: c8f60da f17469e
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 18:46:08 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit c8f60da07b0ccae5da938571eb81463efcdf4c9e
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 18:46:06 2017 -0400
+
+    Testing and added a //TODO comment
+
+commit f17469ec34dbcd41116efc06a7eb332fbb9a5aa5
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 18:37:07 2017 -0400
+
+    Expression Should Work Now After Office Hours
+
+commit b9a4e80a64f9bc28831138393851c5b40905d5ce
+Merge: a4c8cf4 cdfd63d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 18:12:26 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit a4c8cf478fcac632de340171beedd3ee6ce0465e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 18:12:21 2017 -0400
+
+    Expression With Different Negation Implementation
+
+commit cdfd63d7bfa7201a37b73d20dc57b792df0cf637
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 11 13:22:29 2017 -0400
+
+    Added proper ProgramImpl creation to ParserImpl.
+    
+    Also wrote a bunch of documentation.
+
+commit af0ea59522e428a21b3778495eae7eb25e903ae9
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 02:47:25 2017 -0400
+
+    Expression Seems to Be Working
+
+commit 5719f8120bc4964435082a0356ed3d73c3629170
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 11 01:34:27 2017 -0400
+
+    Parsing With Factor Implementation
+    
+    Has some String statements in it that should be taken out later.
+
+commit 6b706c206f2527bd22b0f9d9a746120244dfae85
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 17:09:35 2017 -0400
+
+    Quick tests for pretty printing and size
+
+commit 889d7b84753d324325101306191ca57dc1a13ad2
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 16:49:40 2017 -0400
+
+    Added size() functionality.
+    
+    Still untested.
+
+commit e1030c17f851653566849017e22b768c052e6031
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 16:10:05 2017 -0400
+
+    Changed name of evaluateNode() to evaluate()
+
+commit 2ada007083b7cdecbb26dbdd7dfcc4b67d2f34bb
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 16:02:24 2017 -0400
+
+    More AST pretty printing
+    
+    Also added some more documentation.
+
+commit 383380ffb26ff7e01067a28cb44c33bb60536a0d
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 15:07:29 2017 -0400
+
+    Adding more AST nodes
+    
+    Completed pretty printing functionality? Have yet to test it
+
+commit 19867a0c71bac3e419e5338a676d45dcf943e363
+Merge: b54de06 98c4bd3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 10 01:36:10 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit b54de06e76296f1ba7df64efe344799b03d2e238
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 10 01:35:15 2017 -0400
+
+    Merge Test
+
+commit 98c4bd3a5a800d9369962d220742cc0b2b9c1275
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 10 01:17:13 2017 -0400
+
+    More nodes
+
+commit 0dae210c65395ae9820102e9a71cf7702131efe3
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 9 23:02:17 2017 -0400
+
+    Cleaning up prettyprinting
+
+commit 98c807bfc3555f5b885f2ab601d13f6e0d549707
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 9 22:14:32 2017 -0400
+
+    Cleaned Up Some of The Weird Git Merge Errors
+
+commit 7e4058e0ef9cb2cefa542892c68551b810d2c5b5
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 9 20:39:48 2017 -0400
+
+    Garbage Commit
+
+commit d8c18b9e183bddf66b80cfd3979fdf24b54fef16
+Merge: 14f9246 bcbac9a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 9 20:36:49 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+commit 14f9246264248a07b22811dc4322c8773963b6ef
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 9 20:36:28 2017 -0400
+
+    Initial Parsing Commit: Barely Working
+
+commit bcbac9a71a41a75cc4a622474fdf2d9fa785a8ad
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 9 13:38:50 2017 -0400
+
+    Added PrettyPrint functionality to some nodes.
+
+commit 2dca9ff6a23bf526c5f994bc090580fa5ced4a0d
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 9 02:40:38 2017 -0400
+
+    Initial Parsing Code
+
+commit b44bc837fd76add8a499b11b53ee9bd154c8ef72
+Author: Andy <az389@cornell.edu>
+Date:   Sun Oct 8 23:24:03 2017 -0400
+
+    Creating a few more classes
+
+commit 1eacab181ac1ee04aa9b05b959639b6829f78fe0
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 23:17:48 2017 -0400
+
+    More misc
+
+commit 9cacefa5a19dbc46c63c8c6d55670c5820ee824d
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 23:17:00 2017 -0400
+
+    Miscellaneous work
+
+commit d82ed5429c812f117f6140060fc55498975f3a37
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 7 21:11:25 2017 -0400
+
+    UnaryExpr
+
+commit 312ed20a032d4fa9877d84c950b145762fc7b797
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 19:19:06 2017 -0400
+
+    Work on BinaryExpr
+
+commit c73bb400d579e7c63fd6cd4518213c3be54b099a
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 17:38:42 2017 -0400
+
+    Testing
+
+commit 00e1fa6f353a61b9381ef49841235a87da6eee0a
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 17:35:03 2017 -0400
+
+    What is going on
+
+commit c003dedf29be628930a8790de3114bec89d4eaa8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 7 17:32:34 2017 -0400
+
+    Commit
+
+commit 8ae4fdc7dc881dc1ef2fb01c30d0841bbc14e492
+Merge: 6f05ca4 53c4c2b
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 7 17:28:23 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+    
+    That's okay just let it merge.
+
+commit 6f05ca4d729156e6660d11e35db5cc4476a70eaa
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Sat Oct 7 17:27:41 2017 -0400
+
+    Third Test
+
+commit 53c4c2b2145a668b9c209d5424c0d100e8456a74
+Author: Andy <az389@cornell.edu>
+Date:   Sat Oct 7 17:25:38 2017 -0400
+
+    Adding new classes
+    
+    Added BinaryExpr and AbstractNode
+
+commit d01569a2a53f3e351619f70779987c94d145f8a4
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 6 16:15:07 2017 -0400
+
+    FORMATTING AHHHHH
+    
+    yes.
+
+commit 8bc818d587a8432fa93c77b69d2ba5eac16ddde4
+Author: Andy <az389@cornell.edu>
+Date:   Fri Oct 6 01:23:17 2017 -0400
+
+    FORMATTING.
+    
+    AHHHHHH
+
+commit 9a24289728ff1947e893643e7d52f3631401faea
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Wed Oct 4 23:26:09 2017 -0400
+
+    Second Test
+
+commit 27b2ad811e24b1b047922ab388e7607e3dcb4e27
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 4 21:10:07 2017 -0400
+
+    Test commit
+
+commit d86b272fc0997fb0e6317c52a4b008a10876e047
+Author: Andy <az389@cornell.edu>
+Date:   Wed Oct 4 16:33:10 2017 -0400
+
+    Formatting.
+    
+    Did not touch the classes Tokenizer and TokenType.
+
+commit ec0c0cbfcf07c48337cb8418401fd0706f517d00
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Wed Sep 27 07:00:30 2017 -0400
+
+    fix build.gradle
+
+commit 04b331b5522051b14e575f07b2604064ff6a2331
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Wed Sep 27 06:57:53 2017 -0400
+
+    update main class in jar
+
+commit 12522579bc0cd8c1ac044bf393c472d01c0b8bbc
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Wed Sep 27 06:56:20 2017 -0400
+
+    update readme
+
+commit a93e8a384e79dcf6275a0388d7c2e7903fdea7d9
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Wed Sep 27 06:54:42 2017 -0400
+
+    update readme
+
+commit 36f6c0347f6c3833028aa5e3d85a2cd1bf552a7c
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Tue Sep 26 20:28:47 2017 -0400
+
+    update gitignore
+
+commit 8821b53a01fc5c1b3ed87534b79dc77701244810
+Author: Jacob Glueck <swimgiraffe435@gmail.com>
+Date:   Tue Sep 26 20:15:08 2017 -0400
+
+    rename
+
+commit 7df160b24f17047dc8728648aef62e25d002364e
+Author: Kenneth Wang Fang <kwf37@cornell.edu>
+Date:   Sun Sep 24 21:33:33 2017 -0400
+
+    Update README.md
+
+commit eaec237ed515ae2af243f363faf468de1f0bf79d
+Author: Kenneth Wang Fang <kwf37@cornell.edu>
+Date:   Sun Sep 24 19:19:05 2017 -0400
+
+    Update README.md
+
+commit f3047f3b22aab046b1bcad165dd49edee47efa6e
+Author: Travis Stephen Westura <tsw52@cornell.edu>
+Date:   Sun Sep 24 16:07:29 2017 -0400
+
+    Updated README.md to fix a few typos
+
+commit 20b5fdf1415a432f9883ecea18a3693e50f637e9
+Author: Kenneth Wang Fang <kwf37@cornell.edu>
+Date:   Sun Sep 24 15:04:08 2017 -0400
+
+    Added some gradle info
+
+commit 9071e6c4bea8d968e0228b7c421f3389cc3f3164
+Author: Kenneth Wang Fang <kwf37@cornell.edu>
+Date:   Sun Sep 24 14:28:28 2017 -0400
+
+    Added Git instructinos
+
+commit f35fb464b5841565a1d7499cfada19183b1a1f02
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 19:01:04 2017 -0400
+
+    small update to example test
+
+commit e166fa58cf171728212f8b39a5654485f796d41c
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:59:35 2017 -0400
+
+    Add example test
+
+commit f68e672761aaf65c8d725208c6e96a949ffe0518
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:32:19 2017 -0400
+
+    Add readme file to the test directory
+
+commit 0962bf39e4b12cde0a84e89e705ba3590dae28ea
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:30:05 2017 -0400
+
+    Update jar output in gradle build file
+
+commit 614cf3ad27c42a61bfc1555f1d87ccaa1efcceda
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:28:02 2017 -0400
+
+    Move example program resources to the test
+
+commit 69d53902393fb0cab3dd9cba9a187a11d7466bbb
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:25:39 2017 -0400
+
+    Remove repeated resources folder
+
+commit fe07f661c087d1eaab52333f88fc237afd0c9879
+Author: Travis Westura <twestura@gmail.com>
+Date:   Sat Sep 23 18:21:52 2017 -0400
+
+    Initial commit of a4 files
diff --git a/src/main/java/ast/MutationTransform.java b/src/main/java/ast/MutationTransform.java
index ea98f5f..5540e47 100644
--- a/src/main/java/ast/MutationTransform.java
+++ b/src/main/java/ast/MutationTransform.java
@@ -154,7 +154,7 @@ public class MutationTransform extends AbstractMutation
 	public boolean mutate(UnaryExpr ue)
 	{
 		Random r = new Random();
-		ue.setValue(java.lang.Integer.MAX_VALUE/r.nextInt());
+		ue.setValue(java.lang.Integer.MAX_VALUE/(r.nextInt(java.lang.Integer.MAX_VALUE) + 1));
 		if(printMutationDetail)
 			System.out.println("Transformed the Unary Expression node\n" + ue + "\n");
 		return true;
diff --git a/src/main/java/gui/A6_written_problems.txt b/src/main/java/gui/A6_written_problems.txt
new file mode 100644
index 0000000..4a2f8b6
--- /dev/null
+++ b/src/main/java/gui/A6_written_problems.txt
@@ -0,0 +1,28 @@
+1. An implementation of or() is provided below:
+
+/** Returns: disjunction of this and that (this OR that). */
+public TVBool or(TVBool that) {
+	TVBool result = new TVBool();
+	result.state = Math.max(this.state, that.state);
+	return result;
+}
+
+2. normalize() is implemented correctly because it is simply a checking method whose job is to assert that there isn't any flaws in the logic of the other methods. It never actually changes the representation of the TVBool when being accessed by different classes because if the normalize method retains the sign of the field state even if the technical value of the field is changed. not() is implemented correctly because it never actually changes the value of the field state. It creates a new object, sets the state of that object, and returns that object. It never alters the state of the original object.
+
+3. The hashCode() method is incorrect because if two TVBools are equal, they need to have the same hash code. The given implementation does not have this property. A correct implementation is provided below:
+
+@Override
+public int hashCode() {
+	return Integer.signum(state);
+}
+
+An implementation of equals() is provided below:
+
+@Override
+public boolean equals(Object o) {
+	if (Integer.signum(state) == Integer.signum(o.state)) {
+		return true;
+	} else {
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/Controller.java b/src/main/java/gui/Controller.java
new file mode 100644
index 0000000..5e2fb56
--- /dev/null
+++ b/src/main/java/gui/Controller.java
@@ -0,0 +1,434 @@
+package gui;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Optional;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import ast.Program;
+import javafx.animation.KeyFrame;
+import javafx.animation.Timeline;
+import javafx.beans.value.ChangeListener;
+import javafx.beans.value.ObservableValue;
+import javafx.event.ActionEvent;
+import javafx.event.EventHandler;
+import javafx.fxml.FXML;
+import javafx.scene.canvas.Canvas;
+import javafx.scene.control.Alert;
+import javafx.scene.control.Alert.AlertType;
+import javafx.scene.control.Button;
+import javafx.scene.control.Label;
+import javafx.scene.control.MenuItem;
+import javafx.scene.control.RadioButton;
+import javafx.scene.control.ScrollPane;
+import javafx.scene.control.Slider;
+import javafx.scene.control.TextArea;
+import javafx.scene.control.TextField;
+import javafx.scene.control.TextInputDialog;
+import javafx.scene.control.ToggleGroup;
+import javafx.scene.input.MouseEvent;
+import javafx.scene.input.ScrollEvent;
+import javafx.scene.text.Text;
+import javafx.stage.FileChooser;
+import javafx.stage.Popup;
+import javafx.util.Duration;
+import simulation.SimpleCritter;
+
+/**
+ * This class handles user inputs and sends information to the world model and
+ * world view to update their states accordingly.
+ */
+public class Controller {
+	@FXML
+	private MenuItem help;
+	@FXML
+	private MenuItem close;
+
+	@FXML
+	private Text columnText;
+	@FXML
+	private Text rowText;
+	@FXML
+	private Text memSizeText;
+	@FXML
+	private Text speciesText;
+	@FXML
+	private Text defenseText;
+	@FXML
+	private Text offenseText;
+	@FXML
+	private Text energyText;
+	@FXML
+	private Text passText;
+	@FXML
+	private Text tagText;
+	@FXML
+	private Text postureText;
+	@FXML
+	private Text sizeText;
+	@FXML
+	private TextArea lastRuleDisplay;
+	@FXML
+	private Button displayProgram;
+	
+	@FXML
+	private Button newWorld;
+	@FXML
+	private Button loadWorld;
+	@FXML
+	private Button loadCritterFile;
+	@FXML
+	private ToggleGroup LoadChoice;
+	@FXML
+	private RadioButton chkRand;
+	@FXML
+	private RadioButton chkSpecify;
+	@FXML
+	private TextField numCritters;
+	@FXML
+	private Button stepForward;
+	@FXML
+	private Button run;
+	@FXML
+	private Button pause;
+	@FXML
+	private Button reset;
+	@FXML
+	private Slider simulationSpeed;
+
+	@FXML
+	private ScrollPane scroll;
+	@FXML
+	private Canvas c;
+	@FXML
+	private Label crittersAlive;
+	@FXML
+	private Label stepsTaken;
+
+	private Timeline timeline;
+	/** The model that contains the world state. */
+	private WorldModel model;
+	/** Controls the hex grid. */
+	private WorldMap map;
+
+	private double mousePanPressedX;
+	private double mousePanPressedY;
+	
+	/** The rate at which the simulation is run. */
+	private long simulationRate;
+	/** The executor that is used to step the world periodically. */
+	private ScheduledExecutorService executor;
+
+	@FXML
+	public void initialize() {
+		model = new WorldModel();
+		simulationRate = 30;
+		
+		newWorld.setDisable(false);
+		loadWorld.setDisable(false);
+		loadCritterFile.setDisable(true);
+		chkRand.setDisable(true);
+		chkSpecify.setDisable(true);
+		numCritters.setDisable(true);
+		stepForward.setDisable(true);
+		run.setDisable(true);
+		pause.setDisable(true);
+		reset.setDisable(true);
+		simulationSpeed.setDisable(true);
+
+		c.getGraphicsContext2D().clearRect(0, 0, c.getWidth(), c.getHeight());
+		c.setDisable(true);
+		c.setVisible(false);
+
+		c.heightProperty().bind(scroll.heightProperty());
+		c.widthProperty().bind(scroll.widthProperty());
+		
+		simulationSpeed.valueProperty().addListener(new ChangeListener<Number>() {
+            public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
+                        simulationRate = new_val.longValue();
+                }
+            });
+	}
+
+	@FXML
+	private void handleNewWorldPressed(MouseEvent me) {
+		model.createNewWorld();
+		map = new WorldMap(c, model);
+		newWorld.setDisable(true);
+		loadWorld.setDisable(true);
+		chkRand.setDisable(false);
+		chkSpecify.setDisable(false);
+		stepForward.setDisable(false);
+		run.setDisable(false);
+		reset.setDisable(false);
+		simulationSpeed.setDisable(false);
+		c.setDisable(false);
+		c.setVisible(true);
+
+		map.draw();
+	}
+
+	@FXML
+	private void handleLoadWorldPressed(MouseEvent me) throws FileNotFoundException, IllegalArgumentException {
+		FileChooser fc = new FileChooser();
+		fc.setTitle("Choose World File");
+		File worldFile = fc.showOpenDialog(new Popup());
+		try {
+			model.loadWorld(worldFile);
+		} catch (FileNotFoundException f) {
+			Alert a = new Alert(AlertType.ERROR, "Your file could not be read. Please try again.");
+			a.setTitle("Invalid File");
+			a.showAndWait();
+			return;
+		}
+		map = new WorldMap(c, model);
+
+		newWorld.setDisable(true);
+		loadWorld.setDisable(true);
+		chkRand.setDisable(false);
+		chkSpecify.setDisable(false);
+		stepForward.setDisable(false);
+		run.setDisable(false);
+		reset.setDisable(false);
+		simulationSpeed.setDisable(false);
+		c.setDisable(false);
+		c.setVisible(true);
+
+		map.draw();
+	}
+
+	@FXML
+	private void handleChkRandom(ActionEvent ae) {
+		numCritters.setDisable(false);
+		loadCritterFile.setDisable(false);
+	}
+
+	@FXML
+	private void handleChkSpecify(ActionEvent ae) {
+		numCritters.setDisable(true);
+		loadCritterFile.setDisable(false);
+	}
+
+	@FXML
+	private void handleLoadCritters(MouseEvent me) {
+		FileChooser fc = new FileChooser();
+		fc.setTitle("Choose Critter File");
+		File critterFile = fc.showOpenDialog(new Popup());
+		
+		RadioButton choice = (RadioButton) LoadChoice.getSelectedToggle();
+		if(choice == chkRand)
+		{
+			try
+			{
+				int n = Integer.parseInt(numCritters.getText());
+				model.loadRandomCritters(critterFile, n);
+			}
+			catch (NumberFormatException e)
+			{
+				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid number of critters to load in.");
+				a.setTitle("Invalid Number");
+				a.showAndWait();
+				return;
+			}
+		}
+		else
+		{	
+			TextInputDialog dialog = new TextInputDialog();
+			dialog.setTitle("Choose Hex");
+			dialog.setHeaderText("Enter \"[columns] [rows]\".");
+			Optional<String> result = dialog.showAndWait();
+			
+			try
+			{
+				result.ifPresent(location -> 
+				{
+					String col = result.get().split(" ")[0];
+					String row = result.get().split(" ")[1];
+					int c = Integer.parseInt(col);
+					int r = Integer.parseInt(row);
+					model.loadCritterAtLocation(critterFile, c, r);
+				});
+			}
+			catch (Exception e)
+			{
+				Alert a = new Alert(AlertType.ERROR, "Make sure you've inputed a valid location");
+				a.setTitle("Invalid Location");
+				a.showAndWait();
+				return;
+			}
+		}
+		
+		map.draw();
+	}
+
+	@FXML
+	private void handleStep(MouseEvent me) {
+		model.advanceTime();
+		map.draw();
+		crittersAlive.setText("Critters Alive: " + model.numCritters);
+		stepsTaken.setText("Time: " + model.time);
+	}
+
+	@FXML
+	private void handleRunPressed(MouseEvent me) {
+		if(simulationRate == 0)
+			return;
+		
+		Thread worldUpdateThread = new Thread(new Runnable()
+		{
+			@Override
+			public void run()
+			{
+				model.advanceTime();
+			}
+		});
+		worldUpdateThread.setDaemon(true);
+		
+		executor = Executors.newSingleThreadScheduledExecutor();
+		executor.scheduleAtFixedRate(worldUpdateThread, 0, 1000 / simulationRate, TimeUnit.MILLISECONDS);
+		
+		timeline = new Timeline(new KeyFrame(Duration.millis(1000 / 30), new EventHandler<ActionEvent>() {
+		
+			@Override
+			public void handle(ActionEvent ae)
+			{ 
+				map.draw();
+				crittersAlive.setText("Critters Alive: " + model.numCritters);
+				stepsTaken.setText("Time: " + model.time);
+			}
+		}));
+
+		timeline.setCycleCount(Timeline.INDEFINITE);
+		timeline.play();
+
+		newWorld.setDisable(true);
+		loadWorld.setDisable(true);
+		loadCritterFile.setDisable(true);
+		chkRand.setDisable(true);
+		chkSpecify.setDisable(true);
+		numCritters.setDisable(true);
+		stepForward.setDisable(true);
+		run.setDisable(true);
+		reset.setDisable(true);
+		simulationSpeed.setDisable(true);
+
+		pause.setDisable(false);
+	}
+
+	@FXML
+	private void handlePauseClicked(MouseEvent me) {
+		executor.shutdownNow();
+
+		newWorld.setDisable(false);
+		loadWorld.setDisable(false);
+		loadCritterFile.setDisable(false);
+		chkRand.setDisable(false);
+		chkSpecify.setDisable(false);
+		numCritters.setDisable(false);
+		stepForward.setDisable(false);
+		run.setDisable(false);
+		reset.setDisable(false);
+		simulationSpeed.setDisable(false);
+
+		timeline.stop();
+		pause.setDisable(true);
+	}
+
+	@FXML
+	private void handleMapClicked(MouseEvent me) {
+		if (!me.isPrimaryButtonDown()) {
+			mousePanPressedX = me.getScreenX();
+			mousePanPressedY = me.getScreenY();
+		}
+		else
+		{
+			double xCoordinateSelected = me.getSceneX();
+			double yCoordinateSelected = me.getSceneY();
+			int[] hexCoordinatesSelected = new int[2];
+			boolean shouldUpdateRowColumn = map.select(xCoordinateSelected, yCoordinateSelected);
+			hexCoordinatesSelected = map.getSelectedHex();
+			if(shouldUpdateRowColumn)
+			{
+				rowText.setText(String.valueOf(hexCoordinatesSelected[0]));
+				columnText.setText(String.valueOf(hexCoordinatesSelected[1]));
+				if (model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]) != null)
+				{
+					SimpleCritter critter = model.getCritter(hexCoordinatesSelected[0], hexCoordinatesSelected[1]);
+					memSizeText.setText(String.valueOf(critter.getMemLength()));
+					speciesText.setText(critter.getName());
+					int[] critterMemoryCopy = new int[critter.getMemLength()];
+					critterMemoryCopy = critter.getMemoryCopy();
+					defenseText.setText(String.valueOf(critterMemoryCopy[1]));
+					offenseText.setText(String.valueOf(critterMemoryCopy[2]));
+					sizeText.setText(String.valueOf(critterMemoryCopy[3]));
+					energyText.setText(String.valueOf(critterMemoryCopy[4]));
+					passText.setText(String.valueOf(critterMemoryCopy[5]));
+					tagText.setText(String.valueOf(critterMemoryCopy[6]));
+					postureText.setText(String.valueOf(critterMemoryCopy[7]));
+					lastRuleDisplay.setText(critter.getLastRule());
+				}
+				else
+				{
+					memSizeText.setText("");
+					speciesText.setText("");
+					defenseText.setText("");
+					offenseText.setText("");
+					sizeText.setText("");
+					energyText.setText("");
+					passText.setText("");
+					tagText.setText("");
+					postureText.setText("");
+				}
+			}
+		}
+	}
+
+	@FXML
+	private void handleResetClicked(MouseEvent me) {
+		if (executor != null)
+			executor.shutdownNow();
+		if (timeline != null)
+			timeline.stop();
+		initialize();
+	}
+
+	@FXML
+	private void handleMapScroll(ScrollEvent se) {
+		if (se.getDeltaY() > 0)
+			map.zoom(true);
+		else
+			map.zoom(false);
+	}
+
+	@FXML
+	private void handleMapDrag(MouseEvent me) {
+		if (!me.isPrimaryButtonDown()) {
+			map.drag(me.getScreenX() - mousePanPressedX, me.getScreenY() - mousePanPressedY);
+		}
+	}
+
+	@FXML
+	private void close(ActionEvent ae) {
+		if (executor != null)
+			executor.shutdownNow();
+		if (timeline != null)
+			timeline.stop();
+		System.exit(0);
+	}
+	
+	@FXML
+	private void handleDisplayProgram(MouseEvent me) {
+		int[] hexCoordinates = new int[2];
+		hexCoordinates = map.getSelectedHex();
+		if (model.getCritter(hexCoordinates[0], hexCoordinates[1]) != null) {
+			SimpleCritter critter = model.getCritter(hexCoordinates[0], hexCoordinates[1]);
+			Program critterProgram = critter.getProgram();
+			String critterProgramString = critterProgram.toString();
+			Alert alert = new Alert(AlertType.INFORMATION, critterProgramString);
+			alert.setHeaderText("Critter Program");
+			alert.showAndWait();
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/Main.java b/src/main/java/gui/Main.java
new file mode 100644
index 0000000..fd11749
--- /dev/null
+++ b/src/main/java/gui/Main.java
@@ -0,0 +1,46 @@
+package gui;
+
+import java.net.URL;
+
+import javafx.application.Application;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.stage.Stage;
+
+public class Main extends Application {
+
+	public static void main(String[] args) {
+		launch(args);
+	}
+
+	@Override
+	public void start(Stage stage) {
+		stage.setMinHeight(800);
+		stage.setMinWidth(1000);
+
+		try {
+			URL r = getClass().getResource("gui.fxml");
+			if (r == null)
+				throw new Exception("No FXML resource found.");
+			Scene scene = new Scene(FXMLLoader.load(r));
+			stage.setTitle("CRITTERWORLD!");
+			stage.setScene(scene);
+			stage.sizeToScene();
+			stage.show();
+		} catch (Exception e) {
+			
+		}
+	}
+
+}
+
+// TODO fix zooming + panning position
+// TODO fix hex selection upon zoom
+// TODO fix weird lagginess in panning
+// TODO black universe, grey hex grid, grey fully filled hexes as rocks, neon
+// circles for food (maybe yellow), neon isosceles triangles for critters (maybe
+// green + species variation so different shades)
+// TODO tableview for hexinfo
+// TODO when unselecting a hex, kill the critter info in corner
+// TODO figure out what to do when selecting a rock or food
+// TODO change title of critter program message box
\ No newline at end of file
diff --git a/src/main/java/gui/ResizableCanvas.java b/src/main/java/gui/ResizableCanvas.java
new file mode 100644
index 0000000..4a29646
--- /dev/null
+++ b/src/main/java/gui/ResizableCanvas.java
@@ -0,0 +1,12 @@
+package gui;
+
+import javafx.scene.canvas.Canvas;
+
+public class ResizableCanvas extends Canvas
+{
+	@Override
+	public boolean isResizable()
+	{
+		return true;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/WorldMap.java b/src/main/java/gui/WorldMap.java
new file mode 100644
index 0000000..28cbfb9
--- /dev/null
+++ b/src/main/java/gui/WorldMap.java
@@ -0,0 +1,508 @@
+package gui;
+
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import javafx.scene.canvas.Canvas;
+import javafx.scene.canvas.GraphicsContext;
+import javafx.scene.image.Image;
+import javafx.scene.paint.Color;
+import javafx.scene.text.Font;
+import javafx.scene.text.TextAlignment;
+import simulation.Food;
+import simulation.Hex;
+import simulation.Rock;
+import simulation.SimpleCritter;
+import simulation.WorldObject;
+
+public class WorldMap {
+	private WorldModel model;
+	private GraphicsContext gc;
+	private Canvas canvas;
+	private int[] selectedHex;
+
+	/**
+	 * The minimum acceptable hex sidelength (zoom will not allow the user to zoom
+	 * in any further.
+	 */
+	private final int MIN_SIDELENGTH = 20;
+
+	/**
+	 * The maximum acceptable hex sidelength (zoom will not allow the user to zoom
+	 * out any further.
+	 */
+	private final int MAX_SIDELENGTH = 60;
+
+	/** How much each scroll tick zooms the hex grid by. */
+	private final double ZOOM_FACTOR = 3.0;
+
+	/** The background color of the canvas. */
+	private final Color BACKGROUND_COLOR = Color.DIMGRAY;
+	/** The outline color of hexagons. */
+	private final Color HEX_COLOR = Color.LIGHTGRAY;
+	/** The color of a highlighted hex. */
+	private final Color HIGHLIGHT_COLOR = Color.rgb(176, 224, 230, 0.3);
+
+	private double height;
+	private double width;
+	private int rows;
+	private int columns;
+
+	/** The sideLength of a hexagon. Used as a measure of scale. */
+	private double sideLength;
+
+	// these four variables are used to help drawing methods
+	private int column_drawing_marker;
+	private int row_drawing_marker;
+	private double x_position_marker;
+	private double y_position_marker;
+
+	/**
+	 * Marks the rectangular x coordinate of the origin (the (0, 0) hex coordinate).
+	 */
+	private double origin_x;
+
+	/**
+	 * Marks the rectangular y coordinate of the origin (the (0, 0) hex coordinate).
+	 */
+	private double origin_y;
+
+	private HashMap<String, Image> pictures;
+
+	/**
+	 * Creates a new world map.
+	 * 
+	 * @param can
+	 *            The Canvas to draw on
+	 * @param wm
+	 *            The WorldModel to work off of
+	 */
+	public WorldMap(Canvas can, WorldModel wm) {
+		gc = can.getGraphicsContext2D();
+		canvas = can;
+		model = wm;
+		height = canvas.getHeight();
+		width = canvas.getWidth();
+
+		columns = wm.getColumns();
+		rows = wm.getRows();
+
+		column_drawing_marker = columns;
+		row_drawing_marker = rows;
+		row_drawing_marker -= column_drawing_marker / 2;
+		sideLength = 30;
+
+		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
+				+ (sideLength / 2);
+		y_position_marker = (((double) height / 2)
+				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
+				+ (Math.sqrt(3) * (sideLength / 2));
+
+		initializeImages();
+	}
+
+	/**
+	 * Reads the images needed to display world objects and stores them in a
+	 * hashmap.
+	 */
+	private void initializeImages() {
+		pictures = new HashMap<String, Image>();
+		InputStream is1 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_0.png");
+		InputStream is2 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_60.png");
+		InputStream is3 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_120.png");
+		InputStream is4 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_180.png");
+		InputStream is5 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_240.png");
+		InputStream is6 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/critter_300.png");
+		InputStream is7 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/rock.png");
+		InputStream is8 = WorldMap.class.getClassLoader().getResourceAsStream("gui/images/apple.png");
+		// TODO add general critter image
+
+		Image i1 = new Image(is1);
+		Image i2 = new Image(is2);
+		Image i3 = new Image(is3);
+		Image i4 = new Image(is4);
+		Image i5 = new Image(is5);
+		Image i6 = new Image(is6);
+		Image i7 = new Image(is7);
+		Image i8 = new Image(is8);
+
+		pictures.put("CRITTER_NORTH", i1);
+		pictures.put("CRITTER_NORTHEAST", i2);
+		pictures.put("CRITTER_SOUTHEAST", i3);
+		pictures.put("CRITTER_SOUTH", i4);
+		pictures.put("CRITTER_SOUTHWEST", i5);
+		pictures.put("CRITTER_NORTHWEST", i6);
+		pictures.put("ROCK", i7);
+		pictures.put("FOOD", i8);
+	}
+
+	/**
+	 * Determines whether or not a hex with column index {@code c} and row index
+	 * {@code r} is on the world grid.
+	 */
+	private boolean isValidHex(int c, int r) {
+		if (c < 0 || r < 0)
+			return false;
+		else if (c >= columns || r >= rows)
+			return false;
+		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
+			return false;
+		return true;
+	}
+
+	/** Redraws the world grid. */
+	public void draw() {
+		// resets the world grid
+		height = canvas.getHeight();
+		width = canvas.getWidth();
+		gc.clearRect(0, 0, width, height);
+		gc.setFill(BACKGROUND_COLOR);
+		gc.fillRect(0, 0, width, height);
+
+		// draws the hexagons and sets the origin
+		double hexMarkerX = x_position_marker;
+		double hexMarkerY = y_position_marker;
+		for (int i = 0; i < column_drawing_marker; i++) {
+			if (i % 2 == 0 && column_drawing_marker % 2 == 0) {
+				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+			}
+			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+				hexMarkerY += Math.sqrt(3) * (sideLength / 2);
+				row_drawing_marker--;
+			}
+
+			for (int j = 0; j < row_drawing_marker; j++) {
+				drawHex(hexMarkerX, hexMarkerY);
+				hexMarkerY += (Math.sqrt(3) * (sideLength));
+			}
+
+			hexMarkerX += sideLength + (sideLength / 2);
+			hexMarkerY = y_position_marker;
+			if (i % 2 == 1 && column_drawing_marker % 2 == 1) {
+				row_drawing_marker++;
+			}
+		}
+		hexMarkerX = x_position_marker;
+		origin_x = hexMarkerX;
+		origin_y = hexMarkerY + (sideLength * (Math.sqrt(3)) * row_drawing_marker) - (Math.sqrt(3) * (sideLength / 2));
+		if (column_drawing_marker % 2 == 0)
+			origin_y += (sideLength / 2) * (Math.sqrt(3));
+		origin_y -= sideLength / 2 * Math.sqrt(3); // manual override of sujith's calculations
+
+		// draws the world objects in
+		drawObjects();
+
+		if (selectedHex != null) {
+			double[] highlightCoordinates = hexToCartesian(selectedHex);
+			highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
+		}
+	}
+
+	/** Used to update the grid and draw updates after each time step. */
+	public void updateGrid() {
+
+	}
+
+	/** Draws the world objects onto the grid. */
+	private void drawObjects() {
+		for (Map.Entry<SimpleCritter, Hex> entry : model.getCritterMap()) {
+			int c = entry.getValue().getColumnIndex();
+			int r = entry.getValue().getRowIndex();
+			drawCritter(entry.getKey(), c, r);
+		}
+
+		for (Map.Entry<WorldObject, Hex> entry : model.getObjectMap()) {
+			int c = entry.getValue().getColumnIndex();
+			int r = entry.getValue().getRowIndex();
+			drawWorldObject(entry.getKey(), c, r);
+		}
+	}
+
+	/**
+	 * Draws one critter onto the world grid.
+	 * 
+	 * @param sc
+	 * @param c
+	 * @param r
+	 */
+	private void drawCritter(SimpleCritter sc, int c, int r) {
+		if (!isValidHex(c, r))
+			return;
+
+		// convert to Cartesian coordinates
+		int hexCoordinates[] = new int[] { c, r };
+		double cartX = hexToCartesian(hexCoordinates)[0];
+		double cartY = hexToCartesian(hexCoordinates)[1];
+
+		if (sc == null) {
+			return;
+		}
+
+		int critterSize = sc.size();
+		double size = 0.9 * sideLength * (50 + critterSize / 2) / 100; // TODO this should vary based on critterSize
+
+		double[] xPoints = new double[3];
+		double[] yPoints = new double[3];
+
+		// determine critter orientation
+		int dir = sc.getOrientation();
+		switch (dir) {
+		case 0:
+			xPoints[0] = 0;
+			xPoints[1] = -size / 2;
+			xPoints[2] = size / 2;
+			yPoints[0] = -size / 2 * Math.sqrt(3);
+			yPoints[1] = size / 2 * Math.sqrt(3);
+			yPoints[2] = size / 2 * Math.sqrt(3);
+			break;
+		case 1:
+			xPoints[0] = 3 * size / 4;
+			xPoints[1] = -size;
+			xPoints[2] = -size / 2;
+			yPoints[0] = -size * Math.sqrt(3) / 4;
+			yPoints[1] = 0;
+			yPoints[2] = size * Math.sqrt(3) / 2;
+			break;
+		case 2:
+			xPoints[0] = 3 * size / 4;
+			xPoints[1] = -size / 2;
+			xPoints[2] = -size;
+			yPoints[0] = size * Math.sqrt(3) / 4;
+			yPoints[1] = -size * Math.sqrt(3) / 2;
+			yPoints[2] = 0;
+			break;
+		case 3:
+			xPoints[0] = 0;
+			xPoints[1] = size / 2;
+			xPoints[2] = -size / 2;
+			yPoints[0] = size / 2 * Math.sqrt(3);
+			yPoints[1] = -size / 2 * Math.sqrt(3);
+			yPoints[2] = -size / 2 * Math.sqrt(3);
+			break;
+		case 4:
+			xPoints[0] = -3 * size / 4;
+			xPoints[1] = size;
+			xPoints[2] = size / 2;
+			yPoints[0] = size * Math.sqrt(3) / 4;
+			yPoints[1] = 0;
+			yPoints[2] = -size * Math.sqrt(3) / 2;
+			break;
+		case 5:
+			xPoints[0] = -3 * size / 4;
+			xPoints[1] = size / 2;
+			xPoints[2] = size;
+			yPoints[0] = -size * Math.sqrt(3) / 4;
+			yPoints[1] = size * Math.sqrt(3) / 2;
+			yPoints[2] = 0;
+			break;
+		default:
+			return;
+		}
+
+		// translate points to current hex
+		for (int i = 0; i < 3; i++) {
+			xPoints[i] += cartX;
+		}
+		for (int i = 0; i < 3; i++) {
+			yPoints[i] += cartY;
+		}
+
+		// get critter color
+		String species = sc.getName();
+		int hash = species.hashCode();
+		Color color = new Color(0, 1, 0, 1);
+		System.out.println(hash);
+		
+		// draw critter
+		gc.setStroke(Color.LIME);
+		gc.strokePolygon(xPoints, yPoints, 3);
+	}
+
+	/**
+	 * Draws one non-critter object onto the world grid.
+	 * 
+	 * @param wo
+	 * @param c
+	 * @param r
+	 */
+	private void drawWorldObject(WorldObject wo, int c, int r) {
+		if (!isValidHex(c, r))
+			return;
+
+		int hexCoordinates[] = new int[] { c, r };
+		double cartX = hexToCartesian(hexCoordinates)[0];
+		double cartY = hexToCartesian(hexCoordinates)[1];
+
+		if (wo instanceof Rock) {
+			double size = 0.9 * sideLength;
+			gc.setFill(Color.BROWN);
+			gc.strokeRect(cartX - size / 2, cartY - size / 2, size, size);
+		}
+
+		else if (wo instanceof Food) {
+			int calories = ((Food) wo).getCalories();
+			double size = 0.9 * sideLength;
+			gc.setStroke(Color.RED);
+			gc.strokeOval(cartX - size / 2, cartY - size / 2, size, size);
+			gc.setTextAlign(TextAlignment.CENTER);
+			gc.setFont(new Font(8));
+			gc.strokeText(String.valueOf(calories), cartX, cartY);
+		}
+	}
+
+	/**
+	 * 
+	 * @param centerX
+	 * @param centerY
+	 */
+	private void drawHex(double centerX, double centerY) {
+		gc.setStroke(HEX_COLOR);
+		gc.strokePolygon(
+				new double[] { centerX + sideLength, centerX + (sideLength / 2), centerX - (sideLength / 2),
+						centerX - sideLength, centerX - (sideLength / 2), centerX + (sideLength / 2) },
+				new double[] { centerY, centerY - (Math.sqrt(3) * (sideLength / 2)),
+						centerY - (Math.sqrt(3) * (sideLength / 2)), centerY,
+						centerY + (Math.sqrt(3) * (sideLength / 2)), centerY + (Math.sqrt(3) * (sideLength / 2)) },
+				6);
+	}
+
+	/**
+	 * 
+	 * @param zoomIn
+	 */
+	public void zoom(boolean zoomIn) {
+		if (zoomIn) {
+			sideLength += ZOOM_FACTOR;
+			if (sideLength >= MAX_SIDELENGTH)
+				sideLength = MAX_SIDELENGTH;
+		} else {
+			sideLength -= ZOOM_FACTOR;
+			if (sideLength <= MIN_SIDELENGTH)
+				sideLength = MIN_SIDELENGTH;
+		}
+		x_position_marker = ((double) width / 2) - ((((double) column_drawing_marker / 2) / 2) * 3 * sideLength)
+				+ (sideLength / 2);
+		y_position_marker = (((double) height / 2)
+				- (((double) row_drawing_marker / 2) * (Math.sqrt(3) * (sideLength))))
+				+ (Math.sqrt(3) * (sideLength / 2));
+		draw();
+	}
+
+	/**
+	 * highlightHex highlights the hex that is currently selected 
+	 * @param x xCoordinate of the spot that the user clicks
+	 * @param y yCooridnate of the spot that the user clicks
+	 */
+	public void highlightHex(double x, double y) {
+		int[] hexCoordinates = closestHex(x, y);
+		if (!isValidHex(hexCoordinates[0], hexCoordinates[1])) {
+			return;
+		}
+		double a = (double) sideLength; // for visual clarity in the calculations
+		double m = a * Math.sqrt(3) / 2.0; // for visual clarity in the calculations
+
+		double[] xPoints = { x + a, x + a / 2, x - a / 2, x - a, x - a / 2, x + a / 2 };
+		double[] yPoints = { y, y - m, y - m, y, y + m, y + m };
+
+		gc.setFill(HIGHLIGHT_COLOR);
+		gc.fillPolygon(xPoints, yPoints, 6);
+	}
+
+	/**
+	 * drag implements panning
+	 * @param deltaX 
+	 * @param deltaY
+	 */
+	public void drag(double deltaX, double deltaY) {
+		x_position_marker += deltaX * 0.05;
+		y_position_marker += deltaY * 0.05;
+		if (x_position_marker - sideLength > width)
+			x_position_marker = width - sideLength;
+		if ((((3 * sideLength) / 2) * column_drawing_marker + x_position_marker)< 0){
+			x_position_marker = (2*sideLength) - (((3 * sideLength) / 2) * column_drawing_marker);
+		}
+		if (y_position_marker > height)
+			y_position_marker = height - Math.sqrt(3)*sideLength;
+		if ((y_position_marker + Math.sqrt(3)*sideLength*row_drawing_marker) < 0)
+			y_position_marker = Math.sqrt(3)*sideLength-Math.sqrt(3)*sideLength*row_drawing_marker;
+		gc.clearRect(0, 0, width, height);
+		draw();
+	}
+
+	public boolean select(double xCoordinate, double yCoordinate) {
+		boolean returnValue;
+		int[] closestHexCoordinates = closestHex(xCoordinate, yCoordinate);
+		if (selectedHex != null && Arrays.equals(selectedHex, closestHexCoordinates)) {
+			selectedHex = null;
+			returnValue = false;
+		} else {
+			selectedHex = closestHexCoordinates;
+			returnValue = true;
+		}
+		double[] highlightCoordinates = hexToCartesian(closestHexCoordinates);
+		highlightHex(highlightCoordinates[0], highlightCoordinates[1]);
+
+		draw();
+		return returnValue;
+	}
+
+	/**
+	 * A method that, given a set of rectangular canvas coordinates, returns the
+	 * coordinates of the hex it is located in.
+	 * 
+	 * @param xCoordinate
+	 * @param yCoordinate
+	 * @return An {@code int} array containing the (r, c) coordinates of the closest
+	 *         hex.
+	 */
+	public int[] closestHex(double xCoordinate, double yCoordinate) {
+		// determines the possible hexes that the point could be in
+		int possibleColumnOne = (int) Math.ceil(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
+		int possibleColumnTwo = (int) Math.floor(2.0 * (xCoordinate - origin_x) / (3.0 * sideLength));
+		int possibleRowOne = (int) Math.ceil((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
+				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
+		int possibleRowTwo = (int) Math.floor((-yCoordinate + origin_y) / (Math.sqrt(3.0) * sideLength)
+				+ ((xCoordinate - origin_x) / (3.0 * sideLength)));
+
+		int[][] possibleCoordinates = new int[4][2];
+		possibleCoordinates[0] = new int[] { possibleColumnOne, possibleRowOne };
+		possibleCoordinates[1] = new int[] { possibleColumnOne, possibleRowTwo };
+		possibleCoordinates[2] = new int[] { possibleColumnTwo, possibleRowOne };
+		possibleCoordinates[3] = new int[] { possibleColumnTwo, possibleRowTwo };
+
+		double distanceSquared = Integer.MAX_VALUE;
+		int returnIndex = 0;
+		for (int i = 0; i < 4; i++) {
+			//System.out.println("Option #" + i + ": " + possibleCoordinates[i][0] + " " + possibleCoordinates[i][1]);
+			double tempArray[] = hexToCartesian(possibleCoordinates[i]);
+			double tempDistanceSquared = Math.pow(xCoordinate - tempArray[0], 2)
+					+ Math.pow(yCoordinate - tempArray[1], 2);
+			if (tempDistanceSquared < distanceSquared) {
+				distanceSquared = tempDistanceSquared;
+				returnIndex = i;
+			}
+		}
+		//System.out.println(possibleCoordinates[returnIndex][0] + " " + possibleCoordinates[returnIndex][1]);
+		//System.out.println("\n");
+		return possibleCoordinates[returnIndex];
+	}
+
+	/**
+	 * A method that converts a hex coordinate pair and gives the hex coordinates of
+	 * 
+	 * @param hexCoordinates
+	 * @return
+	 */
+	private double[] hexToCartesian(int[] hexCoordinates) {
+		double x_coordinate = ((3 * sideLength) / 2) * hexCoordinates[0] + origin_x;
+		double y_coordinate = ((Math.sqrt(3) * sideLength) / 2) * hexCoordinates[0]
+				- sideLength * Math.sqrt(3) * hexCoordinates[1] + origin_y;
+		return new double[] { x_coordinate, y_coordinate };
+	}
+
+	public int[] getSelectedHex() {
+		return selectedHex;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/WorldModel.java b/src/main/java/gui/WorldModel.java
new file mode 100644
index 0000000..ce05af3
--- /dev/null
+++ b/src/main/java/gui/WorldModel.java
@@ -0,0 +1,90 @@
+package gui;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Map;
+import java.util.Set;
+
+import simulation.SimpleCritter;
+import simulation.SimpleWorld;
+import simulation.World;
+import simulation.WorldObject;
+import simulation.Hex;
+
+public class WorldModel {
+	private SimpleWorld world;
+	int numCritters;
+	int time;
+
+	/** Creates a new blank world model. */
+	public WorldModel() {
+		numCritters = 0;
+		time = 0;
+	}
+
+	/** Creates a new random world. */
+	public void createNewWorld() {
+		world = new World();
+	}
+
+	/**
+	 * Loads in a world file.
+	 * 
+	 * @param worldfile
+	 * @throws FileNotFoundException
+	 *             if the file could not be found or is somehow invalid
+	 * @throws IllegalArgumentException
+	 *             if the constants.txt file could not be read
+	 */
+	public void loadWorld(File worldfile) throws FileNotFoundException, IllegalArgumentException {
+		world = new World(worldfile);
+	}
+
+	public boolean isReady() {
+		return world != null;
+	}
+
+	/** Returns the number of columns in the world. */
+	public int getColumns() {
+		return world.getColumns();
+	}
+
+	/** Returns the number of rows in the world. */
+	public int getRows() {
+		return world.getRows();
+	}
+
+	public synchronized int hexContent(int c, int r) {
+		return world.analyzeHex(c, r);
+	}
+
+	public synchronized SimpleCritter getCritter(int c, int r) {
+		return world.analyzeCritter(c, r);
+	}
+
+	public synchronized Set<Map.Entry<SimpleCritter, Hex>> getCritterMap() {
+		return world.getCritterMap();
+	}
+
+	public synchronized Set<Map.Entry<WorldObject, Hex>> getObjectMap() {
+		return world.getObjectMap();
+	}
+
+	/** Advances one time step. */
+	public synchronized void advanceTime() {
+		world.advanceOneTimeStep();
+		time++;
+		numCritters = world.numRemainingCritters();
+		//System.out.println(world.printGrid());
+	}
+
+	public synchronized void loadRandomCritters(File f, int n) {
+		world.loadCritters(f, n, -1);
+		numCritters = world.numRemainingCritters();
+	}
+	
+	public synchronized void loadCritterAtLocation(File f, int c, int r) {
+		world.loadCritterAtLocation(f, c, r);
+		numCritters = world.numRemainingCritters();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/gui/gui.fxml b/src/main/java/gui/gui.fxml
new file mode 100644
index 0000000..9937ccf
--- /dev/null
+++ b/src/main/java/gui/gui.fxml
@@ -0,0 +1,143 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.scene.canvas.Canvas?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.Label?>
+<?import javafx.scene.control.Menu?>
+<?import javafx.scene.control.MenuBar?>
+<?import javafx.scene.control.MenuItem?>
+<?import javafx.scene.control.RadioButton?>
+<?import javafx.scene.control.ScrollPane?>
+<?import javafx.scene.control.Slider?>
+<?import javafx.scene.control.SplitPane?>
+<?import javafx.scene.control.TextArea?>
+<?import javafx.scene.control.TextField?>
+<?import javafx.scene.control.TitledPane?>
+<?import javafx.scene.control.ToggleGroup?>
+<?import javafx.scene.layout.AnchorPane?>
+<?import javafx.scene.layout.HBox?>
+<?import javafx.scene.text.Font?>
+<?import javafx.scene.text.Text?>
+
+<AnchorPane prefHeight="900.0" prefWidth="1600.0" xmlns="http://javafx.com/javafx/9.0.1" xmlns:fx="http://javafx.com/fxml/1" fx:controller="gui.Controller">
+   <children>
+      <MenuBar fx:id="Menu" prefHeight="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+         <menus>
+            <Menu mnemonicParsing="false" text="File">
+               <items>
+                  <MenuItem fx:id="help" mnemonicParsing="false" text="Help" />
+                  <MenuItem fx:id="close" mnemonicParsing="false" onAction="#close" text="Close" />
+               </items>
+            </Menu>
+         </menus>
+      </MenuBar>
+      <HBox alignment="BOTTOM_LEFT" layoutY="774.0" prefHeight="25.0" AnchorPane.bottomAnchor="2.1316282072803006E-14" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0">
+         <children>
+            <SplitPane dividerPositions="0.5" prefHeight="26.0" style="-fx-background-color: lightgray;" HBox.hgrow="ALWAYS">
+              <items>
+                  <HBox alignment="CENTER" prefHeight="25.0" prefWidth="200.0">
+                     <children>
+                        <Label fx:id="crittersAlive" alignment="CENTER" text="Critters Alive: 0" />
+                     </children>
+                  </HBox>
+                  <HBox alignment="CENTER" prefHeight="100.0" prefWidth="200.0">
+                     <children>
+                        <Label fx:id="stepsTaken" text="Time: 0" />
+                     </children>
+                  </HBox>
+              </items>
+            </SplitPane>
+         </children></HBox>
+      <AnchorPane layoutX="749.0" layoutY="25.0" prefHeight="775.0" prefWidth="250.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="25.0">
+         <children>
+            <TitledPane animated="false" layoutY="-3.0" minHeight="274.0" prefHeight="274.0" prefWidth="250.0" text="World Info" AnchorPane.bottomAnchor="510.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
+               <content>
+                  <ScrollPane fitToWidth="true" hbarPolicy="NEVER" prefWidth="248.0">
+                    <content>
+                      <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="333.0" prefWidth="248.0">
+                           <children>
+                              <Label layoutX="10.0" layoutY="16.0" prefHeight="10.0" text="Column" />
+                              <Label layoutX="110.0" layoutY="16.0" prefHeight="10.0" prefWidth="39.0" text="Row" />
+                              <Label layoutX="10.0" layoutY="37.0" prefHeight="21.0" prefWidth="69.0" text="Mem Size" />
+                              <Label layoutX="10.0" layoutY="59.0" prefHeight="10.0" prefWidth="60.0" text="Defense" />
+                              <Label layoutX="110.0" layoutY="59.0" prefHeight="10.0" prefWidth="57.0" text="Offense" />
+                              <Label layoutX="10.0" layoutY="80.0" prefHeight="10.0" prefWidth="55.0" text="Energy" />
+                              <Label layoutX="110.0" layoutY="80.0" prefHeight="10.0" prefWidth="35.0" text="Pass" />
+                              <Label layoutX="10.0" layoutY="99.0" prefHeight="10.0" prefWidth="35.0" text="Tag" />
+                              <Label layoutX="110.0" layoutY="99.0" prefHeight="10.0" prefWidth="54.0" text="Posture" />
+                              <Label layoutX="110.0" layoutY="37.0" text="Species" />
+                              <TextArea fx:id="lastRuleDisplay" layoutX="41.0" layoutY="120.0" prefHeight="150.0" prefWidth="167.0" />
+                              <Button fx:id="displayProgram" layoutX="60.0" layoutY="277.0" mnemonicParsing="false" onMouseClicked="#handleDisplayProgram" text="Display Program" />
+                              <Text fx:id="columnText" layoutX="70.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+                              <Text fx:id="rowText" layoutX="147.0" layoutY="32.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="27.0" />
+                              <Text fx:id="memSizeText" layoutX="81.0" layoutY="53.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="28.0" />
+                              <Text fx:id="speciesText" layoutX="170.0" layoutY="52.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="76.0" />
+                              <Text fx:id="defenseText" layoutX="70.0" layoutY="75.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+                              <Text fx:id="offenseText" layoutX="179.0" layoutY="74.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="37.0" />
+                              <Text fx:id="energyText" layoutX="65.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
+                              <Text fx:id="passText" layoutX="146.0" layoutY="96.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
+                              <Text fx:id="tagText" layoutX="39.0" layoutY="115.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="42.0" />
+                              <Text fx:id="postureText" layoutX="164.0" layoutY="114.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="48.0" />
+                              <Label layoutX="176.0" layoutY="16.0" text="Size" />
+                              <Text fx:id="sizeText" layoutX="208.0" layoutY="29.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="40.0" />
+                           </children></AnchorPane>
+                    </content>
+                  </ScrollPane>
+               </content>
+            </TitledPane>
+            <TitledPane animated="false" layoutY="300.0" minHeight="100.0" prefHeight="100.0" prefWidth="250.0" text="Create World" AnchorPane.bottomAnchor="410.0">
+               <content>
+                  <AnchorPane minHeight="0.0" minWidth="0.0" prefWidth="239.0">
+                     <children>
+                        <Button fx:id="newWorld" layoutX="33.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleNewWorldPressed" text="New World" />
+                        <Button fx:id="loadWorld" layoutX="136.0" layoutY="24.0" mnemonicParsing="false" onMouseClicked="#handleLoadWorldPressed" text="Load World" />
+                     </children>
+                  </AnchorPane>
+               </content>
+            </TitledPane>
+            <TitledPane animated="false" layoutY="400.0" minHeight="260.0" prefHeight="260.0" prefWidth="250.0" text="World Controls" AnchorPane.bottomAnchor="150.0">
+               <content>
+                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="0.0" prefWidth="249.0">
+                     <children>
+                        <Button fx:id="loadCritterFile" layoutX="14.0" layoutY="14.0" mnemonicParsing="false" onMousePressed="#handleLoadCritters" text="Load Critter File" />
+                        <RadioButton fx:id="chkRand" layoutX="24.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkRandom" text="Random hex">
+                           <toggleGroup>
+                              <ToggleGroup fx:id="LoadChoice" />
+                           </toggleGroup>
+                        </RadioButton>
+                        <RadioButton fx:id="chkSpecify" layoutX="143.0" layoutY="55.0" mnemonicParsing="false" onAction="#handleChkSpecify" text="Specify hex">
+                           <toggleGroup>
+                              <ToggleGroup fx:id="HexChoice" />
+                           </toggleGroup></RadioButton>
+                        <TextField fx:id="numCritters" layoutX="201.0" layoutY="15.0" prefHeight="23.0" prefWidth="30.0">
+                           <font>
+                              <Font size="10.0" />
+                           </font>
+                        </TextField>
+                        <Label layoutX="144.0" layoutY="18.0" text="Number" />
+                        <Button fx:id="stepForward" layoutX="83.0" layoutY="102.0" mnemonicParsing="false" onMousePressed="#handleStep" text="Step Forward" />
+                        <Button fx:id="run" layoutX="42.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handleRunPressed" text=" Run " />
+                        <Button fx:id="pause" layoutX="166.0" layoutY="149.0" mnemonicParsing="false" onMousePressed="#handlePauseClicked" text="Pause" />
+                        <Button fx:id="reset" layoutX="104.0" layoutY="190.0" mnemonicParsing="false" onMousePressed="#handleResetClicked" text="Reset" />
+                     </children>
+                  </AnchorPane>
+               </content>
+            </TitledPane>
+            <TitledPane animated="false" layoutY="660.0" minHeight="150.0" prefHeight="150.0" prefWidth="250.0" text="Simulation Controls" AnchorPane.bottomAnchor="0.0">
+               <content>
+                  <AnchorPane minHeight="0.0" minWidth="0.0" prefHeight="250.0" prefWidth="250.0">
+                     <children>
+                        <Slider fx:id="simulationSpeed" layoutX="24.0" layoutY="22.0" prefHeight="80.0" prefWidth="200.0" showTickLabels="true" showTickMarks="true" value="30.0" />
+                     </children>
+                  </AnchorPane>
+               </content>
+            </TitledPane>
+         </children>
+      </AnchorPane>
+      <ScrollPane fx:id="scroll" fitToHeight="true" fitToWidth="true" hbarPolicy="NEVER" layoutY="25.0" prefHeight="775.0" prefWidth="750.0" vbarPolicy="NEVER" AnchorPane.bottomAnchor="25.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="250.0" AnchorPane.topAnchor="25.0">
+         <content>
+            <Canvas fx:id="c" height="775.0" onMouseDragged="#handleMapDrag" onMousePressed="#handleMapClicked" onScroll="#handleMapScroll" width="750.0" />
+         </content>
+      </ScrollPane>
+   </children>
+</AnchorPane>
diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
index 18973a1..bd7e371 100644
--- a/src/main/java/interpret/InterpreterImpl.java
+++ b/src/main/java/interpret/InterpreterImpl.java
@@ -28,6 +28,7 @@ public class InterpreterImpl implements Interpreter
 	{
 		Action a = interpret(c.getProgram());
 		executeAction(a);
+		//System.out.println("AS");
 	}
 	
 	/**
diff --git a/src/main/java/main/ParseAndMutateApp.java b/src/main/java/main/ParseAndMutateApp.java
index e522bf9..474024a 100644
--- a/src/main/java/main/ParseAndMutateApp.java
+++ b/src/main/java/main/ParseAndMutateApp.java
@@ -4,64 +4,53 @@ import java.io.*;
 import ast.*;
 import parse.*;
 
-public class ParseAndMutateApp
-{
-
-	public static void main(String[] args) throws Exception
-	{
+public class ParseAndMutateApp {
+	public static void main(String[] args) throws Exception {
 		int n = 0;
 		String file;
-		try
-		{
-			if (args.length == 1)
-			{
+		try {
+			if (args.length == 1) {
 				file = args[0];
 				InputStream in = new FileInputStream(file);
-		        Reader r = new BufferedReader(new InputStreamReader(in));
-		        Parser p = ParserFactory.getParser();
-		        Program critter = p.parse(r);
-		        System.out.println(critter.toString());
-		        
-			}
-			else if (args.length == 3 && args[0].equals("--mutate"))
-			{
+				Reader r = new BufferedReader(new InputStreamReader(in));
+				Parser p = ParserFactory.getParser();
+				Program critter = p.parse(r);
+				System.out.println(critter.toString());
+
+			} else if (args.length == 3 && args[0].equals("--mutate")) {
 				n = parsePositive(args[1]);
 				file = args[2];
 				InputStream in = new FileInputStream(file);
-		        Reader r = new BufferedReader(new InputStreamReader(in));
-		        Parser p = ParserFactory.getParser();
-		        Program critter = p.parse(r);
-		        
-		        for(int i = 0; i < n; i++)
-		        	critter = critter.mutate();
-		        
-		        System.out.println(critter.toString());
-			}
-			else
-			{
+				Reader r = new BufferedReader(new InputStreamReader(in));
+				Parser p = ParserFactory.getParser();
+				Program critter = p.parse(r);
+
+				for (int i = 0; i < n; i++)
+					critter = critter.mutate();
+
+				System.out.println(critter.toString());
+			} else {
 				throw new IllegalArgumentException();
 			}
-			// TODO print program and mutations
-		}
-		catch (IllegalArgumentException | ArrayIndexOutOfBoundsException e)
-		{
+		} catch (IllegalArgumentException | ArrayIndexOutOfBoundsException e) {
 			System.out.println("Usage:\n" + "  <input_file>\n" + "  --mutate <n> <input_file");
-		}
-		catch (FileNotFoundException f)
-		{
+		} catch (FileNotFoundException f) {
 			System.out.println("File not found.");
 		}
 	}
 
 	/**
 	 * Parses {@code str} to an integer.
-	 * @param str - the string to parse
+	 * 
+	 * @param str
+	 *            - the string to parse
 	 * @return the integer represented by {@code str}
-	 * @throws NumberFormatException if {@code str} does not contain a parsable integer
-	 * @throws IllegalArgumentException if {@code str} represents a negative integer
+	 * @throws NumberFormatException
+	 *             if {@code str} does not contain a parsable integer
+	 * @throws IllegalArgumentException
+	 *             if {@code str} represents a negative integer
 	 */
-	public static int parsePositive(String str)
-	{
+	public static int parsePositive(String str) {
 		int n = Integer.parseInt(str);
 		if (n < 0)
 			throw new IllegalArgumentException();
diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
index 0d04293..a0cf4e4 100644
--- a/src/main/java/parse/ParserImpl.java
+++ b/src/main/java/parse/ParserImpl.java
@@ -341,8 +341,6 @@ class ParserImpl implements Parser {
 		return expression;
 	}
 
-	// TODO
-	// add more as necessary...
 
 	/**
 	 * Consumes a token of the expected type.
diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
index a58087f..067a9c8 100644
--- a/src/main/java/simulation/AbstractWorld.java
+++ b/src/main/java/simulation/AbstractWorld.java
@@ -44,18 +44,20 @@ public abstract class AbstractWorld implements SimpleWorld
 	public void advanceOneTimeStep()
 	{
 		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
+		System.out.println(clone.toString());
 		for(int i = 0; i < clone.size(); i++)
 		{
 			SimpleCritter sc = clone.get(i);
 			Interpreter im = new InterpreterImpl(sc, this);
 			im.simulateCritterTurn();
+			//System.out.println("AH");
 		}
 		
 		for(int i = 0; i < clone.size(); i++)
 		{
 			SimpleCritter sc = clone.get(i);
 			sc.toggleMatingPheromones(false);
-}
+		}
 		
 		timePassed++;
 	}
diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
index ac97405..d551c22 100644
--- a/src/main/java/simulation/SimpleWorld.java
+++ b/src/main/java/simulation/SimpleWorld.java
@@ -1,8 +1,18 @@
 package simulation;
 
+import java.io.File;
+import java.util.Map;
+import java.util.Set;
+
 /** An interface containing the basic functions of the world. */
 public interface SimpleWorld
 {
+	/** Returns the number of columns in this world. */
+	int getColumns();
+	
+	/** Returns the number of rows in this world. */
+	int getRows();
+	
 	/** Returns the minimum critter memory size for this world. Cannot be less than 8. */
 	int getMinMemory();
 	
@@ -24,14 +34,31 @@ public interface SimpleWorld
 	 */
 	void loadCritters(String filename, int n, int direction);
 	
+	/**
+	 * Loads critters of following a set pattern into this world.
+	 * @param file the file containing the critter information
+	 * @param n the number of critters to load
+	 * @param direction the orientation of the critter. If this value is less than 0, a critter orientation
+	 * 					will be chosen at random.
+	 */
+	void loadCritters(File file, int n, int direction);
+	
+	void loadCritterAtLocation(File file, int c, int r);
+	
 	/** Advances the world state by a single time step. */
 	void advanceOneTimeStep();
 	
 	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
 	boolean isValidHex(int c, int r);
 	
+	/** Returns an entry set mapping the world critters to hex locations. */
+	Set<Map.Entry<SimpleCritter, Hex>> getCritterMap();
+	
+	/** Returns an entry set mapping the world objects to hex locations. */
+	Set<Map.Entry<WorldObject, Hex>> getObjectMap();
+	
 	/**
-	 * Returns information about a hex. Assumes that the 
+	 * Returns information about a hex.
 	 * @param c
 	 * @param r
 	 * @return
@@ -39,7 +66,7 @@ public interface SimpleWorld
 	int analyzeHex(int c, int r);
 	
 	/**
-	 * 
+	 * Returns the critter on a hex, for analysis.
 	 * @param c
 	 * @param r
 	 * @return
diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
index ae9bd56..ee3704d 100644
--- a/src/main/java/simulation/World.java
+++ b/src/main/java/simulation/World.java
@@ -1,13 +1,16 @@
 package simulation;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.Map;
 import java.util.Random;
+import java.util.Set;
 
 import ast.Program;
 import ast.ProgramImpl;
@@ -20,8 +23,10 @@ public class World extends AbstractWorld
 	private String worldname;
 	/** Contains the hex grid of the world. */
 	private Hex[][] grid;
-	/** Maps each critter to a location in the world */
+	/** Maps each critter to a location in the world. */
 	private HashMap<SimpleCritter, Hex> critterMap;
+	/** Maps each non critter object to a location in the world. */
+	private HashMap<WorldObject, Hex> nonCritterObjectMap;
 	/** The number of columns in the world grid. */
 	private int columns;
 	/** The number of rows in the world grid. */
@@ -42,6 +47,7 @@ public class World extends AbstractWorld
 		super();
 		setConstants();
 		critterMap = new HashMap<SimpleCritter, Hex>();
+		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
 		super.critterList = new LinkedList<SimpleCritter>();
 		super.timePassed = 0;
 
@@ -121,6 +127,98 @@ public class World extends AbstractWorld
 		}
 	}
 
+	/**
+	 * Loads a world from a world description file, in the form of a pre-determined file.
+	 * 
+	 * @param filename The name of the file that contains world information.
+	 * @throws FileNotFoundException if the world file could not be found
+	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 */
+	public World(File file) throws FileNotFoundException, IllegalArgumentException
+	{
+		// sets constants and initializes instance fields
+		super();
+		setConstants();
+		critterMap = new HashMap<SimpleCritter, Hex>();
+		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
+		super.critterList = new LinkedList<SimpleCritter>();
+		super.timePassed = 0;
+
+		BufferedReader bf = new BufferedReader(new FileReader(file));
+
+		// parses the world name, and if no valid one is parsed, supplies a default one
+		worldname = FileParser.parseAttributeFromLine(bf, "name ");
+		if (worldname.equals(""))
+			worldname = "Arrakis";
+
+		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
+		try
+		{
+			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
+			String[] dim = worldDimensions.split(" ");
+			columns = Integer.parseInt(dim[0]);
+			rows = Integer.parseInt(dim[1]);
+
+			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
+			{
+				columns = CONSTANTS.get("COLUMNS").intValue();
+				rows = CONSTANTS.get("ROWS").intValue();
+			}
+		}
+		catch (Exception e)
+		{
+			columns = CONSTANTS.get("COLUMNS").intValue();
+			rows = CONSTANTS.get("ROWS").intValue();
+		}
+		numValidHexes = 0;
+
+		// initializes world grid
+		grid = new Hex[columns][rows];
+		for (int i = 0; i < grid.length; i++)
+			for (int j = 0; j < grid[0].length; j++)
+				if (isValidHex(i, j))
+				{
+					grid[i][j] = new Hex(i, j);
+					numValidHexes++;
+				}
+
+		try
+		{
+			// loads in world objects from file
+			String line = bf.readLine();
+			while (line != null)
+			{
+				String[] info = line.split(" ");
+				switch (info[0])
+				{
+					case "rock":
+						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+						break;
+					case "food":
+						Food f = new Food(Integer.parseInt(info[3]));
+						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+						break;
+					case "critter":
+						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
+						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
+								Integer.parseInt(info[4]));
+						if(sc == null)
+						{
+							System.err.println("The critter file " + file.toString() + " does not have the right syntax, so it was not loaded.");
+							break;
+						}
+							
+						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
+						break;
+				}
+				line = bf.readLine();
+			}
+		}
+		catch (Exception e)
+		{
+			return;
+		}
+	}
 	/**
 	 * Generates a default size world containing nothing but randomly placed rocks.
 	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
@@ -132,6 +230,7 @@ public class World extends AbstractWorld
 		worldname = "Arrakis";
 		setConstants();
 		critterMap = new HashMap<SimpleCritter, Hex>();
+		nonCritterObjectMap = new HashMap<WorldObject, Hex>();
 		critterList = new LinkedList<SimpleCritter>();
 		timePassed = 0;
 
@@ -163,7 +262,7 @@ public class World extends AbstractWorld
 			r = (int) (Math.random() * rows);
 			if (isValidHex(c, r))
 			{
-				grid[c][r].addContent(new Rock());
+				addNonCritterObject(new Rock(), c, r);
 				n++;
 			}
 		}
@@ -175,17 +274,28 @@ public class World extends AbstractWorld
 	 */
 	private void setConstants() throws IllegalArgumentException
 	{
-		InputStream in = World.class.getResourceAsStream("constants.txt");
+		InputStream in = World.class.getClassLoader().getResourceAsStream("simulation/constants.txt");
 		if(in == null)
 		{ 
-			System.err.println("The constants.txt file could not be found in bin/simulation.");
-			System.exit(0);
+			throw new IllegalArgumentException();
 		}
 		
 		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
 		CONSTANTS = FileParser.parseConstants(bf);
 	}
 
+	@Override
+	public int getColumns()
+	{
+		return columns;
+	}
+	
+	@Override
+	public int getRows()
+	{
+		return rows;
+	}
+	
 	@Override
 	public boolean isValidHex(int c, int r)
 	{
@@ -199,7 +309,7 @@ public class World extends AbstractWorld
 	}
 
 	@Override
-	public void loadCritters(String filename, int n, int direction)
+	public synchronized void loadCritters(String filename, int n, int direction)
 	{
 		try
 		{
@@ -228,6 +338,53 @@ public class World extends AbstractWorld
 		}
 	}
 
+	@Override
+	public void loadCritters(File file, int n, int direction)
+	{
+		try
+		{
+			BufferedReader br = new BufferedReader(new FileReader(file));
+			//SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
+
+			for (int i = 0; i < n; i++)
+			{
+				SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
+				int randc = (int) (Math.random() * columns);
+				int randr = (int) (Math.random() * rows);
+				while (!isValidHex(randc, randr))
+				{
+					randc = (int) (Math.random() * columns);
+					randr = (int) (Math.random() * rows);
+				}
+
+				if (isValidHex(randc, randr))
+					loadOneCritter(sc, randc, randr);
+			}
+		}
+		catch (FileNotFoundException e)
+		{
+			System.err.println("Critter file not found.");
+			return;
+		}
+	}
+	
+	@Override
+	public void loadCritterAtLocation(File file, int c, int r)
+	{
+		try
+		{
+			BufferedReader br = new BufferedReader(new FileReader(file));
+			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), -1);
+			if(isValidHex(c, r))
+				loadOneCritter(sc, c, r);
+		}
+		catch (FileNotFoundException e)
+		{
+			System.err.println("Critter file not found.");
+			return;
+		}
+	}
+	
 	/**
 	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
 	 * the hex is not within the world boundaries, or if there is something already present at the hex.
@@ -264,6 +421,7 @@ public class World extends AbstractWorld
 			return;
 		if (!isValidHex(c, r))
 			return;
+		nonCritterObjectMap.put(wo, grid[c][r]);
 		grid[c][r].addContent(wo);
 	}
 
@@ -401,6 +559,7 @@ public class World extends AbstractWorld
 		{
 			Food nourishment = (Food) directlyInFront.getContent();
 			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+			nonCritterObjectMap.remove(nourishment);
 			directlyInFront.removeContent();
 		}
 		if (sc.getEnergy() == 0)
@@ -783,6 +942,7 @@ public class World extends AbstractWorld
 		if (directlyInFront.isEmpty())
 		{
 			Food f = new Food(index);
+			nonCritterObjectMap.put(f, directlyInFront);
 			directlyInFront.addContent(f);
 		}
 		if (donator.getEnergy() == 0)
@@ -804,6 +964,7 @@ public class World extends AbstractWorld
 		critterList.remove(sc);
 
 		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
+		nonCritterObjectMap.put(remnant, location);
 		location.addContent(remnant);
 	}
 
@@ -827,6 +988,18 @@ public class World extends AbstractWorld
 		return result;
 	}
 	
+	@Override
+	public Set<Map.Entry<SimpleCritter, Hex>> getCritterMap()
+	{
+		return critterMap.entrySet();
+	}
+	
+	@Override
+	public Set<Map.Entry<WorldObject, Hex>> getObjectMap()
+	{
+		return nonCritterObjectMap.entrySet();
+	}
+	
 	@Override
 	public int analyzeHex(int c, int r)
 	{
diff --git a/src/main/resources/simulation/constants.txt b/src/main/resources/simulation/constants.txt
new file mode 100644
index 0000000..52649f0
--- /dev/null
+++ b/src/main/resources/simulation/constants.txt
@@ -0,0 +1,19 @@
+BASE_DAMAGE 100 {The multiplier for all damage done by attacking}
+DAMAGE_INC 0.2 {Controls how quickly increased offensive or defensive ability affects damage}
+ENERGY_PER_SIZE 500 {How much energy a critter can have per point of size}
+FOOD_PER_SIZE 200 {How much food is created per point of size when a critter dies}
+MAX_SMELL_DISTANCE 10 {Maximum distance at which food can be sensed}
+ROCK_VALUE -1 {The value reported when a rock is sensed}
+COLUMNS 50 {Default number of columns in the world map}
+ROWS 68 {Default number of rows in the world map}
+MAX_RULES_PER_TURN 999 {The maximum number of rules that can be run per critter turn}
+SOLAR_FLUX 1 {Energy gained from sun by doing nothing}
+MOVE_COST 3 {Energy cost of moving (per unit size)}
+ATTACK_COST 5 {Energy cost of attacking (per unit size)}
+GROW_COST 1 {Energy cost of growing (per size and complexity)}
+BUD_COST 9 {Energy cost of budding (per unit complexity)}
+MATE_COST 5 {Energy cost of successful mating (per unit complexity)}
+RULE_COST 2 {Complexity cost of having a rule}
+ABILITY_COST 25 {Complexity cost of having an ability point}
+INITIAL_ENERGY 250 {Energy of a newly birthed critter}
+MIN_MEMORY 8 {Minimum number of memory entries in a critter}
\ No newline at end of file
diff --git a/src/test/java/mutationtests/TestMutateDuplicate.java b/src/test/java/mutationtests/TestMutateDuplicate.java
index 5d75a27..08c2045 100644
--- a/src/test/java/mutationtests/TestMutateDuplicate.java
+++ b/src/test/java/mutationtests/TestMutateDuplicate.java
@@ -9,7 +9,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import ast.MutationDuplicate;
-import ast.MutationReplace;
 import ast.Program;
 import parse.Parser;
 import parse.ParserFactory;
diff --git a/src/test/java/mutationtests/TestMutateInsert.java b/src/test/java/mutationtests/TestMutateInsert.java
index e1a07bd..3e0c2e6 100644
--- a/src/test/java/mutationtests/TestMutateInsert.java
+++ b/src/test/java/mutationtests/TestMutateInsert.java
@@ -8,15 +8,7 @@ import java.io.Reader;
 import org.junit.Before;
 import org.junit.Test;
 
-import ast.BinaryExpr;
-import ast.Condition;
-import ast.MutationInsert;
-import ast.MutationRemove;
-import ast.Node;
-import ast.Program;
-import ast.Relation;
-import ast.Sensor;
-import ast.UnaryExpr;
+import ast.*;
 import parse.Parser;
 import parse.ParserFactory;
 import parsertests.ASTParserTest;
diff --git a/src/test/java/mutationtests/TestMutateRemove.java b/src/test/java/mutationtests/TestMutateRemove.java
index f20e9c7..3daa497 100644
--- a/src/test/java/mutationtests/TestMutateRemove.java
+++ b/src/test/java/mutationtests/TestMutateRemove.java
@@ -129,7 +129,6 @@ public class TestMutateRemove
 		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
 		
 		int previousSize = be.size();
-		String before = be.toString();
 		ue.acceptMutation(new MutationRemove(true));
 		assertTrue(previousSize > be.size());
 		assertTrue("3 + 2".equals(be.toString()));
diff --git a/src/test/java/mutationtests/TestMutateReplace.java b/src/test/java/mutationtests/TestMutateReplace.java
index 5f70bb3..8d7b7c8 100644
--- a/src/test/java/mutationtests/TestMutateReplace.java
+++ b/src/test/java/mutationtests/TestMutateReplace.java
@@ -9,7 +9,6 @@ import org.junit.Before;
 import org.junit.Test;
 
 import ast.MutationReplace;
-import ast.MutationTransform;
 import ast.Program;
 import parse.Parser;
 import parse.ParserFactory;
diff --git a/src/test/java/mutationtests/TestMutateSwap.java b/src/test/java/mutationtests/TestMutateSwap.java
index d5b046b..ed4310f 100644
--- a/src/test/java/mutationtests/TestMutateSwap.java
+++ b/src/test/java/mutationtests/TestMutateSwap.java
@@ -1,27 +1,18 @@
 package mutationtests;
 
-import static org.junit.Assert.*;
-
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.util.LinkedList;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import ast.BinaryExpr;
-import ast.Command;
-import ast.MutationInsert;
-import ast.BinaryExpr.*;
 import parse.Parser;
 import parse.ParserFactory;
 import parsertests.ASTParserTest;
 import ast.MutationSwap;
 import ast.Program;
-import ast.UnaryExpr;
-import ast.Update;
 
 /**
  * 
diff --git a/src/test/java/mutationtests/TestMutateTransform.java b/src/test/java/mutationtests/TestMutateTransform.java
index 4011203..64a4d81 100644
--- a/src/test/java/mutationtests/TestMutateTransform.java
+++ b/src/test/java/mutationtests/TestMutateTransform.java
@@ -4,23 +4,11 @@ import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.util.LinkedList;
 
 import org.junit.Before;
 import org.junit.Test;
 
-import ast.Action;
-import ast.BinaryCondition;
-import ast.BinaryExpr;
-import ast.Command;
-import ast.Condition;
-import ast.MutationRemove;
-import ast.MutationTransform;
-import ast.Program;
-import ast.Relation;
-import ast.Sensor;
-import ast.UnaryExpr;
-import ast.Update;
+import ast.*;
 import parse.Parser;
 import parse.ParserFactory;
 import parsertests.ASTParserTest;
diff --git a/src/test/java/parsertests/ASTParserTest.java b/src/test/java/parsertests/ASTParserTest.java
index 2789d73..68bb998 100644
--- a/src/test/java/parsertests/ASTParserTest.java
+++ b/src/test/java/parsertests/ASTParserTest.java
@@ -12,7 +12,6 @@ import org.junit.Test;
 import ast.Program;
 import parse.Parser;
 import parse.ParserFactory;
-import parse.Tokenizer;
 
 /** This class contains tests for the Critter parser. */
 public class ASTParserTest
diff --git a/src/test/java/parsertests/FileParserTest.java b/src/test/java/parsertests/FileParserTest.java
index 52571a2..bbf97a5 100644
--- a/src/test/java/parsertests/FileParserTest.java
+++ b/src/test/java/parsertests/FileParserTest.java
@@ -59,7 +59,7 @@ public class FileParserTest
 	}
 	
 	@Test
-	public void testConsoleLoad() //TODO remove when done testing
+	public void testConsoleLoad()
 	{
 		try
 		{
@@ -72,6 +72,7 @@ public class FileParserTest
 			Program prog = p.parse(br);
 			
 			SimpleCritter sc = new Critter(prog, critAttr, name, -1);
+			sc.getEnergy();
 		}
 		catch (FileNotFoundException e)
 		{
diff --git a/src/test/java/simulationTests/BudTest.java b/src/test/java/simulationTests/BudTest.java
deleted file mode 100644
index e24891d..0000000
--- a/src/test/java/simulationTests/BudTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package simulationTests;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import console.Console;
-
-public class BudTest {
-
-	Console console1 = null;
-	Console console2 = null;
-	Console console3 = null;
-
-	@Before
-	public void setup() {
-		console1 = new Console();
-		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
-		console2 = new Console();
-		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
-		console3 = new Console();
-		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
-	}
-
-	/**
-	 * testBasicBud checks to see if a critter can bud under normal circumstances.
-	 */
-	@Test
-	public void testBasicBud() {
-		System.out.println("testBasicBud");
-		int initialNumCritters = console1.crittersAlive();
-		console1.worldInfo();
-		console1.advanceTime(1);
-		console1.worldInfo();
-		assertEquals(initialNumCritters + 1, console1.crittersAlive());
-	}
-
-	/**
-	 * testBudWithRock checks to see that a critter does not bud when there is a
-	 * rock behind it.
-	 */
-	@Test
-	public void testBudWithRock() {
-		System.out.println("testBudWithRock");
-		int initialNumCritters = console2.crittersAlive();
-		console2.worldInfo();
-		console2.advanceTime(1);
-		console2.worldInfo();
-		assertEquals(initialNumCritters, console2.crittersAlive());
-	}
-
-	/**
-	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
-	 * It also tests to see if critter death properly adds a food object onto the site of death.
-	 */
-	@Test
-	public void testBudNoEnergy() {
-		System.out.println("testBudNoEnergy");
-		int initialNumCritters = console3.crittersAlive();
-		console3.worldInfo();
-		console3.advanceTime(1);
-		console3.worldInfo();
-		assertEquals(initialNumCritters - 1, console3.crittersAlive());
-	}
-
-}
diff --git a/src/test/java/simulationTests/AttackTests.java b/src/test/java/simulationtests/AttackTests.java
similarity index 95%
rename from src/test/java/simulationTests/AttackTests.java
rename to src/test/java/simulationtests/AttackTests.java
index 2859cb7..510b215 100644
--- a/src/test/java/simulationTests/AttackTests.java
+++ b/src/test/java/simulationtests/AttackTests.java
@@ -1,4 +1,4 @@
-package simulationTests;
+package simulationtests;
 
 import org.junit.Before;
 import org.junit.Test;
diff --git a/src/test/java/simulationtests/BudTest.java b/src/test/java/simulationtests/BudTest.java
new file mode 100644
index 0000000..ef8bf90
--- /dev/null
+++ b/src/test/java/simulationtests/BudTest.java
@@ -0,0 +1,67 @@
+package simulationtests;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class BudTest {
+
+	Console console1 = null;
+	Console console2 = null;
+	Console console3 = null;
+
+	@Before
+	public void setup() {
+		console1 = new Console();
+		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
+		console2 = new Console();
+		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
+		console3 = new Console();
+		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
+	}
+
+	/**
+	 * testBasicBud checks to see if a critter can bud under normal circumstances.
+	 */
+	@Test
+	public void testBasicBud() {
+		System.out.println("testBasicBud");
+		int initialNumCritters = console1.crittersAlive();
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+		assertEquals(initialNumCritters + 1, console1.crittersAlive());
+	}
+
+//	/**
+//	 * testBudWithRock checks to see that a critter does not bud when there is a
+//	 * rock behind it.
+//	 */
+//	@Test
+//	public void testBudWithRock() {
+//		System.out.println("testBudWithRock");
+//		int initialNumCritters = console2.crittersAlive();
+//		console2.worldInfo();
+//		console2.advanceTime(1);
+//		console2.worldInfo();
+//		assertEquals(initialNumCritters, console2.crittersAlive());
+//	}
+//
+//	/**
+//	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
+//	 * It also tests to see if critter death properly adds a food object onto the site of death.
+//	 */
+//	@Test
+//	public void testBudNoEnergy() {
+//		System.out.println("testBudNoEnergy");
+//		int initialNumCritters = console3.crittersAlive();
+//		console3.worldInfo();
+//		console3.advanceTime(1);
+//		console3.worldInfo();
+//		assertEquals(initialNumCritters - 1, console3.crittersAlive());
+//	}
+
+}
diff --git a/src/test/java/simulationTests/MateTest.java b/src/test/java/simulationtests/MateTest.java
similarity index 98%
rename from src/test/java/simulationTests/MateTest.java
rename to src/test/java/simulationtests/MateTest.java
index 7c6efad..70c2089 100644
--- a/src/test/java/simulationTests/MateTest.java
+++ b/src/test/java/simulationtests/MateTest.java
@@ -1,4 +1,4 @@
-package simulationTests;
+package simulationtests;
 
 import org.junit.Before;
 import org.junit.Test;
diff --git a/src/test/java/simulationTests/MovingTest.java b/src/test/java/simulationtests/MovingTest.java
similarity index 96%
rename from src/test/java/simulationTests/MovingTest.java
rename to src/test/java/simulationtests/MovingTest.java
index 18ff962..56178ff 100644
--- a/src/test/java/simulationTests/MovingTest.java
+++ b/src/test/java/simulationtests/MovingTest.java
@@ -1,6 +1,4 @@
-package simulationTests;
-
-import static org.junit.Assert.*;
+package simulationtests;
 
 import org.junit.Before;
 import org.junit.Test;
diff --git a/src/test/java/simulationTests/SpiralCritterTest.java b/src/test/java/simulationtests/SpiralCritterTest.java
similarity index 95%
rename from src/test/java/simulationTests/SpiralCritterTest.java
rename to src/test/java/simulationtests/SpiralCritterTest.java
index 18af1b3..c292b32 100644
--- a/src/test/java/simulationTests/SpiralCritterTest.java
+++ b/src/test/java/simulationtests/SpiralCritterTest.java
@@ -1,4 +1,4 @@
-package simulationTests;
+package simulationtests;
 
 import org.junit.Test;
 
diff --git a/src/test/java/simulationTests/TurnAndNearbyTests.java b/src/test/java/simulationtests/TurnAndNearbyTests.java
similarity index 97%
rename from src/test/java/simulationTests/TurnAndNearbyTests.java
rename to src/test/java/simulationtests/TurnAndNearbyTests.java
index a1aa66a..39aee78 100644
--- a/src/test/java/simulationTests/TurnAndNearbyTests.java
+++ b/src/test/java/simulationtests/TurnAndNearbyTests.java
@@ -1,4 +1,4 @@
-package simulationTests;
+package simulationtests;
 
 import org.junit.Before;
 import org.junit.Test;
diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
index 5abacf0..040f068 100644
--- a/src/test/resources/simulationTests/SensingWorld.txt
+++ b/src/test/resources/simulationTests/SensingWorld.txt
@@ -1,4 +1,4 @@
 name Sensing World 1
 size 5 10
 
-critter SensingCritter.txt 4 9 0
\ No newline at end of file
+critter src/test/resources/simulationTests/SensingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
index 7102f96..ca69671 100644
--- a/src/test/resources/simulationTests/SpiralCritterWorld.txt
+++ b/src/test/resources/simulationTests/SpiralCritterWorld.txt
@@ -1,3 +1,4 @@
 name Spiral World
 size 11 13
-critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
\ No newline at end of file
+critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
+food 5 7 10000
\ No newline at end of file
