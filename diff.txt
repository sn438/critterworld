diff --git a/.gitignore b/.gitignore
index cba70df..9d56415 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,3 +12,8 @@ content
 *.pdf
 *.DS_Store
 
+src/main/java/interpret/ActionOutcome.java
+src/main/java/parse/Token.java
+src/main/java/parse/TokenCategory.java
+src/main/java/parse/Tokenizer.java
+src/main/java/parse/TokenType.java
diff --git a/a5world.txt b/a5world.txt
new file mode 100644
index 0000000..e9fafb5
--- /dev/null
+++ b/a5world.txt
@@ -0,0 +1,13 @@
+name a5 world
+size 7 8
+rock 0 4
+rock 6 6
+rock 0 1
+rock 9 10
+
+// Some food
+food 2 5 500
+
+// example-critter.txt should be in the working directory
+critter example-critter.txt 2 3 1
+critter example-critter.txt 2 1 5
\ No newline at end of file
diff --git a/biggerworld.txt b/biggerworld.txt
new file mode 100644
index 0000000..10c3b47
--- /dev/null
+++ b/biggerworld.txt
@@ -0,0 +1,42 @@
+name Slightly bigger world
+size 100 150
+rock 2 2
+rock 3 6
+rock 9 10
+
+// Some food
+food 4 4 500
+food 1 3 1000
+food 28 128 10000
+food 29 129 10000
+food 29 129 10000
+food 29 128 10000
+food 26 128 10000
+food 26 129 10000
+food 28 129 10000
+food 26 127 10000
+food 41 25 10000
+food 39 26 10000
+food 39 25 10000
+food 39 28 10000
+food 40 26 10000
+food 41 28 10000
+food 38 24 10000
+food 39 24 10000
+
+// example-critter.txt should be in the working directory
+critter example-critter.txt 2 5 3
+critter example-critter.txt 4 3 1
+critter example-critter.txt 4 4 2
+critter example-critter.txt 40 25 4
+critter example-critter.txt 88 93 0
+critter example-critter.txt 66 128 5
+critter example-critter.txt 71 40 5
+critter example-critter.txt 69 100 5
+critter example-critter.txt 42 28 5
+critter example-critter.txt 60 58 5
+critter example-critter.txt 32 81 5
+critter example-critter.txt 97 60 5
+critter example-critter.txt 14 128 5
+critter example-critter.txt 27 128 5
+
diff --git a/example-critter.txt b/example-critter.txt
new file mode 100644
index 0000000..cc5a71d
--- /dev/null
+++ b/example-critter.txt
@@ -0,0 +1,22 @@
+species: example
+memsize: 9
+defense: 2
+offense: 3
+size: 100
+energy: 500000
+posture: 17
+POSTURE != 17 --> POSTURE := 17; // we are species 17!
+nearby[3] = 0 and ENERGY > 2500 --> bud;
+{ENERGY > SIZE * 400 and SIZE < 7} --> grow;
+ahead[1] < -1 and ENERGY < 500 * SIZE --> eat;
+// next line attacks only other species
+(ahead[1] / 10 mod 100) != 17 and ahead[1] > 0 --> attack;
+ahead[1] < -5 --> forward;
+ahead[2] < -10 and ahead[1] = 0 --> forward;
+ahead[3] < -15 and ahead[1] = 0 --> forward;
+ahead[4] < -20 and ahead[1] = 0 --> forward;
+nearby[0] > 0 and nearby[3] = 0 --> backward;
+// karma action: donate food if we are too full or large enough
+{ahead[1] = 0 or ahead[1] < -1} and { ENERGY > 2500 or SIZE > 7 } --> serve[ENERGY / 42];
+random[3] = 1 --> left;
+1 = 1 --> wait; // mostly soak up the rays
diff --git a/examples/failure-example-critter1.txt b/examples/failure-example-critter1.txt
new file mode 100644
index 0000000..e69de29
diff --git a/examples/world.txt b/examples/world.txt
index 0fbfadf..91bdd68 100644
--- a/examples/world.txt
+++ b/examples/world.txt
@@ -8,7 +8,7 @@ rock 9 10
 food 4 4 500
 food 1 3 1000
 
-// example_critter.txt should be in the working directory
-critter example_critter.txt 2 5 3
-critter example_critter.txt 4 3 1
-critter example_critter.txt 4 4 2
+// example-critter.txt should be in the working directory
+critter example-critter.txt 2 5 3
+critter example-critter.txt 4 3 1
+critter example-critter.txt 4 4 2
diff --git a/log.txt b/log.txt
new file mode 100644
index 0000000..7aedfce
--- /dev/null
+++ b/log.txt
@@ -0,0 +1,271 @@
+[33mcommit fce536fec1b6d39c94b8eb25247226e99b89f023[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31morigin/master[m[33m, [m[1;31morigin/HEAD[m[33m)[m
+Merge: faaae27 41fe28e
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 22:47:22 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit faaae27e8751ae57808ad7b3b0819f7624e3e782[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 22:46:48 2017 -0400
+
+    Final tests
+
+[33mcommit 41fe28e826698ca5cf3e31913bdf54842644b50c[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 22:44:40 2017 -0400
+
+    Testing Done
+
+[33mcommit 3f34641d080ef40ea4dbab4d1980324643736d26[m
+Merge: 3631e4c 2e8bab8
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 21:38:55 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit 3631e4cef53d386e115ab7fa8364e9d22a95efe9[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 21:38:49 2017 -0400
+
+    Turning Tests
+
+[33mcommit 2e8bab888d0b606f53dda0b449210c2f3996abdc[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 21:35:36 2017 -0400
+
+    More Tests
+
+[33mcommit 90fd50cc87b830aff15673e999c4cd22044a9543[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 20:43:50 2017 -0400
+
+    Tests!
+
+[33mcommit 0edcfbd68771f1bed74c2f699a211fdb6a60c7a5[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 20:14:08 2017 -0400
+
+    SpiralCritter works now
+
+[33mcommit 9bdbd6cc4f186af60209dce78176917924f76428[m
+Merge: 4c6c2ee 4892088
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 16:57:49 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit 4c6c2ee00ac1d482311238e8b27924a6ba4d2b51[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 16:57:41 2017 -0400
+
+    Minor fixes
+
+[33mcommit 48920886f5e3ac44e22a57eae5f0fc9f1045d3ac[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 15:37:39 2017 -0400
+
+    Mating Testing Final
+
+[33mcommit 35f9b0ef281e2a40ce0bbb213ba29acc3d81e8e3[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 15:31:26 2017 -0400
+
+    Mating Testing
+
+[33mcommit 7429469fac45d9dc7908a5e9a1bc92ec6d2f7460[m
+Merge: d3b6060 753823a
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 14:59:59 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit d3b60607e47ccc71ddb9a8a65f249e65e127bb22[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 14:58:53 2017 -0400
+
+    Mate Test Change
+
+[33mcommit 9ca82f204cd008b0e3449775ebc042e96557f9a4[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 14:57:30 2017 -0400
+
+    File Parser Update
+
+[33mcommit ecdea17320fd143cf698fc9faa53d5b39131f071[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 14:57:00 2017 -0400
+
+    Mate Testing Done and Bug Fixed
+
+[33mcommit b669ff85cd406986cb387789b43c622d2fd53366[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 13:11:19 2017 -0400
+
+    Mate Testing
+
+[33mcommit b24dcaeecb0961141406915da0977e58847259c1[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 13:01:45 2017 -0400
+
+    Testing
+
+[33mcommit d9804214694a1287b36387ab5096161119fb7d2a[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 13:00:32 2017 -0400
+
+    Testing2
+
+[33mcommit 760b3702d46d973fc51fdfe2988e1365e553c229[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 12:59:02 2017 -0400
+
+    Revert "Testing"
+    
+    This reverts commit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28.
+
+[33mcommit bd9403c57b9d23d8f0ecd32ef96eacbf7338ae28[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 12:54:41 2017 -0400
+
+    Testing
+
+[33mcommit 753823a1f154f70f6e374d0b5e88df5d8239cd1e[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 12:49:12 2017 -0400
+
+    more fixes
+
+[33mcommit 086816869af82477368bfd3c77e6e9f1cff9e8fd[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 12:46:23 2017 -0400
+
+    Fixes
+
+[33mcommit a02473c4318c5f7012d276aed173e05a84fa7cfd[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 12:42:26 2017 -0400
+
+    Revert "Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw"
+    
+    This reverts commit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b, reversing
+    changes made to 21179a6b02c48db2457e6bdb649d6b4b581bd6e3.
+
+[33mcommit 31fb48dc99c9546fcb9e68f5898b4d5f19c9e72b[m
+Merge: 21179a6 8fc49a4
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 12:41:21 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit 21179a6b02c48db2457e6bdb649d6b4b581bd6e3[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 12:40:30 2017 -0400
+
+    Stuff
+
+[33mcommit 8fc49a48b7b0d7351fe1b0df63e19cf2fea71d24[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 12:39:25 2017 -0400
+
+    Tokenizer Has Been Updated With Correct Solution
+
+[33mcommit cebe8f1a5273b0a0a02553cd42f682511f53e186[m
+Merge: 0343510 878321e
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 09:16:26 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit 03435103759b26ede1d3b7c4215dd1f117cd927a[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Tue Oct 31 09:16:19 2017 -0400
+
+    Bud Test
+
+[33mcommit 878321e363ceaa0b2d586c8be5b0102618d50634[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 02:11:11 2017 -0400
+
+    Documentation
+
+[33mcommit dc3812325cb76cf5af623bba64f907b01ca7e243[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 01:31:22 2017 -0400
+
+    Misc stuff
+
+[33mcommit fd5e0b2a528f1ef885e8b1d6de2d101fb0e205ba[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 01:09:31 2017 -0400
+
+    Documentation + finishing up console
+
+[33mcommit c52c9c5df62e77374dc9d24a9d5f5f3d9c69c0f9[m
+Author: Andy <az389@cornell.edu>
+Date:   Tue Oct 31 00:01:43 2017 -0400
+
+    More documentation
+
+[33mcommit 4c6783d0533f75d5d9b97742f61e7803f5aa4390[m
+Merge: c4f5689 adc8c91
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 23:51:40 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit c4f56899144a8923b956408256221a5e46fcc436[m
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 23:51:38 2017 -0400
+
+    Documentation
+
+[33mcommit adc8c91a7ca3d83830c6458fc17aee3d81a02d3b[m
+Merge: 88613b7 ef684b3
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 30 23:47:38 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit 88613b73a6b7c55a034c69ce17b39b15b2f98ad2[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 30 23:47:33 2017 -0400
+
+    Moving Test Done
+
+[33mcommit ef684b37c2fe6924efcc416a45c716297c9f46d6[m
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 23:45:01 2017 -0400
+
+    Fixes
+
+[33mcommit 067278303066953f1241de39755d7545b4cb4b1e[m
+Merge: a6d2ead 5a4812d
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 23:43:56 2017 -0400
+
+    Merge branch 'master' of https://github.coecis.cornell.edu/cs2112-f17/team-az389-sn438-cw
+
+[33mcommit a6d2eadf9badd7c0c163420549e66e2f9eaa2145[m
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 23:43:41 2017 -0400
+
+    Spiral stuff
+
+[33mcommit 5a4812d93de841aed1720ee36c4a6e9304f368e0[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 30 23:25:53 2017 -0400
+
+    Moving Test Initial
+
+[33mcommit 6bdc8658cab5adde9acf8c61cdc1d384bc30a32c[m
+Author: Andy <az389@cornell.edu>
+Date:   Mon Oct 30 17:53:50 2017 -0400
+
+    SpiralCritter stuff
+
+[33mcommit 200b419d4d5d2162ef30ddeb630491a180dd968d[m
+Author: sn438 <31802007+sn438@users.noreply.github.com>
+Date:   Mon Oct 30 17:35:38 2017 -0400
+
+ 
\ No newline at end of file
diff --git a/src/main/java/ast/Action.java b/src/main/java/ast/Action.java
index bca9a07..fc50150 100644
--- a/src/main/java/ast/Action.java
+++ b/src/main/java/ast/Action.java
@@ -2,8 +2,6 @@ package ast;
 
 import java.util.Random;
 
-import ast.Action.ActType;
-
 /** An AST representation of a critter action. */
 public class Action extends AbstractNode implements CommandComponent
 {
@@ -27,6 +25,32 @@ public class Action extends AbstractNode implements CommandComponent
 		val.setParent(this);
 	}
 	
+	/** Returns the type of action contained in this node. */
+	public ActType getActType()
+	{
+		return act;
+	}
+	
+	/** Sets the value of {@code act} to {@code at}, modifying {@code val} as necessary. */
+	public void setActType(ActType at)
+	{
+		Random r = new Random();
+		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
+		{
+			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
+		}
+		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
+			this.val = null;
+		this.act = at;
+	}
+	
+	/** Returns the expression stored at this node, if there is one. */
+	public Expr getVal()
+	{
+		return val;
+	}
+	
 	@Override
 	public int size()
 	{
@@ -124,23 +148,6 @@ public class Action extends AbstractNode implements CommandComponent
 		return sb;
 	}
 	
-	/**
-	 * setActType sets the ActType for the Action. 
-	 * @param at is the ActType that the Action is being set to. If at is not of the same type as the original 
-	 * ActType, then the value is modified if necessary.
-	 */
-	public void setActType(ActType at)
-	{
-		Random r = new Random();
-		if (!(this.act.equals(ActType.TAG) || this.act.equals(ActType.SERVE)))
-		{
-			if ((at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
-				this.val = new UnaryExpr(java.lang.Integer.MAX_VALUE/r.nextInt());
-		}
-		if (!(at.equals(ActType.TAG) || at.equals(ActType.SERVE)))
-			this.val = null;
-		this.act = at;
-	}
 	/** An enumeration of all the possible action types. */
 	public enum ActType
 	{
diff --git a/src/main/java/ast/BinaryCondition.java b/src/main/java/ast/BinaryCondition.java
index 99ce650..4bc10ad 100644
--- a/src/main/java/ast/BinaryCondition.java
+++ b/src/main/java/ast/BinaryCondition.java
@@ -1,5 +1,7 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** A representation of a binary Boolean condition: 'and' or 'or' */
 public class BinaryCondition extends AbstractNode implements Condition
 {
@@ -20,44 +22,43 @@ public class BinaryCondition extends AbstractNode implements Condition
 		left.setParent(this);
 		right.setParent(this);
 	}
-	/**
-	 * getLeft returns the left node for the BinaryCondition.
-	 * @return left node.
-	 */
+	/** Returns the left child of this binary condition. */
 	public Condition getLeft()
 	{
 		return left;
 	}
 	
-	/**
-	 * setLeft sets the left node for the Binary Condition.
-	 * @param newLeft is the new left node of the Binary Condition.
-	 */
+	/** Sets the value of {@code left} to {@code newleft}. */
 	public void setLeft(Condition newLeft)
 	{
 		left = newLeft;
 		left.setParent(this);
 	}
 	
-	/**
-	 * getRight returns the right node for the BinaryCondition.
-	 * @return right node.
-	 */
+	/** Returns the right child of this binary condition. */
 	public Condition getRight()
 	{
 		return right;
 	}
 	
-	/**
-	 * setRight sets the left node for the Binary Condition.
-	 * @param newRight is the new left node of the Binary Condition.
-	 */
+	/** Sets the value of {@code right} to {@code newRight}. */
 	public void setRight(Condition newRight)
 	{
 		right = newRight;
 		right.setParent(this);
 	}
 	
+	/** Returns the operator type of this binary condition. */
+	public Operator getOp()
+	{
+		return op;
+	}
+	
+	/** Sets the value of {@code op} to {@code o}. */
+	public void setOp(Operator o)
+	{
+		this.op = o;
+	}
 	@Override
 	public int size()
 	{
@@ -130,9 +131,9 @@ public class BinaryCondition extends AbstractNode implements Condition
 	}
 
 	@Override
-	public boolean evaluate()
+	public boolean acceptEvaluation(Interpreter i)
 	{
-		throw new UnsupportedOperationException();
+		return i.eval(this);
 	}
 
 	/** An enumeration of all possible binary condition operators. */
@@ -146,11 +147,4 @@ public class BinaryCondition extends AbstractNode implements Condition
 	{
 		return NodeType.BINARYCONDITION;
 	}
-	/**
-	 * setOperator sets the operator to op.
-	 * @param op is the parameter that operator is being set to. 
-	 */
-	public void setOperator(Operator op) {
-		this.op = op;
-	}
 }
\ No newline at end of file
diff --git a/src/main/java/ast/BinaryExpr.java b/src/main/java/ast/BinaryExpr.java
index 1765f87..dac5008 100644
--- a/src/main/java/ast/BinaryExpr.java
+++ b/src/main/java/ast/BinaryExpr.java
@@ -1,5 +1,7 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** A representation of a binary numerical expression that evaluates to an integer. */
 public class BinaryExpr extends AbstractNode implements Expr
 {
@@ -20,25 +22,34 @@ public class BinaryExpr extends AbstractNode implements Expr
 		left.setParent(this);
 		right.setParent(this);
 	}
-	
+	/** Returns the left child of this binary expression. */
 	public Expr getLeft()
 	{
 		return left;
 	}
+	/** Sets the value of {@code left} to {@code newLeft}. */
 	public void setLeft(Expr newLeft)
 	{
 		left = newLeft;
 		left.setParent(this);
 	}
+	/** Returns the right child of this binary expression. */
 	public Expr getRight()
 	{
 		return right;
 	}
+	/** Sets the value of {@code right} to {@code newRight}. */
 	public void setRight(Expr newRight)
 	{
 		right = newRight;
 		right.setParent(this);
 	}
+	/** Returns the operator type of this binary expression. */
+	public MathOp getOperator()
+	{
+		return operator;
+	}
+	/** Sets the value of {@code operator} to {@code op}. */
 	public void setOperator(MathOp op)
 	{
 		this.operator = op;
@@ -131,9 +142,9 @@ public class BinaryExpr extends AbstractNode implements Expr
 		return sb;
 	}
 	@Override
-	public int evaluate()
+	public int acceptEvaluation(Interpreter i)
 	{
-		throw new UnsupportedOperationException();
+		return i.eval(this);
 	}
 
 	/** Enumerates all the accepted binary mathematical operations. */
diff --git a/src/main/java/ast/Command.java b/src/main/java/ast/Command.java
index 79d7011..c46d579 100644
--- a/src/main/java/ast/Command.java
+++ b/src/main/java/ast/Command.java
@@ -21,10 +21,19 @@ public class Command extends AbstractNode
 			u.setParent(this);
 		last.setParent(this);
 	}
+	
+	/** Returns the list of updates in this command. */
 	public LinkedList<Update> getUpdateList()
 	{
 		return UpdateList;
 	}
+	
+	/** Returns the last component of this command. */
+	public CommandComponent getLast()
+	{
+		return last;
+	}
+	
 	@Override
 	public int size()
 	{
@@ -111,7 +120,7 @@ public class Command extends AbstractNode
 	public StringBuilder prettyPrint(StringBuilder sb)
 	{
 		for(Update u : getUpdateList())
-			sb.append(u.toString() + "\n");
+			sb.append(u.toString() + " ");
 		sb.append(last.toString());
 		return sb;
 	}
diff --git a/src/main/java/ast/Condition.java b/src/main/java/ast/Condition.java
index 3cf5e2b..92853be 100644
--- a/src/main/java/ast/Condition.java
+++ b/src/main/java/ast/Condition.java
@@ -1,10 +1,12 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** An interface representing a Boolean condition in a critter program. */
 public interface Condition extends Node
 {
-	/** Returns the boolean value of this condition. */
-	public boolean evaluate(); // to be done in A5
+	/** Accepts an evaluation from an Interpreter. */
+	public boolean acceptEvaluation(Interpreter i);
 	
 	/** Returns a deep copy of this condition. */
 	public Condition clone();
diff --git a/src/main/java/ast/Expr.java b/src/main/java/ast/Expr.java
index f6de6df..a535510 100644
--- a/src/main/java/ast/Expr.java
+++ b/src/main/java/ast/Expr.java
@@ -1,10 +1,12 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** A critter program expression that has an integer value. */
 public interface Expr extends Node
 {
-	/** Returns the integer value of this expression. */
-	public int evaluate(); // to be done in A5
+	/** Accepts an evaluation from Interpreter i. */
+	public int acceptEvaluation(Interpreter i);
 	
 	/** Returns a deep copy of this expression. */
 	public Expr clone();
diff --git a/src/main/java/ast/MutationTransform.java b/src/main/java/ast/MutationTransform.java
index 72282ee..ea98f5f 100644
--- a/src/main/java/ast/MutationTransform.java
+++ b/src/main/java/ast/MutationTransform.java
@@ -34,7 +34,7 @@ public class MutationTransform extends AbstractMutation
 			op = BinaryCondition.Operator.OR;
 			break;
 		}
-		c.setOperator(op);
+		c.setOp(op);
 		if(printMutationDetail)
 			System.out.println("Transformed the Condition node\n" + c + "\n");
 		return true;
diff --git a/src/main/java/ast/Program.java b/src/main/java/ast/Program.java
index 31eba98..8a93f6f 100644
--- a/src/main/java/ast/Program.java
+++ b/src/main/java/ast/Program.java
@@ -1,8 +1,13 @@
 package ast;
 
+import java.util.LinkedList;
+
 /** An abstraction of a critter program. */
 public interface Program extends Node
 {
+	/** Returns the list of rules contained in this program node. */
+	public LinkedList<Rule> getRulesList();
+	
 	/**
 	 * Mutates this program with a single mutation
 	 * @return The root of the mutated AST
diff --git a/src/main/java/ast/ProgramImpl.java b/src/main/java/ast/ProgramImpl.java
index aa17e31..73c14b8 100644
--- a/src/main/java/ast/ProgramImpl.java
+++ b/src/main/java/ast/ProgramImpl.java
@@ -16,6 +16,7 @@ public class ProgramImpl extends AbstractNode implements Program
 			r.setParent(this);
 	}
 	
+	@Override
 	public LinkedList<Rule> getRulesList()
 	{
 		return RulesList;
@@ -100,22 +101,22 @@ public class ProgramImpl extends AbstractNode implements Program
 			switch(rand)
 			{
 				case 0:
-					m = MutationFactory.getRemove(true);
+					m = MutationFactory.getRemove(false);
 					break;
 				case 1:
-					m = MutationFactory.getSwap(true);
+					m = MutationFactory.getSwap(false);
 					break;
 				case 2:
-					m = MutationFactory.getReplace(true);
+					m = MutationFactory.getReplace(false);
 					break;
 				case 3:
-					m = MutationFactory.getTransform(true);
+					m = MutationFactory.getTransform(false);
 					break;
 				case 4:
-					m = MutationFactory.getInsert(true);
+					m = MutationFactory.getInsert(false);
 					break;
 				case 5:
-					m = MutationFactory.getDuplicate(true);
+					m = MutationFactory.getDuplicate(false);
 					break;
 			}
 			valid = mutate(randIndex, m);
diff --git a/src/main/java/ast/Relation.java b/src/main/java/ast/Relation.java
index 150361b..e1f3fe4 100644
--- a/src/main/java/ast/Relation.java
+++ b/src/main/java/ast/Relation.java
@@ -1,5 +1,7 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** A representation of a relational comparison between two numerical expressions. */
 public class Relation extends AbstractNode implements Condition
 {
@@ -9,10 +11,10 @@ public class Relation extends AbstractNode implements Condition
 	private RelOp op;
 	/** The right child of this node. */
 	private Expr right;
-	
+	/** The condition contained in this relation, if there is one. */
 	private Condition cond;
 	
-	/** Creates a relational comparison between two numerical expressions, representing l o r.*/
+	/** Creates a relational comparison between two numerical expressions, representing l op r.*/
 	public Relation(Expr l, RelOp o, Expr r)
 	{
 		this.left = l;
@@ -35,32 +37,62 @@ public class Relation extends AbstractNode implements Condition
 		cond.setParent(this);
 	}
 
+	/** 
+	 * Returns the left child of this relation. 
+	 * Precondition: {@code this.op != ISCOND}
+	 */
 	public Expr getLeft()
 	{
 		return left;
 	}
+	
+	/** Sets the value of {@code left} to {@code newLeft}. */
 	public void setLeft(Expr newLeft)
 	{
 		left = newLeft;
 		left.setParent(this);
 	}
+	
+	/** 
+	 * Returns the right child of this relation. 
+	 * Precondition: {@code this.op != ISCOND}
+	 */
 	public Expr getRight()
 	{
 		return right;
 	}
+	
+	/** Sets the value of {@code right} to {@code newRight}. */
 	public void setRight(Expr newRight)
 	{
 		right = newRight;
 		right.setParent(this);
 	}
+	
+	/** Returns a boolean based on whether or not this relation node contains a condition. */
 	public boolean isCond()
 	{
 		return op == RelOp.ISCOND;
 	}
 	
+	/**
+	 * Returns the condition this relation contains.
+	 * Precondition: {@code this.op == ISCOND}
+	 */
+	public Condition getCond()
+	{
+		return cond;
+	}
+	
+	/** Returns the type of this Relation. */
+	public RelOp getRelOp()
+	{
+		return op;
+	}
+	/** Sets the value of {@code op} to {@code ro}, if {@code op} is not equal to ISCOND. */
 	public void setRelOp(RelOp ro)
 	{
-		if (this.op.equals(RelOp.ISCOND))
+		if (isCond())
 			return;
 		if (ro.equals(RelOp.ISCOND))
 		{
@@ -80,7 +112,7 @@ public class Relation extends AbstractNode implements Condition
 	@Override
 	public int size()
 	{
-		if(op == RelOp.ISCOND)
+		if(isCond())
 			return 1 + cond.size();
 		return 1 + left.size() + right.size();
 	}
@@ -92,7 +124,7 @@ public class Relation extends AbstractNode implements Condition
 			return this;
 		if(index > size() - 1 || index < 0)
 			throw new IndexOutOfBoundsException();
-		if(op == RelOp.ISCOND)
+		if(isCond())
 			return cond.nodeAt(index - 1);
 		else
 		{
@@ -106,7 +138,7 @@ public class Relation extends AbstractNode implements Condition
 	@Override
 	public Relation clone()
 	{
-		if(op == RelOp.ISCOND)
+		if(isCond())
 			return new Relation(cond.clone());
 		Expr tempLeft = left.clone();
 		Expr tempRight = right.clone();
@@ -122,7 +154,7 @@ public class Relation extends AbstractNode implements Condition
 	@Override
 	public boolean replaceChild(Node child, Node replacement)
 	{
-		if(op == RelOp.ISCOND)
+		if(isCond())
 		{
 			if(child == this.cond)
 			{
@@ -183,9 +215,9 @@ public class Relation extends AbstractNode implements Condition
 		return sb;
 	}
 	@Override
-	public boolean evaluate()
+	public boolean acceptEvaluation(Interpreter i)
 	{
-		throw new UnsupportedOperationException();
+		return i.eval(this);
 	}
 	/** An enumeration of all the accepted mathematical relational operators. */
 	public enum RelOp
diff --git a/src/main/java/ast/Rule.java b/src/main/java/ast/Rule.java
index e8c6fb9..3275487 100644
--- a/src/main/java/ast/Rule.java
+++ b/src/main/java/ast/Rule.java
@@ -17,6 +17,18 @@ public class Rule extends AbstractNode
 		comm.setParent(this);
 	}
 	
+	/** Returns the condition of this rule. */
+	public Condition getCond()
+	{
+		return cond;
+	}
+	
+	/** Returns the command of this rule. */
+	public Command getComm()
+	{
+		return comm;
+	}
+	
 	@Override
 	public int size()
 	{
diff --git a/src/main/java/ast/Sensor.java b/src/main/java/ast/Sensor.java
index f56656b..0769b29 100644
--- a/src/main/java/ast/Sensor.java
+++ b/src/main/java/ast/Sensor.java
@@ -1,12 +1,14 @@
 package ast;
 
 import java.util.Random;
+import interpret.Interpreter;
 
 /** An AST representation of a Sensor node. */
 public class Sensor extends AbstractNode implements Expr
 {
 	/** The type of this Sensor node. */
 	private SensorType type;
+	/** The sensor index of this node. Not compatible with SensorType SMELL. */
 	private Expr sensorIndex;
 	
 	/** Creates a new Sensor node with the specified type and index. Not compatible with SensorType SMELL. */
@@ -24,6 +26,21 @@ public class Sensor extends AbstractNode implements Expr
 		sensorIndex = null;
 	}
 	
+	/** Returns the type of this sensor. */
+	public SensorType getSensorType()
+	{
+		return type;
+	}
+	
+	/** 
+	 * Returns the sensor index of this sensor, if there is one.
+	 * Precondition: this sensor is not of type SMELL.
+	 */
+	public Expr getSensorIndex()
+	{
+		return sensorIndex;
+	}
+	
 	/** Sets the SensorType of this sensor node. */
 	public void setSensorType(SensorType st)
 	{
@@ -111,9 +128,9 @@ public class Sensor extends AbstractNode implements Expr
 	}
 	
 	@Override
-	public int evaluate()
+	public int acceptEvaluation(Interpreter i)
 	{
-		throw new UnsupportedOperationException();
+		return i.eval(this);
 	}
 	
 	/** An enumeration of all the possible Sensor types. */
diff --git a/src/main/java/ast/Test.java b/src/main/java/ast/Test.java
deleted file mode 100644
index b77889d..0000000
--- a/src/main/java/ast/Test.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package ast;
-
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.LinkedList;
-
-import ast.BinaryExpr;
-import ast.BinaryCondition.Operator;
-import ast.BinaryExpr.MathOp;
-import ast.Relation.RelOp;
-import ast.UnaryExpr.ExprType;
-import parse.Parser;
-import parse.ParserFactory;
-import parse.Tokenizer;
-import parsertests.ParserTest;
-
-public class Test
-{
-	public static void main(String[] args)
-	{
-		/*UnaryExpr e1 = new UnaryExpr(2);
-		UnaryExpr e2 = new UnaryExpr(12);
-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
-		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION);
-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
-		Relation r = new Relation(e4, RelOp.EQUAL, e5);
-		
-		System.out.println(r.toString());
-		System.out.println(r.size());*/
-		
-		/*UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
-		UnaryExpr e1 = new UnaryExpr(2);
-		UnaryExpr e2 = new UnaryExpr(12);
-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		ll.add(u2);
-		ll.add(u3);
-		ll.add(u4);
-		Command c = new Command(ll, u);
-		Rule rule = new Rule(con, c);
-		
-		System.out.println(rule.toString() + "\n" + rule.size() + "\n" + rule.nodeAt(13));
-		System.out.println("" + rule.size() + "\n" + con.size() + "\n" + c.size());*/
-		
-		/*Sensor s = new Sensor();
-		System.out.println(s.nodeAt(0).toString());*/
-		
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
-        Reader r = new BufferedReader(new InputStreamReader(in));
-        Tokenizer t = new Tokenizer(r);
-        Parser p = ParserFactory.getParser();
-        Program prog = p.parse(r);
-        System.out.println(prog.toString());
-        
-        Program pclone = (Program) prog.clone();
-        System.out.println(pclone.toString());
-        pclone = null;
-        System.out.println(prog.toString());
-        
-		
-		/*Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		System.out.println(u.size() + "\n" + u.nodeAt(0) + "\nmem[" + u.nodeAt(1) + "] := " + u.nodeAt(2));
-		UnaryExpr e1 = new UnaryExpr(new UnaryExpr(5), ExprType.NEGATION);
-		System.out.println(e1.size() + "\n" + e1.nodeAt(1));
-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
-		System.out.println(e5.size() + "\n" + e5.nodeAt(0));*/
-		
-		
-	}
-}
diff --git a/src/main/java/ast/TestMutations.java b/src/main/java/ast/TestMutations.java
deleted file mode 100644
index 74fdb33..0000000
--- a/src/main/java/ast/TestMutations.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package ast;
-
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.LinkedList;
-
-import ast.BinaryCondition.Operator;
-import ast.BinaryExpr.MathOp;
-import ast.Relation.RelOp;
-import ast.UnaryExpr.ExprType;
-import parse.Parser;
-import parse.ParserFactory;
-import parse.Tokenizer;
-import parsertests.ParserTest;
-
-public class TestMutations
-{
-	public static void main(String[] args)
-	{
-		/*
-		UnaryExpr e = new UnaryExpr(5);
-		
-		BinaryExpr be = new BinaryExpr(e, MathOp.DIVIDE, new UnaryExpr(7));
-		System.out.println(be.toString());
-		be.acceptMutation(new MutationSwap());
-		System.out.println(be.toString());
-		System.out.println(be.toString());
-		be.acceptMutation(new MutationSwap());
-		System.out.println(be.toString());
-		
-		Update u = new Update(new UnaryExpr(2), new UnaryExpr(9));
-		System.out.println(u.toString());
-		u.acceptMutation(new MutationSwap());
-		System.out.println(u.toString());
-		
-		System.out.println(u.getClass().getSimpleName());
-		System.out.println(be.getClass().getSimpleName());*/
-		
-		
-		
-		//System.out.println(e.getParent().toString());
-		
-		/*Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
-		UnaryExpr e1 = new UnaryExpr(2);
-		UnaryExpr e2 = new UnaryExpr(12);
-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
-		Command c = new Command(ll, u6);
-		Rule r = new Rule(con, c);
-		System.out.println(c.toString() + "\n");
-		c.acceptMutation(new MutationSwap());
-		System.out.println(c.toString() + "\n");
-		
-		//u6.acceptMutation(new MutationRemove());
-		//System.out.println(c.toString());
-		
-		c.acceptMutation(new MutationDuplicate());
-		System.out.println(c.toString());*/
-		
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
-        Reader r = new BufferedReader(new InputStreamReader(in));
-        Tokenizer t = new Tokenizer(r);
-        Parser p = ParserFactory.getParser();
-        Program prog = p.parse(r);
-        
-        System.out.println(prog.mutate());
-        
-        //for(int i = 0; i < prog.size(); i++)
-			//try
-			{
-			//	System.out.println("Index #" + i + ": " + prog.nodeAt(i));
-			}
-			//catch (IndexOutOfBoundsException e)
-			{
-				//System.out.println("NODEAT FAILED");
-			}
-        
-        //int n = (int) (Math.random() * (prog.size() - 1));
-        //for(int i = 0; i < prog.size(); i++)
-			//try
-			//{
-				//System.out.println(prog.mutate(n, new MutationInsert()).toString());
-			//}
-			//catch (NullPointerException e)
-			//{
-				//System.out.println("Incompatible node type");
-			//}
-		
-	}
-}
\ No newline at end of file
diff --git a/src/main/java/ast/UnaryExpr.java b/src/main/java/ast/UnaryExpr.java
index a749244..8493bca 100644
--- a/src/main/java/ast/UnaryExpr.java
+++ b/src/main/java/ast/UnaryExpr.java
@@ -1,5 +1,7 @@
 package ast;
 
+import interpret.Interpreter;
+
 /** A representation of a unary numerical expression that evaluates to an integer. */
 public class UnaryExpr extends AbstractNode implements Expr
 {
@@ -7,6 +9,7 @@ public class UnaryExpr extends AbstractNode implements Expr
 	private ExprType type;
 	/** The subexpression that this unary expression is based off of. May be null. */
 	private Expr exp;
+	/** The integer value contained in this unary expression, if it has one. Only applies to expressions of type CONSTANT. */
 	private int value;
 	
 	/** 
@@ -32,6 +35,32 @@ public class UnaryExpr extends AbstractNode implements Expr
 		this.type = ExprType.CONSTANT;
 	}
 	
+	/** Returns the type of this unary expression. */
+	public ExprType getExprType()
+	{
+		return type;
+	}
+	
+	/**
+	 * Returns the integer value contained in this unary expression.
+	 * Precondition: the type of this expression must be CONSTANT.
+	 */
+	public int getValue()
+	{
+		return value;
+	}
+	/** Sets the value of {@code value} to {@code val}. */
+	public void setValue(int val)
+	{
+		this.exp = null;
+		this.value = val;
+		this.type = ExprType.CONSTANT;
+	}
+	
+	public Expr getExp()
+	{
+		return exp;
+	}
 	@Override
 	public int size()
 	{
@@ -101,24 +130,20 @@ public class UnaryExpr extends AbstractNode implements Expr
 			case NEGATION:
 				sb.append("-" + exp.toString());
 				break;
-			case SENSORVAL:
-				//if this UnaryExpr has the type of SENSORVAL, then the class type of exp should be Sensor
-				sb.append(exp.toString());
-				break;
 		}
 		return sb;
 	}
 	
 	@Override
-	public int evaluate()
+	public int acceptEvaluation(Interpreter i)
 	{
-		throw new UnsupportedOperationException();
+		return i.eval(this);
 	}
 	
 	/** An enumeration of all the possible unary expression types. */
 	public enum ExprType
 	{
-		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION, SENSORVAL;
+		CONSTANT, MEMORYVAL, EXPRESSION, NEGATION;
 	}
 
 	@Override
@@ -126,10 +151,4 @@ public class UnaryExpr extends AbstractNode implements Expr
 	{
 		return NodeType.UNARYEXPR;
 	}
-	
-	public void setValue(int value) {
-		this.exp = null;
-		this.value = value;
-		this.type = ExprType.CONSTANT;
-	}
 }
\ No newline at end of file
diff --git a/src/main/java/ast/Update.java b/src/main/java/ast/Update.java
index a47ebfa..141a459 100644
--- a/src/main/java/ast/Update.java
+++ b/src/main/java/ast/Update.java
@@ -22,18 +22,25 @@ public class Update extends AbstractNode implements CommandComponent
 		value.setParent(this);
 	}
 	
+	/** Returns the memory index of this update. */
 	public Expr getMemIndex()
 	{
 		return memIndex;
 	}
+	
+	/** Sets the value of {@code memIndex} to {@code newIndex}. */
 	public void setMemIndex(Expr newIndex)
 	{
 		this.memIndex = newIndex;
 	}
+	
+	/** Returns the new value to be set for this update. */
 	public Expr getValue()
 	{
 		return value;
 	}
+	
+	/** Sets the value of {@code value} to {@code newVal}. */
 	public void setValue(Expr newVal)
 	{
 		this.value = newVal;
diff --git a/src/main/java/console/Console.java b/src/main/java/console/Console.java
index 89f4bec..ca92071 100644
--- a/src/main/java/console/Console.java
+++ b/src/main/java/console/Console.java
@@ -1,222 +1,311 @@
 package console;
 
-import java.io.InputStream;
-import java.io.PrintStream;
+import java.io.*;
 import java.util.Scanner;
 
-/**
- * The console user interface for Assignment 5.
- */
-public class Console {
-    private Scanner scan;
-    public boolean done;
-    public PrintStream out;
-
-    /* =========================== */
-    /* DO NOT EDIT ABOVE THIS LINE */
-    /* (except imports...)         */
-    /* =========================== */
-
-    //TODO world representation...
-
-    /**
-     * Starts new random world simulation.
-     */
-    public void newWorld() {
-        //TODO implement
-    }
-
-    /**
-     * Starts new simulation with world specified in filename.
-     *
-     * @param filename
-     */
-    public void loadWorld(String filename) {
-        //TODO implement
-    }
-
-    /**
-     * Loads critter definition from filename and randomly places
-     * n critters with that definition into the world.
-     *
-     * @param filename
-     * @param n
-     */
-    public void loadCritters(String filename, int n) {
-        //TODO implement
-    }
-
-    /**
-     * Advances the world by n time steps.
-     *
-     * @param n
-     */
-    public void advanceTime(int n) {
-        //TODO implement
-    }
-
-    /**
-     * Prints current time step, number of critters, and world
-     * map of the simulation.
-     */
-    public void worldInfo() {
-        //TODO implement
-        worldInfo(0, 0);
-    }
-
-    /**
-     * Prints description of the contents of hex (c,r).
-     *
-     * @param c column of hex
-     * @param r row of hex
-     */
-    public void hexInfo(int c, int r) {
-        //TODO implement and call appropriate method
-
-        critterInfo(null, null, null, null);
-        // OR
-//        terrainInfo(0);
-    }
-
-    /* =========================== */
-    /* DO NOT EDIT BELOW THIS LINE */
-    /* =========================== */
-
-    /**
-     * Be sure to call this function, we will override it to grade.
-     *
-     * @param numSteps      The number of steps that have passed in the world.
-     * @param crittersAlive The number of critters currently alive.
-     */
-    protected void worldInfo(int numSteps, int crittersAlive) {
-        out.println("steps: " + numSteps);
-        out.println("critters: " + crittersAlive);
-    }
-
-    /**
-     * Be sure to call this function, we will override it to grade.
-     *
-     * @param species  The species of the critter.
-     * @param mem      The memory of the critter.
-     * @param program  The program of the critter pretty printed as a String. This should be able to be parsed back to
-     *                 the same AST.
-     * @param lastrule The last rule executed by the critter pretty printed as a String. This should be able to be
-     *                 parsed back to the same AST. If no rule has been executed, this parameter should be null.
-     */
-    protected void critterInfo(String species, int[] mem, String program, String lastrule) {
-        out.println("Species: " + species);
-        StringBuilder sbmem = new StringBuilder();
-        for (int i : mem) {
-            sbmem.append(" ").append(i);
-        }
-        out.println("Memory:" + sbmem.toString());
-        out.println("Program: " + program);
-        out.println("Last rule: " + lastrule);
-    }
-
-    /**
-     * Be sure to call this function, we will override it to grade.
-     *
-     * @param terrain 0 is empty, -1 is rock, -X is (X-1) food
-     */
-    protected void terrainInfo(int terrain) {
-        if (terrain == 0) {
-            out.println("Empty");
-        } else if (terrain == -1) {
-            out.println("Rock");
-        } else {
-            out.println("Food: " + (-terrain - 1));
-        }
-    }
-
-    /**
-     * Prints a list of possible commands to the standard output.
-     */
-    public void printHelp() {
-        out.println("new: start a new simulation with a random world");
-        out.println("load <world_file>: start a new simulation with "
-                + "the world loaded from world_file");
-        out.println("critters <critter_file> <n>: add n critters "
-                + "defined by critter_file randomly into the world");
-        out.println("step <n>: advance the world by n timesteps");
-        out.println("info: print current timestep, number of critters "
-                + "living, and map of world");
-        out.println("hex <c> <r>: print contents of hex "
-                + "at column c, row r");
-        out.println("exit: exit the program");
-    }
-
-    /**
-     * Constructs a new Console capable of reading a given input.
-     */
-    public Console(InputStream in, PrintStream out) {
-        this.out = out;
-        scan = new Scanner(in);
-        done = false;
-    }
-
-    /**
-     * Constructs a new Console capable of reading the standard input.
-     */
-    public Console() {
-        this(System.in, System.out);
-    }
-
-    /**
-     * Processes a single console command provided by the user.
-     */
-    public void handleCommand() {
-        out.print("Enter a command or \"help\" for a list of commands.\n> ");
-        String command = scan.next();
-        switch (command) {
-            case "new": {
-                newWorld();
-                break;
-            }
-            case "load": {
-                String filename = scan.next();
-                loadWorld(filename);
-                break;
-            }
-            case "critters": {
-                String filename = scan.next();
-                int n = scan.nextInt();
-                loadCritters(filename, n);
-                break;
-            }
-            case "step": {
-                int n = scan.nextInt();
-                advanceTime(n);
-                break;
-            }
-            case "info": {
-                worldInfo();
-                break;
-            }
-            case "hex": {
-                int c = scan.nextInt();
-                int r = scan.nextInt();
-                hexInfo(c, r);
-                break;
-            }
-            case "help": {
-                printHelp();
-                break;
-            }
-            case "exit": {
-                done = true;
-                break;
-            }
-            default:
-                out.println(command + " is not a valid command.");
-        }
-    }
-
-    public static void main(String[] args) {
-        Console console = new Console();
-        while (!console.done) {
-            console.handleCommand();
-        }
-    }
+import simulation.SimpleCritter;
+import simulation.SimpleWorld;
+import simulation.World;
+
+/** The console user interface for Assignment 5. */
+public class Console
+{
+	private Scanner scan;
+	public boolean done;
+	public PrintStream out;
+
+	/* =========================== */
+	/* DO NOT EDIT ABOVE THIS LINE */
+	/* (except imports...) */
+	/* =========================== */
+
+	// TODO world representation...
+	private SimpleWorld world;
+
+	/** Starts new random world simulation. */
+	public void newWorld()
+	{
+		try
+		{
+			world = new World();
+		}
+		catch (IllegalArgumentException i)
+		{
+			System.err.println("The constants.txt file could not be read. Please check if it exists or is formatted properly.");
+		}
+	}
+
+	/**
+	 * Starts new simulation with world specified in filename.
+	 * @param filename
+	 */
+	public void loadWorld(String filename)
+	{
+		try
+		{
+			world = new World(filename);
+		}
+		catch (FileNotFoundException f)
+		{
+			System.err.println("World file not found. Loading defaultly generated world...");
+			world = new World();
+		}
+		catch (IllegalArgumentException i)
+		{
+			System.err.println("The constants.txt file could not be read. Please check if it is formatted properly.");
+			System.exit(0);
+		}
+	}
+
+	/**
+	 * Loads critter definition from {@code filename} and randomly places n critters with that definition into the world.
+	 * If the file cannot be found, this method prints an error message and loads 0 critters. If the file contains invalid
+	 * attributes, critters are supplied with default memory values. A full list of default critter memory values can be
+	 * found in our overview document.
+	 *
+	 * @param filename
+	 * @param n
+	 */
+	public void loadCritters(String filename, int n)
+	{
+		//This method can't do anything if no world has been created yet.
+		if(world == null)
+		{
+			System.err.println("You must first create a world before you load critters into it.");
+			printHelp();
+			return;
+		}
+		
+		world.loadCritters(filename, n, -1);
+	}
+
+	/**
+	 * Advances the world by n time steps.
+	 * @param n
+	 */
+	public void advanceTime(int n)
+	{
+		//This method can't do anything if no world has been created yet.
+		if(world == null)
+		{
+			System.err.println("You must first create a world before you advance time in it.");
+			printHelp();
+			return;
+		}
+		for(int i = 0; i < n; i++)
+			world.advanceOneTimeStep();
+	}
+
+	/** Prints current time step, number of critters, and world map of the simulation. */
+	public void worldInfo()
+	{
+		//This method can't do anything if no world has been created yet.
+		if(world == null)
+		{
+			System.err.println("You must first create a world before you can view its information.");
+			printHelp();
+			return;
+		}
+		
+		out.println(world.printGrid().toString());
+		worldInfo(world.getTimePassed(), crittersAlive());
+	}
+
+	/** Returns the number of critters still alive. Useful for testing purposes. */
+	public int crittersAlive()
+	{
+		if(world == null)
+			return Integer.MIN_VALUE;
+		return world.numRemainingCritters();
+	}
+	
+	/**
+	 * Prints description of the contents of hex (c,r).
+	 *
+	 * @param c column of hex
+	 * @param r row of hex
+	 */
+	public void hexInfo(int c, int r)
+	{
+		//This method can't do anything if no world has been created yet.
+		if(world == null)
+		{
+			System.err.println("You must first create a world before you can view its information.");
+			printHelp();
+			return;
+		}
+		
+		if(!world.isValidHex(c, r))
+		{
+			System.err.println("Invalid world coordinates.");
+			return;
+		}
+		
+		SimpleCritter sc;
+		int hexAnalysis = world.analyzeHex(c, r);
+		if(hexAnalysis <= 0)
+			terrainInfo(hexAnalysis);
+		
+		sc = world.analyzeCritter(c, r);
+		if(sc == null)
+			return;
+		
+		critterInfo(sc.getName(), sc.getMemoryCopy(), sc.getProgram().toString(), sc.getLastRule());
+	}
+
+	/* =========================== */
+	/* DO NOT EDIT BELOW THIS LINE */
+	/* =========================== */
+
+	/**
+	 * Be sure to call this function, we will override it to grade.
+	 *
+	 * @param numSteps
+	 *            The number of steps that have passed in the world.
+	 * @param crittersAlive
+	 *            The number of critters currently alive.
+	 */
+	protected void worldInfo(int numSteps, int crittersAlive)
+	{
+		out.println("steps: " + numSteps);
+		out.println("critters: " + crittersAlive);
+	}
+
+	/**
+	 * Be sure to call this function, we will override it to grade.
+	 *
+	 * @param species
+	 *            The species of the critter.
+	 * @param mem
+	 *            The memory of the critter.
+	 * @param program
+	 *            The program of the critter pretty printed as a String. This should
+	 *            be able to be parsed back to the same AST.
+	 * @param lastrule
+	 *            The last rule executed by the critter pretty printed as a String.
+	 *            This should be able to be parsed back to the same AST. If no rule
+	 *            has been executed, this parameter should be null.
+	 */
+	protected void critterInfo(String species, int[] mem, String program, String lastrule)
+	{
+		out.println("Species: " + species);
+		StringBuilder sbmem = new StringBuilder();
+		for (int i : mem)
+		{
+			sbmem.append(" ").append(i);
+		}
+		out.println("Memory:" + sbmem.toString());
+		out.println("Program: " + program);
+		out.println("Last rule: " + lastrule);
+	}
+
+	/**
+	 * Be sure to call this function, we will override it to grade.
+	 *
+	 * @param terrain
+	 *            0 is empty, -1 is rock, -X is (X-1) food
+	 */
+	protected void terrainInfo(int terrain)
+	{
+		if (terrain == 0)
+			out.println("Empty");
+		else if (terrain == -1)
+			out.println("Rock");
+		else
+			out.println("Food: " + (-terrain - 1));
+	}
+
+	/** Prints a list of possible commands to the standard output. */
+	public void printHelp()
+	{
+		out.println("new: start a new simulation with a random world");
+		out.println("load <world_file>: start a new simulation with " + "the world loaded from world_file");
+		out.println("critters <critter_file> <n>: add n critters " + "defined by critter_file randomly into the world");
+		out.println("step <n>: advance the world by n timesteps");
+		out.println("info: print current timestep, number of critters " + "living, and map of world");
+		out.println("hex <c> <r>: print contents of hex " + "at column c, row r");
+		out.println("exit: exit the program");
+	}
+
+	/** Constructs a new Console capable of reading a given input. */
+	public Console(InputStream in, PrintStream out)
+	{
+		this.out = out;
+		scan = new Scanner(in);
+		done = false;
+	}
+
+	/** Constructs a new Console capable of reading the standard input. */
+	public Console()
+	{
+		this(System.in, System.out);
+	}
+
+	/** Processes a single console command provided by the user. */
+	public void handleCommand()
+	{
+		out.print("Enter a command or \"help\" for a list of commands.\n> ");
+		String command = scan.next();
+		switch (command)
+		{
+			case "new":
+			{
+				newWorld();
+				break;
+			}
+			case "load":
+			{
+				String filename = scan.next();
+				loadWorld(filename);
+				break;
+			}
+			case "critters":
+			{
+				String filename = scan.next();
+				int n = scan.nextInt();
+				loadCritters(filename, n);
+				break;
+			}
+			case "step":
+			{
+				int n = scan.nextInt();
+				advanceTime(n);
+				break;
+			}
+			case "info":
+			{
+				worldInfo();
+				break;
+			}
+			case "hex":
+			{
+				int c = scan.nextInt();
+				int r = scan.nextInt();
+				hexInfo(c, r);
+				break;
+			}
+			case "help":
+			{
+				printHelp();
+				break;
+			}
+			case "exit":
+			{
+				done = true;
+				break;
+			}
+			default:
+				out.println(command + " is not a valid command.");
+		}
+	}
+
+	public static void main(String[] args)
+	{
+		Console console = new Console();
+		while (!console.done)
+		{
+			console.handleCommand();
+		}
+	}
 
 }
diff --git a/src/main/java/interpret/Interpreter.java b/src/main/java/interpret/Interpreter.java
index e205039..1a57929 100644
--- a/src/main/java/interpret/Interpreter.java
+++ b/src/main/java/interpret/Interpreter.java
@@ -1,36 +1,52 @@
 package interpret;
 
-import ast.Condition;
-import ast.Expr;
-import ast.Program;
+import ast.BinaryCondition;
+import ast.Relation;
+import ast.BinaryExpr;
+import ast.UnaryExpr;
+import ast.Sensor;
 
 /**
  * An example interface for interpreting a critter program. This is just a starting
  * point and may be changed as much as you like.
  */
-public interface Interpreter {
+public interface Interpreter
+{
+	/** Executes the results of one critter turn. */
+	public void simulateCritterTurn();
+
     /**
-     * Execute program {@code p} until either the maximum number of rules per
-     * turn is reached or some rule whose command contains an action is
-     * executed.
-     * @param p
-     * @return a result containing the action to be performed;
-     * the action may be null if the maximum number of rules
-     * per turn was exceeded.
+     * Evaluates the given binary condition.
+     * @param c
+     * @return a boolean that results from evaluating c.
      */
-    Outcome interpret(Program p);
-
+    boolean eval(BinaryCondition c);
+    
     /**
-     * Evaluate the given condition.
+     * Evaluates the given relation.
      * @param c
      * @return a boolean that results from evaluating c.
      */
-    boolean eval(Condition c);
+    boolean eval(Relation c);
 
     /**
-     * Evaluate the given expression.
+     * Evaluates the given binary expression.
+     * @param e
+     * @return an integer that results from evaluating e.
+     */
+    int eval(BinaryExpr e);
+    
+    /**
+     * Evaluates the given unary expression.
+     * @param e
+     * @return an integer that results from evaluating e.
+     */
+    int eval(UnaryExpr e);
+    
+    /**
+     * Evaluates the given sensor.
      * @param e
      * @return an integer that results from evaluating e.
      */
-    int eval(Expr e);
+    int eval(Sensor s);
 }
diff --git a/src/main/java/interpret/InterpreterImpl.java b/src/main/java/interpret/InterpreterImpl.java
new file mode 100644
index 0000000..18973a1
--- /dev/null
+++ b/src/main/java/interpret/InterpreterImpl.java
@@ -0,0 +1,265 @@
+package interpret;
+
+import ast.*;
+import ast.Action.ActType;
+import ast.Node.NodeType;
+import simulation.AbstractWorld;
+import simulation.SimpleCritter;
+
+import java.util.LinkedList;
+
+/** Interprets and executes the AST of a critter. */
+public class InterpreterImpl implements Interpreter
+{
+	/** The critter whose AST this Interpreter interprets. */
+	private SimpleCritter c;
+	/** The world in which the critter inhabits. */
+	private AbstractWorld world;
+	
+	/** Creates a new InterpreterImpl. */
+	public InterpreterImpl(SimpleCritter cr, AbstractWorld aw)
+	{
+		c = cr;
+		world = aw;
+	}
+	
+	/** Executes the results of one critter turn. */
+	public void simulateCritterTurn()
+	{
+		Action a = interpret(c.getProgram());
+		executeAction(a);
+	}
+	
+	/**
+     * Execute program {@code p} until either the maximum number of rules per turn is reached or some rule
+     * whose command contains an action is executed.
+     * @param p
+     * @return the action to be performed
+     */
+	private Action interpret(Program p)
+	{
+		LinkedList<Rule> rl = p.getRulesList();
+		Action a = null;
+		boolean actionInterpreted = false;
+		while (!actionInterpreted && c.readMemory(5) < world.getMaxRules())
+		{
+			for (Rule r : rl)
+			{
+				boolean ruleCondition = r.getCond().acceptEvaluation(this);
+				if(ruleCondition)
+				{
+					Command ruleCommand = r.getComm();
+					for(Update u : ruleCommand.getUpdateList())
+						applyUpdate(u);
+					if(ruleCommand.getLast().getType() == NodeType.ACTION)
+					{
+						a = (Action) ruleCommand.getLast();
+						actionInterpreted = true;
+					}
+					else
+						applyUpdate((Update) ruleCommand.getLast());
+					c.setLastRule(r.toString());
+					break;
+				}
+			}
+			c.incrementPass();
+		}
+		c.setMemory(0, 5);
+		
+		if(a == null)
+			a = new Action(ActType.WAIT);
+		return a;
+	}
+	
+	/** Executes an action returned by the {@code interpret} method. */
+	private void executeAction(Action a)
+	{
+		int val = 0;
+		if(a.getVal() != null)
+			val = a.getVal().acceptEvaluation(this);
+		
+		switch(a.getActType())
+		{
+			case FORWARD:
+				world.moveCritter(c, true);
+				break;
+			case BACKWARD:
+				world.moveCritter(c, false);
+				break;
+			case LEFT:
+				world.turnCritter(c, false);
+				break;
+			case RIGHT:
+				world.turnCritter(c, true);
+				break;
+			case EAT:
+				world.critterEat(c);
+				break;
+			case ATTACK:
+				world.critterBattle(c);
+				break;
+			case GROW:
+				world.growCritter(c);
+				break;
+			case BUD:
+				world.critterBud(c);
+				break;
+			case MATE:
+				world.critterMate(c);
+				break;
+			case TAG:
+				world.critterTag(c, val);
+				break;
+			case SERVE:
+				world.critterServe(c, val);
+				break;
+			case WAIT:
+				world.critterSoakEnergy(c);
+				break;
+		}
+	}
+	/** Applies the effects of a single update to a critter. */
+	private void applyUpdate(Update u)
+	{
+		int index = u.getMemIndex().acceptEvaluation(this);
+		int val = u.getValue().acceptEvaluation(this);
+		c.setMemory(val, index);
+	}
+
+	@Override
+	public boolean eval(BinaryCondition c)
+	{
+		boolean result = false;
+		boolean left = c.getLeft().acceptEvaluation(this);
+		boolean right = c.getRight().acceptEvaluation(this);
+		switch(c.getOp())
+		{
+			case AND:
+				result = left && right;
+				break;
+			case OR:
+				result = left || right;
+				break;
+		}
+		return result;
+	}
+	
+	@Override
+	public boolean eval(Relation r)
+	{
+		boolean result = false;
+		if(r.getCond() != null)
+		{
+			result = r.getCond().acceptEvaluation(this);
+			return result;
+		}
+		int left = r.getLeft().acceptEvaluation(this);
+		int right = r.getRight().acceptEvaluation(this);
+		switch(r.getRelOp())
+		{
+			case LESS:
+				result = left < right;
+				break;
+			case LESSOREQ:
+				result = left <= right;
+				break;
+			case GREATER:
+				result = left > right;
+				break;
+			case GREATEROREQ:
+				result = left >= right;
+				break;
+			case EQUAL:
+				result = left == right;
+				break;
+			case NOTEQUAL:
+				result = left != right;
+				break;
+			case ISCOND:
+				result = r.getCond().acceptEvaluation(this);
+				break;
+		}
+		return result;
+	}
+	
+	@Override
+	public int eval(BinaryExpr e)
+	{
+		int result = 0;
+		int left = e.getLeft().acceptEvaluation(this);
+		int right = e.getRight().acceptEvaluation(this);
+		switch(e.getOperator())
+		{
+			case ADD:
+				result = left + right;
+				break;
+			case SUBTRACT:
+				result = left - right;
+				break;
+			case MULTIPLY:
+				result = left * right;
+				break;
+			case DIVIDE:
+				if(right != 0)
+					result = left / right;
+				break;
+			case MOD:
+				if(right != 0)
+					result = left % right;
+				break;
+		}
+		return result;
+	}
+	
+	@Override
+	public int eval(UnaryExpr e)
+	{
+		int result = 0;
+		switch(e.getExprType())
+		{
+			case CONSTANT:
+				result = e.getValue();
+				break;
+			case MEMORYVAL:
+				int index = e.getExp().acceptEvaluation(this);
+				result = c.readMemory(index);
+				if(result == Integer.MIN_VALUE)
+					result = 0;
+				break;
+			case EXPRESSION:
+				result = e.getExp().acceptEvaluation(this);
+				break;
+			case NEGATION:
+				result = -1 * e.getExp().acceptEvaluation(this);
+				break;
+		}
+		return result;
+	}
+	
+	@Override
+	public int eval(Sensor s)
+	{
+		int result = 0;
+		int index;
+		switch(s.getSensorType())
+		{
+			case NEARBY:
+				index = s.getSensorIndex().acceptEvaluation(this);
+				result = world.searchNearby(c, index);
+				break;
+			case AHEAD:
+				index = s.getSensorIndex().acceptEvaluation(this);
+				result = world.searchAhead(c, index);
+				break;
+			case RANDOM:
+				index = s.getSensorIndex().acceptEvaluation(this);
+				if(index < 2)
+					result = 0;
+				else
+					result = (int) (Math.random() * index);
+			case SMELL:
+				result = 0;
+		}
+		return result;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/interpret/Outcome.java b/src/main/java/interpret/Outcome.java
deleted file mode 100644
index 6f6ea20..0000000
--- a/src/main/java/interpret/Outcome.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package interpret;
-
-/**
- * An example interface for representing an outcome of interpreting
- * a critter program.
- */
-public interface Outcome {
-    // TODO define appropriate operations
-}
diff --git a/src/main/java/parse/ParserImpl.java b/src/main/java/parse/ParserImpl.java
index a702d28..0d04293 100644
--- a/src/main/java/parse/ParserImpl.java
+++ b/src/main/java/parse/ParserImpl.java
@@ -18,10 +18,10 @@ class ParserImpl implements Parser {
 	public Program parse(Reader r) {
 		this.tokens = new Tokenizer(r);
 		try {
-			this.programAST = parseProgram(tokens);
-		} catch (SyntaxError e) {
-			System.out.println("The program inputted does not have the proper syntax.");
-			System.exit(0);
+			programAST = parseProgram(tokens);
+		}
+		catch (SyntaxError e) {
+			programAST = null;
 		}
 
 		return this.programAST;
@@ -39,7 +39,9 @@ class ParserImpl implements Parser {
 	public static ProgramImpl parseProgram(Tokenizer t) throws SyntaxError {
 		LinkedList<Rule> RuleList = new LinkedList<Rule>();
 		while (t.hasNext()) {
-			RuleList.add(parseRule(t));
+			Rule r = parseRule(t);
+			RuleList.add(r);
+			
 		}
 		return new ProgramImpl(RuleList);
 	}
@@ -49,7 +51,6 @@ class ParserImpl implements Parser {
 		consume(t, TokenType.ARR);
 		Command command = parseCommand(t);
 		consume(t, TokenType.SEMICOLON);
-		//System.out.println((new Rule(condition, command)).toString()); //TODO remove when done tesing
 		return new Rule(condition, command);
 	}
 	
@@ -174,7 +175,6 @@ class ParserImpl implements Parser {
 		Condition conj = parseConjunction(t);
 		while (t.peek().getType() == TokenType.OR) {
 			consume(t, TokenType.OR);
-			//System.out.println((new BinaryCondition(conj, Operator.OR, parseConjunction(t)).toString())); //TODO remove when done
 			return new BinaryCondition(conj, Operator.OR, parseConjunction(t));
 		}
 		return conj;
@@ -186,7 +186,6 @@ class ParserImpl implements Parser {
 			consume(t, TokenType.AND);
 			return new BinaryCondition(rel, Operator.AND, parseRelation(t));
 		}
-		//System.out.println(condition.toString());
 		return rel;
 	}
 	public static Relation parseRelation(Tokenizer t) throws SyntaxError {
@@ -200,8 +199,6 @@ class ParserImpl implements Parser {
 		}
 		
 		Expr expression = parseExpression(t);
-		//System.out.println(expression.toString());
-		//Condition condition;
 		if (t.peek().getType().category() == TokenCategory.RELOP) {
 			String relationOperator = t.peek().toString();
 			consume(t, t.peek().getType());
diff --git a/src/main/java/parse/Token.java b/src/main/java/parse/Token.java
index a1f023e..2ba46cf 100644
--- a/src/main/java/parse/Token.java
+++ b/src/main/java/parse/Token.java
@@ -186,8 +186,8 @@ class Token {
 		 * Constructs a new error token containing the value {@code v}.
 		 * @param v - String value for this error token.
 		 */
-		ErrorToken(String v) {
-			super(TokenType.ERROR, -1);
+		ErrorToken(String v, int lineNo) {
+			super(TokenType.ERROR, lineNo);
 			value = v;
 		}
 
diff --git a/src/main/java/parse/Tokenizer.java b/src/main/java/parse/Tokenizer.java
index 384ab04..8547ada 100644
--- a/src/main/java/parse/Tokenizer.java
+++ b/src/main/java/parse/Tokenizer.java
@@ -1,510 +1,460 @@
 package parse;
 
+import static parse.TokenType.ARR;
+import static parse.TokenType.ASSIGN;
+import static parse.TokenType.DIV;
+import static parse.TokenType.EQ;
+import static parse.TokenType.GE;
+import static parse.TokenType.GT;
+import static parse.TokenType.LBRACE;
+import static parse.TokenType.LBRACKET;
+import static parse.TokenType.LE;
+import static parse.TokenType.LPAREN;
+import static parse.TokenType.LT;
+import static parse.TokenType.MINUS;
+import static parse.TokenType.MUL;
+import static parse.TokenType.NE;
+import static parse.TokenType.PLUS;
+import static parse.TokenType.RBRACE;
+import static parse.TokenType.RBRACKET;
+import static parse.TokenType.RPAREN;
+import static parse.TokenType.SEMICOLON;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Iterator;
 
+import parse.Token.EOFToken;
+import parse.Token.ErrorToken;
+import parse.Token.NumToken;
+
 /**
  * A Tokenizer turns a Reader into a stream of tokens that can be iterated over
  * using a {@code for} loop.
  */
 public class Tokenizer implements Iterator<Token> {
 
-	/**
-	 * BufferedReader to read from the {@code Reader} provided in the constructor,
-	 * not {@code null}.
-	 */
-	private final BufferedReader br;
-
-	/** Builder to store read characters. */
-	private final StringBuilder sb;
-
-	/**
-	 * The number of the line being parsed from the reader. Starts at 1 and always
-	 * equals 1 + the number of new line characters encountered.
-	 */
-	private int lineNo;
-
-	/**
-	 * {@code tokenReady} is {@code false} if a token is not immediately available
-	 * to be returned from {@code next()}, and {@code true} if a token is
-	 * immediately ready to be returned from {@code next()}.
-	 */
-	private boolean tokenReady;
-
-	/**
-	 * The most recent token processed by this Tokenizer, or an error token. Not
-	 * {@code null}.
-	 */
-	private Token curTok;
-
-	/**
-	 * {@code false} if the EOF has not been encountered, {@code true} if it has
-	 * been encountered
-	 */
-	private boolean atEOF;
-
-	/**
-	 * Create a Tokenizer that reads from the specified reader
-	 * 
-	 * @param r
-	 *            - The source from which the Tokenizer lexes input into Tokens
-	 */
-	public Tokenizer(Reader r) {
-		br = new BufferedReader(r);
-		sb = new StringBuilder();
-		lineNo = 1;
-		tokenReady = false;
-		curTok = new Token.ErrorToken("Tokenizer has not yet begun reading");
-		atEOF = false;
-	}
-
-	/**
-	 * Returns {@code true} if the iteration has more meaningful elements. (In other
-	 * words, returns {@code true} if {@link #next} would return a non-EOF element
-	 * rather than throwing an exception or returning EOF.)
-	 *
-	 * @return {@code true} if the iteration has more meaningful elements
-	 */
-	@Override
-	public boolean hasNext() {
-		if (!tokenReady) {
-			try {
-				lexOneToken();
-			} catch (IOException e) {
-				throw new TokenizerIOException(e);
-			} catch (EOFException e) {
-				return false;
-			}
-		}
-		return true;
-	}
-
-	@Override
-	public Token next() throws TokenizerIOException {
-		Token tok = peek();
-		tokenReady = false;
-		return tok;
-	}
-
-	/**
-	 * Return the next token in the program without consuming the token.
-	 *
-	 * @return the next token, without consuming it
-	 * @throws IOException
-	 *             if an IOException was thrown while trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF was encountered while trying to lex the next token
-	 */
-	public Token peek() throws TokenizerIOException {
-		if (!tokenReady && !atEOF) {
-			try {
-				lexOneToken();
-			} catch (IOException e) {
-				throw new TokenizerIOException(e);
-			} catch (EOFException e) {
-				// EOFException is thrown by encounteredEOF(), which should set
-				// curTok to an EOFToken, so this catch block should be empty.
-			}
-		}
-		return curTok;
-	}
-
-	@Override
-	public void remove() {
-		tokenReady = false;
-	}
-
-	/** Close the reader opened by this tokenizer. */
-	void close() {
-		try {
-			br.close();
-		} catch (IOException e) {
-			System.out.println("IOException:");
-			System.out.println(e.getMessage());
-			e.printStackTrace();
-		}
-	}
-
-	/**
-	 * Read one token from the reader. One token is always produced if the end of
-	 * file is not encountered, but that token may be an error token.
-	 *
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexOneToken() throws IOException, EOFException {
-		setBuilderToFirstMeaningfulChar();
-		char c = sb.charAt(0);
-
-		switch (c) {
-		case '[':
-			setNextTokenAndReset(TokenType.LBRACKET);
-			break;
-		case ']':
-			setNextTokenAndReset(TokenType.RBRACKET);
-			break;
-		case '(':
-			setNextTokenAndReset(TokenType.LPAREN);
-			break;
-		case ')':
-			setNextTokenAndReset(TokenType.RPAREN);
-			break;
-		case '{':
-			setNextTokenAndReset(TokenType.LBRACE);
-			break;
-		case '}':
-			setNextTokenAndReset(TokenType.RBRACE);
-			break;
-		case ';':
-			setNextTokenAndReset(TokenType.SEMICOLON);
-			break;
-		case '=':
-			setNextTokenAndReset(TokenType.EQ);
-			break;
-		case '+':
-			setNextTokenAndReset(TokenType.PLUS);
-			break;
-		case '*':
-			setNextTokenAndReset(TokenType.MUL);
-			break;
-		case '/':
-			if (consume('/')) {
-				br.readLine();
-				resetStringBuilder();
-				setBuilderToFirstMeaningfulChar();
-			} else {
-				setNextTokenAndReset(TokenType.DIV);
-			}
-			break;
-		case '<':
-			lexLAngle();
-			break;
-		case '>':
-			lexRAngle();
-			break;
-		case '-':
-			lexDash();
-			break;
-		case ':':
-			if (consume('='))
-				setNextTokenAndReset(TokenType.ASSIGN);
-			break;
-		case '!':
-			if (consume('='))
-				setNextTokenAndReset(TokenType.NE);
-			break;
-		default:
-			if (Character.isLetter(c))
-				lexIdentifier();
-			else if (Character.isDigit(c))
-				lexNum();
-			else
-				unexpected();
-		}
-	}
-
-	/**
-	 * Consumes whitespace up until the first non-whitespace character, and sets the
-	 * builder to that character
-	 *
-	 * @throws IOException
-	 *             if an IOException is encountered while reading from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void setBuilderToFirstMeaningfulChar() throws IOException, EOFException {
-		// Make sure there isn't any leftover from a previous lexing operation
-		assert sb.length() <= 1;
-		char c = sb.length() == 1 ? c = sb.charAt(0) : getNextCharAndAppend();
-
-		// consume whitespace
-		while (Character.isWhitespace(c)) {
-			if (c == '\n')
-				++lineNo;
-			c = getNextCharAndAppend();
-		}
-
-		resetBuilderWith(c);
-	}
-
-	/**
-	 * Lexes a left angle bracket. May be called only when the previously read
-	 * character is '<'.
-	 * 
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexLAngle() throws IOException, EOFException {
-		int c = nextChar(false);
-		if (c == -1) {
-			setNextTokenAndReset(TokenType.LT);
-		} else {
-			char cc = (char) c;
-			sb.append(cc);
-			if (cc == '=')
-				setNextTokenAndReset(TokenType.LE);
-			else
-				setNextTokenAndResetWith(TokenType.LT, cc);
-		}
-	}
-
-	/**
-	 * Lexes a right angle bracket. May be called only when the previously read
-	 * character '>'.
-	 * 
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexRAngle() throws IOException, EOFException {
-		int c = nextChar(false);
-		if (c == -1) {
-			setNextTokenAndReset(TokenType.GT);
-		} else {
-			char cc = (char) c;
-			sb.append(cc);
-			if (cc == '=')
-				setNextTokenAndReset(TokenType.GE);
-			else
-				setNextTokenAndResetWith(TokenType.GT, cc);
-		}
-	}
-
-	/**
-	 * Lexes a dash character. If a dash is followed by another dash, then it is
-	 * part of an arrow. Otherwise it must represent a minus sign.
-	 * 
-	 * May only be called when the previously read char is a dash '-'.
-	 * 
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexDash() throws IOException, EOFException {
-		int c = nextChar(false);
-		if (c == -1) {
-			setNextTokenAndReset(TokenType.MINUS);
-		} else {
-			char cc = (char) c;
-			sb.append(cc);
-			if (cc == '-') {
-				if (consume('>'))
-					setNextTokenAndReset(TokenType.ARR);
-			} else
-				setNextTokenAndResetWith(TokenType.MINUS, cc);
-		}
-	}
-
-	/**
-	 * Lexes an identifier. May be called only when the previously read character is
-	 * a letter.
-	 * 
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexIdentifier() throws IOException, EOFException {
-		int c;
-		for (c = nextChar(false); c != -1 && Character.isLetter(c); c = nextChar(false))
-			sb.append((char) c);
-
-		String id = sb.toString();
-		TokenType tt = TokenType.getTypeFromString(id);
-		if (tt != null)
-			setNextTokenAndReset(tt);
-		else
-			unexpected();
-
-		if (c != -1)
-			sb.append((char) c);
-	}
-
-	/**
-	 * Lexes a number. May be called only when the previously read character is a
-	 * digit.
-	 * 
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and a token cannot be produced.
-	 */
-	private void lexNum() throws IOException, EOFException {
-		int c;
-		for (c = nextChar(false); c != -1 && Character.isDigit(c); c = nextChar(false))
-			sb.append((char) c);
-
-		try {
-			String num = sb.toString();
-			int val = Integer.parseInt(num);
-			curTok = new Token.NumToken(val, lineNo);
-			tokenReady = true;
-			resetStringBuilder();
-			if (c != -1)
-				sb.append((char) c);
-		} catch (NumberFormatException e) {
-			unexpected();
-		}
-	}
-
-	/**
-	 * Read the next character from the reader, treating EOF as an error. If
-	 * successful, append the character to the buffer.
-	 *
-	 * @return The next character
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read the next char
-	 * @throws EOFException
-	 *             if EOF is encountered
-	 */
-	private char getNextCharAndAppend() throws IOException, EOFException {
-		char c = (char) nextChar(true);
-		sb.append(c);
-		return c;
-	}
-
-	/**
-	 * Read the next character from the reader. If {@code exceptionOnEOF}, treat EOF
-	 * as an error. If successful, append the character to the buffer.
-	 *
-	 * @param exceptionOnEOF
-	 *            {@code true} if EOF should be treated as an error
-	 * @return The integer representation of the next character
-	 * @throws IOException
-	 *             if an {@code IOException} is thrown when trying to read from the
-	 *             source Reader
-	 * @throws EOFException
-	 *             if EOF is encountered and isEOFerror is true
-	 */
-	private int nextChar(boolean exceptionOnEOF) throws IOException, EOFException {
-		int c = br.read(); // returns -1 if the stream's end has been reached
-		if (exceptionOnEOF && c == -1)
-			encounteredEOF();
-		return c;
-	}
-
-	/**
-	 * Sets the next token to be a token of {@code tokenType} and clears the
-	 * {@code StringBuilder}.
-	 * 
-	 * @param tokenType
-	 *            - the type of the token to set, not {@code null}
-	 */
-	private void setNextTokenAndReset(TokenType tokenType) {
-		curTok = new Token(tokenType, lineNo);
-		tokenReady = true;
-		resetStringBuilder();
-	}
-
-	/**
-	 * Sets the next token to be a token of {@code tokenType}, clears the
-	 * {@code StringBuilder}, and inserts {@code c} to begin the next string.
-	 * 
-	 * @param tokenType
-	 *            - the type of the token to set, not {@code null}
-	 * @param c
-	 *            - the character to use at the start of the string builder
-	 */
-	private void setNextTokenAndResetWith(TokenType tokenType, char c) {
-		setNextTokenAndReset(tokenType);
-		sb.append(c);
-	}
-
-	/**
-	 * Resets the StringBuilder and starts a new string with {@code c}.
-	 * 
-	 * @param c
-	 *            - the character with which to start a new string
-	 */
-	private void resetBuilderWith(char c) {
-		resetStringBuilder();
-		sb.append(c);
-	}
-
-	/** Resets the StringBuilder {@code sb} to clear its string. */
-	private void resetStringBuilder() {
-		sb.setLength(0);
-	}
-
-	/**
-	 * Read the next character and determine whether it is the expected character.
-	 * If not, the current buffer is an error
-	 *
-	 * @param expected
-	 *            - The expected next character
-	 * @return true if the next character is as expected
-	 * @throws IOException
-	 *             if an IOException was thrown when trying to read from the source
-	 *             Reader
-	 * @throws EOFException
-	 *             if EOF is encountered
-	 */
-	private boolean consume(char expected) throws IOException, EOFException {
-		int c = getNextCharAndAppend();
-		if (c == expected)
-			return true;
-		unexpected();
-		return false;
-	}
-
-	/**
-	 * Makes the current token an error token with the current contents of the
-	 * buffer.
-	 */
-	private void unexpected() {
-		curTok = new Token.ErrorToken(sb.toString());
-		tokenReady = true;
-		resetStringBuilder();
-	}
-
-	/**
-	 * Make the contents of the current buffer into an EOFToken, clearing the buffer
-	 * in the process, set atEOF to true, and set the current token to the newly
-	 * generated EOFToken, setting tokenReady in the process
-	 */
-	private void encounteredEOF() throws EOFException {
-		curTok = new Token.EOFToken(sb.toString(), lineNo);
-		resetStringBuilder();
-		atEOF = true;
-		tokenReady = true;
-		throw new EOFException();
-	}
-
-	/** "Helper" exception to indicate that EOF was reached */
-	static class EOFException extends Exception {
-		/** Unique serial version ID. @see Serializable#serialVersionUID */
-		private static final long serialVersionUID = -7333947165525391472L;
-	}
-
-	/** "Helper" exception to indicate an IO exception while tokenizing. */
-	static class TokenizerIOException extends RuntimeException {
-		/** Unique serial version ID. @see Serializable#serialVersionUID */
-		private static final long serialVersionUID = 8014027094822746940L;
-
-		/**
-		 * Constructs a new {@code TokenizerIOException} caused by {@code cause}.
-		 * 
-		 * @param cause
-		 *            - the cause of the IOException
-		 */
-		TokenizerIOException(Throwable cause) {
-			super(cause);
-		}
-	}
-}
+    private final BufferedReader br;
+    private final StringBuilder buf;
+    private int lineNo;
+    /**
+     * {@code tokenReady} is {@code false} if a token is not immediately
+     * available to be returned from {@code next()}, and {@code true} if a token
+     * is immediately ready to be returned from {@code next()}.
+     */
+    private boolean tokenReady = false;
+    private Token curTok =
+            new ErrorToken("Tokenizer has not yet begun reading", -1);
+    private boolean atEOF = false;
+
+    /**
+     * Create a Tokenizer that reads from the specified reader
+     * 
+     * @param r
+     *            The source from which the Tokenizer lexes input into Tokens
+     */
+    Tokenizer(Reader r) {
+        br = new BufferedReader(r);
+        buf = new StringBuilder();
+        lineNo = 1;
+    }
+
+    /**
+     * Returns {@code true} if the iteration has more meaningful elements. (In
+     * other words, returns {@code true} if {@link #next} would return a non-EOF
+     * element rather than throwing an exception or returning EOF.)
+     *
+     * @return {@code true} if the iteration has more meaningful elements
+     */
+    @Override
+    public boolean hasNext() {
+        if (!tokenReady) {
+            try {
+                lexOneToken();
+            }
+            catch (IOException e) {
+                throw new TokenizerIOException(e);
+            }
+            catch (EOFException e) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public Token next() throws TokenizerIOException {
+        Token tok = peek();
+        tokenReady = false;
+        return tok;
+    }
+
+    /**
+     * Return the next token in the program without consuming the token.
+     * 
+     * @return the next token, without consuming it
+     * @throws IOException
+     *             if an IOException was thrown while trying to read from the
+     *             source Reader
+     * @throws EOFException
+     *             if EOF was encountered while trying to lex the next token
+     */
+    public Token peek() throws TokenizerIOException {
+        if (!tokenReady && !atEOF) try {
+            lexOneToken();
+        }
+        catch (IOException e) {
+            throw new TokenizerIOException(e);
+        }
+        catch (EOFException e) {
+            // EOFException is thrown by encounteredEOF(), which should set
+            // curTok to an EOFToken
+        }
+        return curTok;
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Close the reader opened by this tokenizer.
+     */
+    void close() {
+        try {
+            br.close();
+        }
+        catch (IOException e) {
+            System.out.println("IOException:");
+            System.out.println(e.getMessage());
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Read one token from the reader. One token is always produced if the end
+     * of file is not encountered, but that token may be an error token.
+     * 
+     * @throws IOException
+     *             if an IOException was thrown when trying to read from the
+     *             source Reader
+     * @throws EOFException
+     *             if EOF is encountered and a token cannot be produced.
+     */
+    private void lexOneToken() throws IOException, EOFException {
+        setBufToFirstMeaningfulChar();
+        char c = buf.charAt(0);
+
+        switch (c) {
+        case '[':
+            setNextTokenAndReset(LBRACKET);
+            break;
+        case ']':
+            setNextTokenAndReset(RBRACKET);
+            break;
+        case '(':
+            setNextTokenAndReset(LPAREN);
+            break;
+        case ')':
+            setNextTokenAndReset(RPAREN);
+            break;
+        case '{':
+            setNextTokenAndReset(LBRACE);
+            break;
+        case '}':
+            setNextTokenAndReset(RBRACE);
+            break;
+        case ';':
+            setNextTokenAndReset(SEMICOLON);
+            break;
+        case '=':
+            setNextTokenAndReset(EQ);
+            break;
+        case '+':
+            setNextTokenAndReset(PLUS);
+            break;
+        case '*':
+            setNextTokenAndReset(MUL);
+            break;
+        case '/':
+            lexSlash();
+            break;
+        case '<':
+            lexLAngle();
+            break;
+        case '>':
+            lexRAngle();
+            break;
+        case '-':
+            lexDash();
+            break;
+        case ':':
+            if (consume('=')) setNextTokenAndReset(ASSIGN);
+            break;
+        case '!':
+            if (consume('=')) setNextTokenAndReset(NE);
+            break;
+        default:
+            if (Character.isLetter(c))
+                lexIdentifier();
+            else if (Character.isDigit(c))
+                lexNum();
+            else unexpected();
+        }
+    }
+
+    /**
+     * Consumes whitespace up until the first non-whitespace character, and sets
+     * the buffer to that character
+     * 
+     * @throws IOException
+     *             if an IOException is encountered while reading from the
+     *             source Reader
+     */
+    private void setBufToFirstMeaningfulChar() throws IOException, EOFException {
+        // Make sure there isn't any leftover from a previous lexing operation
+        assert buf.length() <= 1;
+        char c = buf.length() == 1 ? c = buf.charAt(0) : getNextCharAndAppend();
+
+        // consume whitespaces
+        while (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
+            if (c == '\n') lineNo++;
+            c = getNextCharAndAppend();
+        }
+
+        resetBufferWith(c);
+    }
+
+    private void lexSlash() throws IOException, EOFException {
+        int c = nextChar(false);
+        if (c == -1)
+            setNextTokenAndReset(DIV);
+        else {
+            char cc = (char) c;
+            buf.append(cc);
+            if (cc == '/') {
+                // rest-of-line comment
+                while (cc != '\n')
+                    cc = getNextCharAndAppend();
+                resetBufferWith(cc);
+                setBufToFirstMeaningfulChar();
+            }
+            else setNextTokenAndResetWith(DIV, cc);
+        }
+    }
+
+    private void lexLAngle() throws IOException, EOFException {
+        int c = nextChar(false);
+        if (c == -1)
+            setNextTokenAndReset(LT);
+        else {
+            char cc = (char) c;
+            buf.append(cc);
+            if (cc == '=')
+                setNextTokenAndReset(LE);
+            else setNextTokenAndResetWith(LT, cc);
+        }
+    }
+
+    private void lexRAngle() throws IOException, EOFException {
+        int c = nextChar(false);
+        if (c == -1)
+            setNextTokenAndReset(GT);
+        else {
+            char cc = (char) c;
+            buf.append(cc);
+            if (cc == '=')
+                setNextTokenAndReset(GE);
+            else setNextTokenAndResetWith(GT, cc);
+        }
+    }
+
+    private void lexDash() throws IOException, EOFException {
+        int[] cs = peekReader(2);
+        if (cs[0] == -1) {
+            consume('-'); // Dash already in the system
+            setNextTokenAndReset(MINUS);
+        }
+        else { // Have one dash, what's next
+               // If dash #2
+            if ((char) cs[0] == '-') {
+                // If >
+                if ((char) cs[1] == '>') { // It's an arrow!
+                    consume('-');
+                    consume('>');
+                    setNextTokenAndReset(ARR);
+                }
+                else {
+                    consume('-');
+                    setNextTokenAndResetWith(MINUS, '-');
+                }
+            }
+            else { // No dash #2
+                setNextTokenAndReset(MINUS);
+            }
+        }
+    }
+
+    private void lexIdentifier() throws IOException, EOFException {
+        int c;
+        for (c = nextChar(false); c != -1 && Character.isLetter(c); c =
+                nextChar(false))
+            buf.append((char) c);
+
+        String id = buf.toString();
+        TokenType tt = TokenType.getTypeFromString(id);
+        if (tt != null) {
+            setNextTokenAndReset(tt);
+        }
+        else {
+            unexpected();
+        }
+
+        if (c != -1) buf.append((char) c);
+    }
+
+    private void lexNum() throws IOException, EOFException {
+        int c;
+        for (c = nextChar(false); c != -1 && Character.isDigit(c); c =
+                nextChar(false))
+            buf.append((char) c);
+
+        try {
+            String num = buf.toString();
+            int val = Integer.parseInt(num);
+            curTok = new NumToken(val, lineNo);
+            tokenReady = true;
+            buf.setLength(0);
+            if (c != -1) buf.append((char) c);
+        }
+        catch (NumberFormatException e) {
+            unexpected();
+        }
+    }
+
+    /**
+     * Read the next character from the reader, treating EOF as an error. If
+     * successful, append the character to the buffer.
+     * 
+     * @return The next character
+     * @throws IOException
+     *             if an IOException was thrown when trying to read the next
+     *             char
+     * @throws EOFException
+     *             if EOF is encountered
+     */
+    private char getNextCharAndAppend() throws IOException, EOFException {
+        char c = (char) nextChar(true);
+        buf.append(c);
+        return c;
+    }
+
+    /**
+     * Read the next character from the reader. If isEOFerror, treat EOF as an
+     * error. If successful, append the character to the buffer.
+     * 
+     * @param exceptionOnEOF
+     * @return The integer representation of the next character
+     * @throws IOException
+     *             if an {@code IOException} is thrown when trying to read from
+     *             the source Reader
+     * @throws EOFException
+     *             if EOF is encountered and isEOFerror is true
+     */
+    private int nextChar(boolean exceptionOnEOF) throws IOException,
+            EOFException {
+        int c = br.read();
+        if (exceptionOnEOF && c == -1) encounteredEOF();
+        return c;
+    }
+
+    private void setNextTokenAndReset(TokenType tokenType) {
+        curTok = new Token(tokenType, lineNo);
+        tokenReady = true;
+        buf.setLength(0);
+    }
+
+    private void setNextTokenAndResetWith(TokenType tokenType, char c) {
+        setNextTokenAndReset(tokenType);
+        buf.append(c);
+    }
+
+    private void resetBufferWith(char c) {
+        buf.setLength(0);
+        buf.append(c);
+    }
+
+    /**
+     * Read the next character and determine whether it is the expected
+     * character. If not, the current buffer is an error
+     * 
+     * @param expected
+     *            The expected next character
+     * @return true if the next character is as expected
+     * @throws IOException
+     *             if an IOException was thrown when trying to read from the
+     *             source Reader
+     * @throws EOFException
+     *             if EOF is encountered
+     */
+    private boolean consume(char expected) throws IOException, EOFException {
+        int c = getNextCharAndAppend();
+        if (c != expected) {
+            unexpected();
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Make the current token an error token with the current contents of the
+     * buffer
+     */
+    private void unexpected() {
+        curTok = new ErrorToken(buf.toString(), lineNo);
+        tokenReady = true;
+        buf.setLength(0);
+    }
+
+    private final int[] charBuf = new int[3];
+
+    private int[] peekReader(int distance) throws IOException {
+        assert distance <= 3 && distance > 0;
+        br.mark(distance + 1);
+        for (int i = 0; i < distance; i++) {
+            charBuf[i] = br.read();
+        }
+        br.reset();
+        return charBuf;
+    }
+
+    /**
+     * Make the contents of the current buffer into an EOFToken, clearing the
+     * buffer in the process, set atEOF to true, and set the current token to
+     * the newly generated EOFToken, setting tokenReady in the process
+     */
+    private void encounteredEOF() throws EOFException {
+        curTok = new EOFToken(buf.toString(), lineNo);
+        buf.setLength(0);
+        atEOF = true;
+        tokenReady = true;
+        throw new EOFException();
+    }
+
+    /**
+     * "Helper" exception to indicate that EOF was reached
+     */
+    static class EOFException extends Exception {
+        private static final long serialVersionUID = -7333947165525391472L;
+    }
+
+    static class TokenizerIOException extends RuntimeException {
+        private static final long serialVersionUID = 8014027094822746940L;
+
+        TokenizerIOException(Throwable cause) {
+            super(cause);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/AbstractWorld.java b/src/main/java/simulation/AbstractWorld.java
new file mode 100644
index 0000000..a58087f
--- /dev/null
+++ b/src/main/java/simulation/AbstractWorld.java
@@ -0,0 +1,170 @@
+package simulation;
+
+import java.util.HashMap;
+import java.util.LinkedList;
+
+import interpret.Interpreter;
+import interpret.InterpreterImpl;
+
+public abstract class AbstractWorld implements SimpleWorld
+{
+	/** A compilation of all the constants needed for world creation. */
+	protected HashMap<String, Double> CONSTANTS;
+	/** Stores all the critters present in the world, in the order in which they were created. */
+	protected LinkedList<SimpleCritter> critterList;
+	/** The number of time steps passed since this world's genesis. */
+	protected int timePassed;
+	
+	@Override
+	public int getMinMemory()
+	{
+		return CONSTANTS.get("MIN_MEMORY").intValue();
+	}
+
+	@Override
+	public int getMaxRules()
+	{
+		return CONSTANTS.get("MAX_RULES_PER_TURN").intValue();
+	}
+
+	@Override
+	public int numRemainingCritters()
+	{
+		return critterList.size();
+	}
+	
+	@Override
+	public int getTimePassed()
+	{
+		return timePassed;
+	}
+	
+	@Override
+	@SuppressWarnings("unchecked")
+	public void advanceOneTimeStep()
+	{
+		LinkedList<SimpleCritter> clone = (LinkedList<SimpleCritter>) critterList.clone();
+		for(int i = 0; i < clone.size(); i++)
+		{
+			SimpleCritter sc = clone.get(i);
+			Interpreter im = new InterpreterImpl(sc, this);
+			im.simulateCritterTurn();
+		}
+		
+		for(int i = 0; i < clone.size(); i++)
+		{
+			SimpleCritter sc = clone.get(i);
+			sc.toggleMatingPheromones(false);
+}
+		
+		timePassed++;
+	}
+
+	@Override
+	public abstract void loadCritters(String filename, int n, int direction);
+	
+	@Override
+	public abstract StringBuilder printGrid();
+	
+	/* ========================================= */
+	/* ----------- Critter Sensors ------------- */
+	/* ========================================= */
+	
+	/**
+	 * Looks at the contents of a hex adjacent to a critter.
+	 * @param sc : the critter who is observing its surroundings
+	 * @param dir : the direction in which to look
+	 * @return an integer value based on the contents of the observed hex, determined by the {@code WorldObject}
+	 * 		   method {@code getAppearance()}.
+	 */
+	public abstract int searchNearby(SimpleCritter sc, int dir);
+
+	/**
+	 * Looks at the contents of a hex ahead of a critter.
+	 * @param sc : the critter who is observing its surroundings
+	 * @param index : how far ahead to look
+	 * @return an integer value based on the contents of the observed hex, following the same scheme as {@code searchNearby}.
+	 */
+	public abstract int searchAhead(SimpleCritter sc, int index);
+
+	/* ========================================= */
+	/* ----------- Critter Actions ------------- */
+	/* ========================================= */
+	
+	/* 
+	  A NOTE ON ACTIONS: all critter actions except WAIT expend energy. Most of them expend the same amount of energy whether
+	  they succeed or not. If a critter tries to execute an action that requires more energy than it currently has, it will 
+	  die without executing that action. If a critter has just enough energy to perform an action (i.e. the energy required
+	  to perform that action is equal to the energy it currently has, it will execute that action and promptly die afterwards.
+	*/
+	
+	/**
+	 * Moves a critter, if there is nothing in the way and critter will not move off the world bounds.
+	 * @param sc : the moving critter
+	 * @param forward : whether or not the critter is moving forward or backward
+	 */
+	public abstract void moveCritter(SimpleCritter sc, boolean forward);
+	
+	/**
+	 * Turns a critter.
+	 * @param sc : the turning critter
+	 * @param forward : whether or not the critter is turning clockwise or counterclockwise
+	 */
+	public abstract void turnCritter(SimpleCritter sc, boolean clockwise);
+
+	/**
+	 * Forces a critter to eat, if there is food in the hex directly in front of it. This action replenishes energy
+	 * equal to the caloric content of the food eaten.
+	 * @param sc : the feasting critter
+	 */
+	public abstract void critterEat(SimpleCritter sc);
+
+	/**
+	 * Grows a critter by one size.
+	 * @param sc : the growing critter
+	 */
+	public abstract void growCritter(SimpleCritter sc);
+
+	/** 
+	 * Simulates the results of one critter attacking another.
+	 * @param attacker
+	 */
+	public abstract void critterBattle(SimpleCritter attacker);
+	
+	
+	/** 
+	 * Executes the result of one critter attempting to bud. The newly created offspring will appear directly behind
+	 * the parent critter, unless there is something already in that hex (in which case no reproduction will occur).
+	 * @param sc : the budding critter
+	 */
+	public abstract void critterBud(SimpleCritter sc);
+	
+	/**
+	 * Executes the result of one critter attempting to mate with another critter. The other critter must be directly in
+	 * front of the first critter and facing the first critter. The newly created offspring will appear directly behind
+	 * one of the parent critters, unless there is something already in that hex (in which case no reproduction will occur).
+	 * @param sc
+	 */
+	public abstract void critterMate(SimpleCritter sc);
+	
+	/**
+	 * One critter "tags" another critter by setting its "tag" attribute in memory equal to the value of {@code index}.
+	 * @param sc
+	 * @param index
+	 */
+	public abstract void critterTag(SimpleCritter sc, int index);
+	
+	/**
+	 * One critter severs a part of its soul (its energy) and places it on the hex in front of it in the form of food. It is
+	 * possible for the critter to serve all of its remaining energy, killing it in the process
+	 * @param sc : the overly generous critter
+	 * @param index : the amount of food to serve
+	 */
+	public abstract void critterServe(SimpleCritter sc, int index);
+	
+	/**
+	 * A critter does nothing but sit in the sun. It replenishes some energy in the process.
+	 * @param sc
+	 */
+	public abstract void critterSoakEnergy(SimpleCritter sc);
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/Critter.java b/src/main/java/simulation/Critter.java
new file mode 100644
index 0000000..a414aab
--- /dev/null
+++ b/src/main/java/simulation/Critter.java
@@ -0,0 +1,298 @@
+package simulation;
+
+import ast.Program;
+import java.util.Arrays;
+
+/** A critter is a creature that inhabits CritterWorld. */
+public class Critter implements SimpleCritter
+{
+	/** The set of rules for this critter. */
+	private Program prog;
+	/** The memory of this critter, which stores important attributes of the critter. */
+	private int[] memory;
+	/** The length of this critter's memory. Must be at least 8. */
+	private int memLength;
+	/** The direction this critter is facing. */
+	private Direction orientation;
+	/** Whether or not this critter wants to mate. */
+	private boolean readyToMingle;
+	/** The name of this critter, used for identification purposes. */
+	private String name;
+	/** A string containing information about the last rule this critter completed. */
+	private String lastRuleCompleted;
+	
+	/**
+	 * Creates a new Critter with a specified ruleset, memory, orientation, and name.
+	 * @param p
+	 * @param mem
+	 * @param dir
+	 * @param s
+	 */
+	public Critter(Program p, int[] mem, String s, int dir)
+	{
+		prog = p;
+		memory = mem;
+		memLength = mem[0];
+		name = s;
+		readyToMingle = false;
+		lastRuleCompleted = null;
+		
+		orientation = Direction.constructDir(dir);
+	}
+	
+	/**
+	 * Creates a new Critter with a specified ruleset, memory, name, and a random orientation.
+	 * @param p
+	 * @param mem
+	 * @param s
+	 */
+	public Critter(Program p, int[] mem, String s)
+	{
+		prog = p;
+		memory = mem;
+		memLength = mem[0];
+		name = s;
+		readyToMingle = false;
+		lastRuleCompleted = null;
+		
+		int rand = (int) (Math.random() * 6);
+		orientation = Direction.constructDir(rand);
+	}
+	
+	@Override
+	public int size()
+	{
+		return memory[3];
+	}
+	
+	@Override
+	public int getMemLength()
+	{
+		return memLength;
+	}
+	
+	@Override
+	public Program getProgram()
+	{
+		return prog;
+	}
+	
+	@Override
+	public int getOrientation()
+	{
+		return orientation.getValue();
+	}
+	
+	@Override
+	public String getLastRule()
+	{
+		return lastRuleCompleted;
+	}
+	@Override
+	public void setLastRule(String s)
+	{
+		lastRuleCompleted = s;
+	}
+	
+	@Override
+	public int readMemory(int index)
+	{
+		if(index < 0 || index >= memLength)
+			return Integer.MIN_VALUE;
+		return memory[index];
+	}
+	
+	@Override
+	public boolean setMemory(int val, int index)
+	{
+		//this method does nothing if it tries to alter an index of less than 7, or if the index is out of memory's bounds
+		if(index < 7 || index >= memLength)
+			return false;
+		//the value of mem[7] must be in the range [0, 99] so attempting to set it to something else also has no effect
+		if(index == 7 && !(val <= 99 && val >= 0))
+			return false;
+		
+		memory[index] = val;
+		return true;
+	}
+	
+	@Override
+	public String getName()
+	{
+		return name;
+	}
+	
+	@Override
+	public int getEnergy()
+	{
+		return memory[4];
+	}
+	
+	@Override
+	public void updateEnergy(int amount, int maxEnergyPerSize)
+	{
+		memory[4] += amount;
+		if(memory[4] > maxEnergyPerSize * size())
+			memory[4] = maxEnergyPerSize * size();
+	}
+	
+	@Override
+	public void incrementPass()
+	{
+		if(memory[5] < 999)
+			memory[5]++;
+	}
+	
+	@Override
+	public void turn(boolean counterclockwise)
+	{
+		int curDir = orientation.getValue();
+		int change = counterclockwise ? 1 : -1;
+		
+		int newDir = curDir + change;
+		if(newDir > 5)
+			newDir -= 6;
+		else if(newDir < 0)
+			newDir += 6;
+		orientation = Direction.constructDir(newDir);
+	}
+	
+	@Override
+	public String toString()
+	{
+		return "" + orientation.getValue();
+	}
+	
+	@Override
+	public boolean wantsToMate()
+	{
+		return readyToMingle;
+	}
+	
+	@Override
+	public void toggleMatingPheromones(boolean b)
+	{
+		readyToMingle = b;
+	}
+	
+	@Override
+	public int complexity(int ruleCost, int abilityCost)
+	{
+		return prog.getRulesList().size() * ruleCost + (memory[1] + memory[2]) * abilityCost;
+	}
+	
+	@Override
+	public int getAppearance()
+	{
+		return memory[3] * 100000 + memory[6] * 1000 + memory[7] * 10 + orientation.getValue();
+	}
+
+	@Override
+	public int[] changeInPosition(boolean forward, int dir)
+	{
+		int[] result = new int[2];
+		Direction d = Direction.constructDir(dir);
+		switch(d)
+		{
+			case NORTH:
+				result[0] = 0;
+				result[1] = 1;
+				break;
+			case NORTHEAST:
+				result[0] = 1;
+				result[1] = 1;
+				break;
+			case SOUTHEAST:
+				result[0] = 1;
+				result[1] = 0;
+				break;
+			case SOUTH:
+				result[0] = 0;
+				result[1] = -1;
+				break;
+			case SOUTHWEST:
+				result[0] = -1;
+				result[1] = -1;
+				break;
+			case NORTHWEST:
+				result[0] = -1;
+				result[1] = 0;
+				break;			
+		}
+		if(!forward)
+		{
+			result[0] *= -1;
+			result[1] *= -1;
+		}
+		return result;
+	}
+	
+	@Override
+	public int[] getMemoryCopy()
+	{
+		return Arrays.copyOf(memory, memLength);
+	}
+	
+	/** An enumeration of all the possible directions a critter can be facing. */
+	public enum Direction
+	{
+		NORTH, NORTHEAST, SOUTHEAST, SOUTH, SOUTHWEST, NORTHWEST;
+		
+		/** 
+		 * Returns an integer value of this direction based on an arbitrary numbering system that sets NORTH to 0 and 
+		 * goes counterclockwise until it stops at NORTHEAST.
+		 */
+		public int getValue()
+		{
+			int result = 0;
+			switch(this)
+			{
+				case NORTH:
+					result = 0;
+					break;
+				case NORTHEAST:
+					result = 1;
+					break;
+				case SOUTHEAST:
+					result = 2;
+					break;
+				case SOUTH:
+					result = 3;
+					break;
+				case SOUTHWEST:
+					result = 4;
+					break;
+				case NORTHWEST:
+					result = 5;
+					break;
+			}
+			return result;
+		}
+		
+		/**
+		 * Returns a direction from an integer based on the aforementioned numbering system.
+		 * @param n
+		 * @return a direction that depends on the integer entered. If {@code n} is not in [0, 5], returns NORTH.
+		 */
+		public static Direction constructDir(int n)
+		{
+			switch(n)
+			{
+				case 0:
+					return NORTH;
+				case 1:
+					return NORTHEAST;
+				case 2:
+					return SOUTHEAST;
+				case 3:
+					return SOUTH;
+				case 4:
+					return SOUTHWEST;
+				case 5:
+					return NORTHWEST;
+				default:
+					return NORTH;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/FileParser.java b/src/main/java/simulation/FileParser.java
new file mode 100644
index 0000000..95dbc6b
--- /dev/null
+++ b/src/main/java/simulation/FileParser.java
@@ -0,0 +1,183 @@
+package simulation;
+
+import java.io.*;
+import java.util.HashMap;
+
+import ast.Program;
+import parse.Parser;
+import parse.ParserFactory;
+
+/** This class supplies several static methods that may be useful for parsing files needed for world creation and modification. */
+public class FileParser
+{
+	/**
+	 * Constructs a critter from a file.
+	 * @param br : a BufferedReader containing the file to be read
+	 * @param minMemory : the minimum memory size for a critter
+	 * @param direction : the direction the critter will be facing
+	 * @return A SimpleCritter object made from the parsed file, or null if the program contains syntax errors
+	 */
+	public static SimpleCritter parseCritter(BufferedReader br, int minMemory, int direction)
+	{
+		String[] parsed = parseAttributes(br);
+		String name = parsed[0].equals("") ? "Untitled #" : parsed[0];
+		int[] critMem = FileParser.makeCritterMemory(parsed, minMemory);
+		
+		//parses the critter program. If the program isn't syntactically valid, returns null
+		Parser p = ParserFactory.getParser();
+		Program prog = p.parse(br);
+		if(prog == null)
+			return null;
+		
+		if((direction < 0 || direction > 5))
+			return new Critter(prog, critMem, name);
+		return new Critter(prog, critMem, name, direction);
+	}
+	
+	/**
+	 * Parses the attributes for a critter from a file into a String array.
+	 * @param br : a BufferedReader containing the file to be read
+	 * @return a String array containing the memory attributes needed to create the critter.
+	 */
+	public static String[] parseAttributes(BufferedReader br)
+	{
+		String name = parseAttributeFromLine(br, "species: ");
+		String memsize = parseAttributeFromLine(br, "memsize: ");
+		String defense = parseAttributeFromLine(br, "defense: ");
+		String offense = parseAttributeFromLine(br, "offense: ");
+		String size = parseAttributeFromLine(br, "size: ");
+		String energy = parseAttributeFromLine(br, "energy: ");
+		String posture = parseAttributeFromLine(br, "posture: ");
+		
+		return new String[] {name, memsize, defense, offense, size, energy, posture};
+	}
+	
+	/**
+	 * Given a BufferedReader, parses one attribute line from a file and returns a string containing only the attribute by
+	 * trimming out a specified substring {@code substringToCut}. If {@code substringToCut} is not present in the line or the end
+	 * of the file is reached, returns an empty string.
+	 * 
+	 * @param b : the BufferedReader to read lines from
+	 * @param : substringToCut the substring to trim
+	 * @return A string containing only the attribute given on the line
+	 */
+	public static String parseAttributeFromLine(BufferedReader b, String substringToCut)
+	{
+		String result = "";
+		try
+		{
+			String line = b.readLine();
+			int len = substringToCut.length();
+			if(line != null && line.startsWith(substringToCut) && len < line.length())
+				result = line.substring(len);
+		}
+		catch (IOException e)
+		{
+			return "";
+		}
+		return result;
+	}
+	
+	/**
+	 * Prepares an int array to be used as critter memory, based on a string array.<br>
+	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
+	 * @param strs : an array of strings created by the method {@code FileParser.parseAttributes(filename)}
+	 * @param minMemory : the minimum memory size for a critter
+	 * @return an int array, ready to be used as critter memory. Returns a default set of memory if {@code strs} is not compatible.
+	 */
+	private static int[] makeCritterMemory(String[] strs, int minMemory)
+	{
+		//if the strs array is less than 7, then we revert to a default set of memory
+		if(strs.length < 7)
+			return new int[] {minMemory, 3, 3, 1, 500, 0, 0, 0};
+		
+		int[] critterAttributes;
+		
+		int memsize = parseIntFromString(strs[1]);
+		if(memsize < minMemory)
+			memsize = minMemory;
+		critterAttributes = new int[memsize];
+		critterAttributes[0] = memsize;
+		
+		int defense = parseIntFromString(strs[2]);
+		if(defense < 0)
+			defense = 3;
+		critterAttributes[1] = defense;
+		
+		int offense = parseIntFromString(strs[3]);
+		if(offense < 0)
+		offense = 3;
+		critterAttributes[2] = offense;
+		
+		int size = parseIntFromString(strs[4]);
+		if(size < 0)
+			size = 1;
+		critterAttributes[3] = size;
+		
+		int energy = parseIntFromString(strs[5]);
+		if(energy < 0)
+			energy = 500;
+		critterAttributes[4] = energy;
+		
+		int pass = 0;
+		critterAttributes[5] = pass;
+		
+		int tag = 0;
+		critterAttributes[6] = tag;
+		
+		int posture = parseIntFromString(strs[6]);
+		if(posture < 0 || posture > 99)
+			posture = 0;
+		critterAttributes[7] = posture;
+		
+		for(int i = 8; i < memsize; i++)
+			critterAttributes[i] = 0;
+		
+		return critterAttributes;
+	}
+	/**
+	 * Parses an integer value from a given string, or returns -1 if no integer was found.
+	 * @param s : the string to parse
+	 * @return the int parsed from the string, or -1 if no integer was found
+	 */
+	private static int parseIntFromString(String s)
+	{
+		try
+		{
+			return Integer.parseInt(s);
+		}
+		catch (NumberFormatException n)
+		{
+			return -1;
+		}
+	}
+	
+	/**
+	 * Parses constants from a file and returns them in the form of a HashMap. Assumes that the file adheres to the format
+	 * specified by the <a href="http://www.cs.cornell.edu/courses/cs2112/2017fa/project/constants.txt">constants file given
+	 * to us</a>.
+	 * @param b : a BufferedReader containing the file to be read.
+	 * @return a HashMap containing the names of constants mapped to their values.
+	 * @throws IllegalArgumentException if the file is not valid.
+	 */
+	public static HashMap<String, Double> parseConstants(BufferedReader b) throws IllegalArgumentException
+	{
+		HashMap<String, Double> result = new HashMap<String, Double>();
+		try
+		{
+			String line = b.readLine();
+			while(line != null)
+			{
+				String[] constant = line.split(" ");
+				result.put(constant[0], Double.parseDouble(constant[1]));
+				line = b.readLine();
+			}
+		}
+		//If the constants file has any irregularities,
+		catch (Exception e)
+		{
+			throw new IllegalArgumentException();
+		}
+		return result;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/Food.java b/src/main/java/simulation/Food.java
new file mode 100644
index 0000000..ecc2e6f
--- /dev/null
+++ b/src/main/java/simulation/Food.java
@@ -0,0 +1,31 @@
+package simulation;
+
+/** A piece of food that can be present on one world hex. */
+public class Food implements WorldObject
+{
+	/** The caloric value of this piece of food. */
+	private int calories;
+	
+	/** Creates a new Food object with the specified amount of calories. */
+	public Food(int amt)
+	{
+		calories = amt;
+	}
+	
+	/** Returns the amount of calories in this piece of food. */
+	public int getCalories()
+	{
+		return calories;
+	}
+	
+	public String toString()
+	{
+		return "F";
+	}
+
+	@Override
+	public int getAppearance()
+	{
+		return -1 * (calories + 1);
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/Hex.java b/src/main/java/simulation/Hex.java
new file mode 100644
index 0000000..cd3bd91
--- /dev/null
+++ b/src/main/java/simulation/Hex.java
@@ -0,0 +1,81 @@
+package simulation;
+
+/** Stores the information for one hex in the world grid. */
+public class Hex
+{
+	/** The column index of this Hex. */
+	private int colIndex;
+	/** The row index of this Hex. */
+	private int rowIndex;
+	/** What this hex contains. May be null if there is nothing on this hex. */
+	private WorldObject content;
+	
+	/** Creates a new empty Hex object with the specified rowIndex and colIndex. */
+	public Hex(int c, int r)
+	{
+		colIndex = c;
+		rowIndex = r;
+		content = null;
+	}
+	
+	/** Returns the column index of this Hex. */
+	public int getColumnIndex()
+	{
+		return colIndex;
+	}
+	
+	/** Returns the row index of this Hex. */
+	public int getRowIndex()
+	{
+		return rowIndex;
+	}
+	
+	/**
+	 * Adds a world object to this hex, if it is empty.
+	 * @param wo the object to add
+	 * @return whether or not {@code wo} was able to be added to this hex.
+	 */
+	public boolean addContent(WorldObject wo)
+	{
+		if(isEmpty())
+		{
+			content = wo;
+			return true;
+		}
+		return false;
+	}
+	
+	/** Removes the content on this hex. */
+	public void removeContent()
+	{
+		content = null;
+	}
+	
+	public WorldObject getContent()
+	{
+		return content;
+	}
+	/** Returns {@code true} if and only if {@code content == null}. */
+	public boolean isEmpty()
+	{
+		return content == null;
+	}
+	
+	/**
+	 * Returns an integer representing how this hex appears to a critter. If this hex is empty, this integer is 0,
+	 * but otherwise, this value is determined by {@code content.getAppearance()}, which follows the numbering scheme
+	 * described in the interface {@code WorldObject}.
+	 */
+	public int hexAppearance()
+	{
+		return isEmpty() ? 0 : content.getAppearance();
+	}
+	
+	@Override
+	public String toString()
+	{
+		if(content == null)
+			return "-";
+		return content.toString();
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/Rock.java b/src/main/java/simulation/Rock.java
new file mode 100644
index 0000000..fd7ac7f
--- /dev/null
+++ b/src/main/java/simulation/Rock.java
@@ -0,0 +1,17 @@
+package simulation;
+
+/** This is a <a href = "https://en.wikipedia.org/wiki/Rock_(geology)">rock</a>. */
+public class Rock implements WorldObject
+{
+	@Override
+	public String toString()
+	{
+		return "#";
+	}
+
+	@Override
+	public int getAppearance()
+	{
+		return -1;
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/SimpleCritter.java b/src/main/java/simulation/SimpleCritter.java
new file mode 100644
index 0000000..0bfb0f2
--- /dev/null
+++ b/src/main/java/simulation/SimpleCritter.java
@@ -0,0 +1,80 @@
+package simulation;
+
+import ast.Program;
+
+public interface SimpleCritter extends WorldObject
+{
+	/** Returns the ruleset of this critter. */
+	public Program getProgram();
+	
+	/** Returns the size of this critter. */
+	public int size();
+	
+	/** Returns the memory length of this critter. */
+	public int getMemLength();
+	
+	/** Returns the orientation of this critter. */
+	public int getOrientation();
+	
+	/** Returns the current energy level of this critter. */
+	public int getEnergy();
+	
+	/** Updates the critter's energy by the amount specified. */
+	public void updateEnergy(int amount, int maxEnergyPerSize);
+	
+	/** 
+	 * Returns the value of {@code memory[index]}.
+	 * @param index
+	 * @return the value of this critter's memory at the specified index, or {@code Integer.MIN_VALUE} if the index lies out-of-bounds
+	 */
+	public int readMemory(int index);
+	
+	/**
+	 * Sets the memory at index to val. Does nothing if {@code index} is an out-of-bounds or unassignable index
+	 * or if {@code val} is not within the restrictions of that array index.
+	 * @param val
+	 * @param index
+	 * @return Whether or not the memory array was actually altered
+	 */
+	public boolean setMemory(int val, int index);
+	
+	@Override
+	public int getAppearance();
+	
+	/** Returns a copy of the memory. */
+	public int[] getMemoryCopy();
+	
+	/** Returns the species name of this critter. */
+	public String getName();
+	
+	/** Returns a string representation of the last rule executed by this critter. */
+	public String getLastRule();
+	
+	/** Sets the last rule executed. */
+	public void setLastRule(String s);
+	
+	/** Increments the pass number of this critter (memory index 5) by one, if it is less than 999. */
+	public void incrementPass();
+	
+	/**
+	 * Turns this critter in the direction specified.
+	 * @param counterclockwise
+	 */
+	public void turn(boolean clockwise);
+	
+	/**
+	 * Returns an array of length 2 that symbolizes the change in position of a critter if it moves one hex in the specified direction.
+	 * @param forward : whether or not the hex will be accessed by moving forward or backward
+	 * @param dir : the direction the hex is in
+	 */
+	public int[] changeInPosition(boolean forward, int dir);
+	
+	/** Whether or not this critter wants to mate. */
+	public boolean wantsToMate();
+	
+	/** Turns mating signals of this critter on or off. */
+	public void toggleMatingPheromones(boolean b);
+	
+	/** Returns an integer value representing this critter's complexity. */
+	public int complexity(int ruleCost, int abilityCost);
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/SimpleWorld.java b/src/main/java/simulation/SimpleWorld.java
new file mode 100644
index 0000000..ac97405
--- /dev/null
+++ b/src/main/java/simulation/SimpleWorld.java
@@ -0,0 +1,51 @@
+package simulation;
+
+/** An interface containing the basic functions of the world. */
+public interface SimpleWorld
+{
+	/** Returns the minimum critter memory size for this world. Cannot be less than 8. */
+	int getMinMemory();
+	
+	/** Returns the maximum number of rules that may be executed per turn for this world. */
+	int getMaxRules();
+	
+	/** Returns the number of living critters currently in the simulation. */
+	int numRemainingCritters();
+	
+	/** Returns the amount of time passed since this world's genesis. */
+	int getTimePassed();
+	
+	/**
+	 * Loads critters of following a set pattern into this world.
+	 * @param filename the file containing the critter information
+	 * @param n the number of critters to load
+	 * @param direction the orientation of the critter. If this value is less than 0, a critter orientation
+	 * 					will be chosen at random.
+	 */
+	void loadCritters(String filename, int n, int direction);
+	
+	/** Advances the world state by a single time step. */
+	void advanceOneTimeStep();
+	
+	/** Determines whether or not a hex with column index {@code c} and row index {@code r} is on the world grid. */
+	boolean isValidHex(int c, int r);
+	
+	/**
+	 * Returns information about a hex. Assumes that the 
+	 * @param c
+	 * @param r
+	 * @return
+	 */
+	int analyzeHex(int c, int r);
+	
+	/**
+	 * 
+	 * @param c
+	 * @param r
+	 * @return
+	 */
+	SimpleCritter analyzeCritter(int c, int r);
+
+	/** Returns a StringBuilder containing the printed version of the world grid. */
+	StringBuilder printGrid();
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/World.java b/src/main/java/simulation/World.java
new file mode 100644
index 0000000..ae9bd56
--- /dev/null
+++ b/src/main/java/simulation/World.java
@@ -0,0 +1,845 @@
+package simulation;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Random;
+
+import ast.Program;
+import ast.ProgramImpl;
+import ast.Rule;
+
+/** A class to simulate the world state. */
+public class World extends AbstractWorld
+{
+	/** The name of this world. */
+	private String worldname;
+	/** Contains the hex grid of the world. */
+	private Hex[][] grid;
+	/** Maps each critter to a location in the world */
+	private HashMap<SimpleCritter, Hex> critterMap;
+	/** The number of columns in the world grid. */
+	private int columns;
+	/** The number of rows in the world grid. */
+	private int rows;
+	/** The number of hexes that lie on the world grid. */
+	private int numValidHexes;
+
+	/**
+	 * Loads a world based on a world description file.
+	 * 
+	 * @param filename The name of the file that contains world information.
+	 * @throws FileNotFoundException if the world file could not be found
+	 * 		   IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 */
+	public World(String filename) throws FileNotFoundException, IllegalArgumentException
+	{
+		// sets constants and initializes instance fields
+		super();
+		setConstants();
+		critterMap = new HashMap<SimpleCritter, Hex>();
+		super.critterList = new LinkedList<SimpleCritter>();
+		super.timePassed = 0;
+
+		BufferedReader bf = new BufferedReader(new FileReader(filename));
+
+		// parses the world name, and if no valid one is parsed, supplies a default one
+		worldname = FileParser.parseAttributeFromLine(bf, "name ");
+		if (worldname.equals(""))
+			worldname = "Arrakis";
+
+		// parses world dimensions, and supplies default ones if no valid dimensions are parsed
+		try
+		{
+			String worldDimensions = FileParser.parseAttributeFromLine(bf, "size ");
+			String[] dim = worldDimensions.split(" ");
+			columns = Integer.parseInt(dim[0]);
+			rows = Integer.parseInt(dim[1]);
+
+			if (!(columns > 0 && rows > 0 && 2 * rows - columns > 0))
+			{
+				columns = CONSTANTS.get("COLUMNS").intValue();
+				rows = CONSTANTS.get("ROWS").intValue();
+			}
+		}
+		catch (Exception e)
+		{
+			columns = CONSTANTS.get("COLUMNS").intValue();
+			rows = CONSTANTS.get("ROWS").intValue();
+		}
+		numValidHexes = 0;
+
+		// initializes world grid
+		grid = new Hex[columns][rows];
+		for (int i = 0; i < grid.length; i++)
+			for (int j = 0; j < grid[0].length; j++)
+				if (isValidHex(i, j))
+				{
+					grid[i][j] = new Hex(i, j);
+					numValidHexes++;
+				}
+
+		try
+		{
+			// loads in world objects from file
+			String line = bf.readLine();
+			while (line != null)
+			{
+				String[] info = line.split(" ");
+				switch (info[0])
+				{
+					case "rock":
+						addNonCritterObject(new Rock(), Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+						break;
+					case "food":
+						Food f = new Food(Integer.parseInt(info[3]));
+						addNonCritterObject(f, Integer.parseInt(info[1]), Integer.parseInt(info[2]));
+						break;
+					case "critter":
+						BufferedReader critterreader = new BufferedReader(new FileReader(info[1]));
+						SimpleCritter sc = FileParser.parseCritter(critterreader, getMinMemory(),
+								Integer.parseInt(info[4]));
+						if(sc == null)
+						{
+							System.err.println("The critter file " + filename + " does not have the right syntax, so it was not loaded.");
+							break;
+						}
+							
+						loadOneCritter(sc, Integer.parseInt(info[2]), Integer.parseInt(info[3]));
+						break;
+				}
+				line = bf.readLine();
+			}
+		}
+		catch (Exception e)
+		{
+			return;
+		}
+	}
+
+	/**
+	 * Generates a default size world containing nothing but randomly placed rocks.
+	 * @throws IllegalArgumentException if the world constants file could not be found or was improperly formatted
+	 */
+	public World() throws IllegalArgumentException
+	{
+		// sets constants and initializes instance fields
+		super();
+		worldname = "Arrakis";
+		setConstants();
+		critterMap = new HashMap<SimpleCritter, Hex>();
+		critterList = new LinkedList<SimpleCritter>();
+		timePassed = 0;
+
+		super.critterList = new LinkedList<SimpleCritter>();
+		super.timePassed = 0;
+
+		columns = CONSTANTS.get("COLUMNS").intValue();
+		rows = CONSTANTS.get("ROWS").intValue();
+		numValidHexes = 0;
+
+		grid = new Hex[columns][rows];
+		for (int i = 0; i < grid.length; i++)
+			for (int j = 0; j < grid[0].length; j++)
+			{
+				if (isValidHex(i, j))
+				{
+					grid[i][j] = new Hex(i, j);
+					numValidHexes++;
+				}
+			}
+
+		// randomly fills about 1/40 of the hexes in the world with rocks
+		int c = (int) (Math.random() * columns);
+		int r = (int) (Math.random() * rows);
+		int n = 0;
+		while (n < numValidHexes / 40)
+		{
+			c = (int) (Math.random() * columns);
+			r = (int) (Math.random() * rows);
+			if (isValidHex(c, r))
+			{
+				grid[c][r].addContent(new Rock());
+				n++;
+			}
+		}
+	}
+
+	/**
+	 * Parses the constants file in the project directory and stores the constants in the CONSTANTS field.
+	 * @throws IllegalArgumentException if the constants file couldn't be found or is improperly formatted
+	 */
+	private void setConstants() throws IllegalArgumentException
+	{
+		InputStream in = World.class.getResourceAsStream("constants.txt");
+		if(in == null)
+		{ 
+			System.err.println("The constants.txt file could not be found in bin/simulation.");
+			System.exit(0);
+		}
+		
+		BufferedReader bf = new BufferedReader(new InputStreamReader(in));
+		CONSTANTS = FileParser.parseConstants(bf);
+	}
+
+	@Override
+	public boolean isValidHex(int c, int r)
+	{
+		if (c < 0 || r < 0)
+			return false;
+		else if (c >= columns || r >= rows)
+			return false;
+		else if ((2 * r - c) < 0 || (2 * r - c) >= (2 * rows - columns))
+			return false;
+		return true;
+	}
+
+	@Override
+	public void loadCritters(String filename, int n, int direction)
+	{
+		try
+		{
+			BufferedReader br = new BufferedReader(new FileReader(filename));
+			SimpleCritter sc = FileParser.parseCritter(br, getMinMemory(), direction);
+
+			for (int i = 0; i < n; i++)
+			{
+
+				int randc = (int) (Math.random() * columns);
+				int randr = (int) (Math.random() * rows);
+				while (!isValidHex(randc, randr))
+				{
+					randc = (int) (Math.random() * columns);
+					randr = (int) (Math.random() * rows);
+				}
+
+				if (isValidHex(randc, randr))
+					loadOneCritter(sc, randc, randr);
+			}
+		}
+		catch (FileNotFoundException e)
+		{
+			System.err.println("Critter file not found.");
+			return;
+		}
+	}
+
+	/**
+	 * Loads a single critter into the world at the specified coordinates, if possible. Does nothing if
+	 * the hex is not within the world boundaries, or if there is something already present at the hex.
+	 * 
+	 * @param sc the critter to add
+	 * @param c the column index of the hex where the critter will be added
+	 * @param r the row index of the hex where the critter will be added
+	 */
+	private void loadOneCritter(SimpleCritter sc, int c, int r)
+	{
+		if (!isValidHex(c, r))
+			return;
+		boolean added = grid[c][r].addContent(sc);
+		if (added)
+		{
+			critterList.add(sc);
+			critterMap.put(sc, grid[c][r]);
+		}
+	}
+
+	/**
+	 * Loads a single non-critter world object into the world at the specified coordinates, if possible.
+	 * Does nothing if the hex is not within the world boundaries or if there is something already present at
+	 * the hex. This method cannot be used to add critters into the world. Use the method
+	 * {@code loadCritter(SimpleCritter sc, int c, int r)} instead.
+	 * 
+	 * @param sc the object to add
+	 * @param c the column index of the hex where the object will be added
+	 * @param r the row index of the hex where the object will be added
+	 */
+	private void addNonCritterObject(WorldObject wo, int c, int r)
+	{
+		if (wo instanceof Critter)
+			return;
+		if (!isValidHex(c, r))
+			return;
+		grid[c][r].addContent(wo);
+	}
+
+	/* ========================================= */
+	/* ----------- Critter Sensors ------------- */
+	/* ========================================= */
+
+	@Override
+	public int searchNearby(SimpleCritter sc, int dir)
+	{
+		//determines the row and column coordinates of the critter
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+		
+		// finds the hex to look in, based on the value of dir
+		if (dir < 0)
+			dir = 0;
+		else if (dir > 6)
+			dir %= 6;
+		int nearbyc = c + sc.changeInPosition(true, dir)[0];
+		int nearbyr = r + sc.changeInPosition(true, dir)[1];
+
+		// critters see rock when they look off the edge of the world
+		if (!isValidHex(nearbyc, nearbyr))
+			return -1;
+		Hex nearby = grid[nearbyc][nearbyr];
+		return nearby.hexAppearance();
+	}
+
+	@Override
+	public int searchAhead(SimpleCritter sc, int index)
+	{
+		//determines the row and column coordinates of the critter
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+		
+		if (index < 0)
+			index = 0;
+		int aheadc = c + sc.changeInPosition(true, sc.getOrientation())[0] * index;
+		int aheadr = r + sc.changeInPosition(true, sc.getOrientation())[1] * index;
+
+		if (!isValidHex(aheadc, aheadr))
+			return -1;
+		Hex nearby = grid[aheadc][aheadr];
+		return nearby.hexAppearance();
+	}
+
+	/* ========================================= */
+	/* ----------- Critter Actions ------------- */
+	/* ========================================= */
+
+	@Override
+	public void moveCritter(SimpleCritter sc, boolean forward)
+	{
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		int cost = CONSTANTS.get("MOVE_COST").intValue() * sc.size();
+		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		// if the critter did not have enough energy to complete this action, kills the critter
+		if (sc.getEnergy() < 0)
+		{
+			kill(sc);
+			return;
+		}
+
+		int[] changeInCoords = sc.changeInPosition(forward, sc.getOrientation());
+		int newc = c + changeInCoords[0];
+		int newr = r + changeInCoords[1];
+
+		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
+		{
+			if (sc.getEnergy() == 0)
+				kill(sc);
+			return;
+		}
+		grid[c][r].removeContent();
+		critterMap.remove(sc);
+		grid[newc][newr].addContent(sc);
+		critterMap.put(sc, grid[newc][newr]);
+		if (sc.getEnergy() == 0)
+			kill(sc);
+	}
+
+	@Override
+	public void turnCritter(SimpleCritter sc, boolean clockwise)
+	{
+		int cost = sc.size();
+		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		// if the critter did not have enough energy to complete this action, kills the critter
+		if (sc.getEnergy() < 0)
+		{
+			kill(sc);
+			return;
+		}
+
+		sc.turn(clockwise);
+		if (sc.getEnergy() == 0)
+			kill(sc);
+	}
+
+	@Override
+	public void critterEat(SimpleCritter sc)
+	{
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		int cost = sc.size();
+		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		// if the critter did not have enough energy to complete this action, kills the critter
+		if (sc.getEnergy() < 0)
+		{
+			kill(sc);
+			return;
+		}
+
+		int newc = c + sc.changeInPosition(true, sc.getOrientation())[0];
+		int newr = r + sc.changeInPosition(true, sc.getOrientation())[1];
+		if (!isValidHex(newc, newr))
+		{
+			if (sc.getEnergy() == 0)
+				kill(sc);
+			return;
+		}
+
+		Hex directlyInFront = grid[newc][newr];
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof Food)
+		{
+			Food nourishment = (Food) directlyInFront.getContent();
+			sc.updateEnergy(nourishment.getCalories(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+			directlyInFront.removeContent();
+		}
+		if (sc.getEnergy() == 0)
+			kill(sc);
+	}
+
+	@Override
+	public void growCritter(SimpleCritter sc)
+	{
+		int cost = sc.size()
+				* sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
+		sc.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		// if the critter did not have enough energy to complete this action, kills the critter
+		if (sc.getEnergy() < 0)
+		{
+			kill(sc);
+			return;
+		}
+
+		int currentSize = sc.readMemory(3);
+		sc.setMemory(currentSize + 1, 3);
+	}
+
+	@Override
+	public void critterBattle(SimpleCritter attacker)
+	{
+		Hex location = critterMap.get(attacker);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		int cost = attacker.size() * CONSTANTS.get("ATTACK_COST").intValue();
+		attacker.updateEnergy(-1 * cost, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		//if the critter did not have enough energy to complete this action, kills the critter
+		if (attacker.getEnergy() < 0)
+		{
+			kill(attacker);
+			return;
+		}
+
+		int newc = c + attacker.changeInPosition(true, attacker.getOrientation())[0];
+		int newr = r + attacker.changeInPosition(true, attacker.getOrientation())[1];
+		if (!isValidHex(newc, newr))
+		{
+			if (attacker.getEnergy() == 0)
+				kill(attacker);
+			return;
+		}
+
+		Hex directlyInFront = grid[newc][newr];
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
+		{
+			// Calculates the damage dealt to the target critter
+			SimpleCritter target = (SimpleCritter) (directlyInFront.getContent());
+			int baseDamage = CONSTANTS.get("BASE_DAMAGE").intValue();
+			double dmgMultiplier = CONSTANTS.get("DAMAGE_INC").doubleValue();
+			int dmgBeforeScaling = (attacker.size() * attacker.readMemory(2)) - (target.size() * target.readMemory(1));
+			int damage = baseDamage * attacker.size() * logisticFunction(dmgMultiplier * (double)dmgBeforeScaling);
+
+			// kills the target if it took damage greater than or equal to its current energy
+			target.updateEnergy(-1 * damage, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+			if (target.getEnergy() <= 0)
+				kill(target);
+		}
+
+		if (attacker.getEnergy() == 0)
+			kill(attacker);
+	}
+
+	/** Performs the logistic function 1 / (1 + e^-x), floored to an integer value. */
+	private int logisticFunction(double x)
+	{
+		double exponent = -1 * x;
+		return (int) (1 / (1 + Math.exp(exponent)));
+	}
+
+	@Override
+	public void critterBud(SimpleCritter sc)
+	{
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		int complexity = sc.complexity(CONSTANTS.get("RULE_COST").intValue(), CONSTANTS.get("ABILITY_COST").intValue());
+		sc.updateEnergy(-1 * CONSTANTS.get("BUD_COST").intValue() * complexity,
+				CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		//if the critter did not have enough energy to complete this action, kills the critter
+		if (sc.getEnergy() < 0)
+		{
+			kill(sc);
+			return;
+		}
+
+		int newc = c + sc.changeInPosition(false, sc.getOrientation())[0];
+		int newr = r + sc.changeInPosition(false, sc.getOrientation())[1];
+		if (!isValidHex(newc, newr) || !grid[newc][newr].isEmpty())
+		{
+			if (sc.getEnergy() == 0)
+				kill(sc);
+			return;
+		}
+
+		//Constructs the baby critter's memory, copying memory length, offense, and defense from the parent
+		int[] babymem = new int[sc.getMemLength()];
+		babymem[0] = sc.getMemLength();
+		babymem[1] = sc.readMemory(1);
+		babymem[2] = sc.readMemory(2);
+		babymem[3] = 1;
+		babymem[4] = 250;
+		for (int i = 5; i < babymem.length; i++)
+			babymem[i] = 0;
+
+		String name = sc.getName() + " Jr.";
+		Program prog = sc.getProgram();
+		int numMutations = numberMutations();
+		for (int i = 0; i < numMutations; i++)
+			prog = prog.mutate();
+
+		SimpleCritter baby = new Critter(prog, babymem, name, sc.getOrientation());
+		loadOneCritter(baby, newc, newr);
+
+		if (sc.getEnergy() == 0)
+			kill(sc);
+	}
+
+	@Override
+	public void critterMate(SimpleCritter sc)
+	{
+		sc.toggleMatingPheromones(true);
+		Hex location = critterMap.get(sc);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+		int behindColumnParent1 = c + sc.changeInPosition(false, sc.getOrientation())[0];
+		int behindRowParent1 = r + sc.changeInPosition(false, sc.getOrientation())[1];
+		if (!isValidHex(behindColumnParent1, behindRowParent1))
+		{
+			sc.toggleMatingPheromones(false);
+			return;
+		}
+		// coordinates of Parent 2
+		int columnParent2 = c + sc.changeInPosition(true, sc.getOrientation())[0];
+		int rowParent2 = r + sc.changeInPosition(true, sc.getOrientation())[1];
+		if (!isValidHex(columnParent2, rowParent2))
+		{
+			sc.toggleMatingPheromones(false);
+			return;
+		}
+		Hex directlyInFront = grid[columnParent2][rowParent2];
+		if (!(directlyInFront.getContent() instanceof SimpleCritter))
+		{
+			sc.toggleMatingPheromones(false);
+			return;
+		}
+		SimpleCritter parent2 = (SimpleCritter) (directlyInFront.getContent());
+		int behindColumnParent2 = columnParent2 + sc.changeInPosition(false, sc.getOrientation())[0];
+		int behindRowParent2 = rowParent2 + sc.changeInPosition(false, sc.getOrientation())[1];
+		if (!isValidHex(behindColumnParent2, behindRowParent2))
+		{
+			sc.toggleMatingPheromones(false);
+			return;
+		}
+		// checks if Parent 2 wants to mate
+		if (!parent2.wantsToMate())
+			return;
+		int parent1Direction = sc.getOrientation();
+		int parent2Direction = parent2.getOrientation();
+
+		// direction checking
+		if (!(Math.abs(parent1Direction - parent2Direction) == 3))
+		{
+			sc.toggleMatingPheromones(false);
+			return;
+		}
+
+		// energy calculation
+		sc.updateEnergy(-sc.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+		parent2.updateEnergy(-parent2.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+		if (sc.getEnergy() < 0 || parent2.getEnergy() < 0)
+		{
+			if (sc.getEnergy() < 0)
+				kill(sc);
+			if (parent2.getEnergy() < 0)
+				kill(parent2);
+			return;
+		}
+		initiateMatingProcess(sc, parent2);
+	}
+
+	/** Randomly determines the number of mutations that will occur during mating or budding. */
+	private int numberMutations()
+	{
+		double randomNumber = Math.random();
+		int returnValue = 0;
+		double temp = 0.25;
+
+		for (int i = 0; i < 10; i++)
+		{
+			if (randomNumber < temp)
+				returnValue++;
+			temp = Math.pow(0.25, i + 1);
+		}
+		return returnValue;
+	}
+
+	/** Executes the mating process, as long as there is one empty hex around the two critters. */
+	private void initiateMatingProcess(SimpleCritter sc1, SimpleCritter sc2)
+	{
+		Random random = new Random();
+		// energy calculation
+		int complexity1 = sc1.complexity(CONSTANTS.get("RULE_COST").intValue(),
+				CONSTANTS.get("ABILITY_COST").intValue());
+		int complexity2 = sc2.complexity(CONSTANTS.get("RULE_COST").intValue(),
+				CONSTANTS.get("ABILITY_COST").intValue());
+		sc1.updateEnergy(-5 * complexity1, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+		sc2.updateEnergy(-5 * complexity2, CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+		if (sc1.getEnergy() < 0 || sc2.getEnergy() < 0)
+		{
+			if (sc1.getEnergy() < 0)
+				kill(sc1);
+			if (sc2.getEnergy() < 0)
+				kill(sc2);
+			return;
+		}
+
+		// generating RuleSet
+		LinkedList<Rule> babyRules = new LinkedList<Rule>();
+		int ruleSetSize = 0;
+		if (random.nextBoolean())
+			ruleSetSize = sc1.getProgram().getRulesList().size();
+		else
+			ruleSetSize = sc2.getProgram().getRulesList().size();
+		for (int i = 0; i < ruleSetSize; i++)
+		{
+			if (random.nextBoolean())
+			{
+				if (i >= sc1.getProgram().getRulesList().size())
+					babyRules.add(sc2.getProgram().getRulesList().get(i));
+				else
+					babyRules.add(sc1.getProgram().getRulesList().get(i));
+			}
+			else
+			{
+				if (i >= sc2.getProgram().getRulesList().size())
+					babyRules.add(sc1.getProgram().getRulesList().get(i));
+				else
+					babyRules.add(sc2.getProgram().getRulesList().get(i));
+			}
+		}
+		Program prog = new ProgramImpl(babyRules);
+
+		//generating memory
+		int[] babymem = null;
+		if (random.nextBoolean())
+		{
+			babymem = new int[sc1.getMemLength()];
+			babymem[0] = sc1.getMemLength();
+		}
+		else
+		{
+			babymem = new int[sc2.getMemLength()];
+			babymem[0] = sc2.getMemLength();
+		}
+		for (int i = 1; i <= 2; i++)
+		{
+			if (random.nextBoolean())
+				babymem[i] = sc1.readMemory(i);
+			else
+				babymem[i] = sc2.readMemory(i);
+		}
+		babymem[3] = 1;
+		babymem[4] = 250;
+		for (int i = 5; i < babymem.length; i++)
+			babymem[i] = 0;
+
+		// coordinate Generation
+		int babyColumn = 0;
+		int babyRow = 0;
+		if (random.nextBoolean())
+		{
+			Hex location = critterMap.get(sc1);
+			babyColumn = location.getColumnIndex() + sc1.changeInPosition(false, sc1.getOrientation())[0];
+			babyRow = location.getRowIndex() + sc1.changeInPosition(false, sc1.getOrientation())[1];
+		}
+		else
+		{
+			Hex location = critterMap.get(sc2);
+			babyColumn = location.getColumnIndex() + sc2.changeInPosition(false, sc2.getOrientation())[0];
+			babyRow = location.getRowIndex() + sc2.changeInPosition(false, sc2.getOrientation())[1];
+		}
+
+		int numMutations = numberMutations();
+		for (int i = 0; i < numMutations; i++)
+			prog = prog.mutate();
+		String name = sc1.getName() + sc2.getName() + " Jr.";
+		SimpleCritter baby = new Critter(prog, babymem, name, 0);
+		loadOneCritter(baby, babyColumn, babyRow);
+
+		if (sc1.getEnergy() == 0 || sc2.getEnergy() == 0)
+		{
+			if (sc1.getEnergy() == 0)
+				kill(sc1);
+			if (sc2.getEnergy() == 0)
+				kill(sc2);
+			return;
+		}
+		sc1.toggleMatingPheromones(false);
+		sc2.toggleMatingPheromones(false);
+	}
+
+	@Override
+	public void critterTag(SimpleCritter tagger, int val)
+	{
+		Hex location = critterMap.get(tagger);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		tagger.updateEnergy(-1 * tagger.size(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		//if the critter did not have enough energy to complete this action, kills the critter
+		if (tagger.getEnergy() < 0)
+		{
+			kill(tagger);
+			return;
+		}
+
+		int newc = c + tagger.changeInPosition(true, tagger.getOrientation())[0];
+		int newr = r + tagger.changeInPosition(true, tagger.getOrientation())[1];
+		if (!isValidHex(newc, newr))
+		{
+			if (tagger.getEnergy() == 0)
+				kill(tagger);
+			return;
+		}
+
+		Hex directlyInFront = grid[newc][newr];
+		if (!directlyInFront.isEmpty() && directlyInFront.getContent() instanceof SimpleCritter)
+		{
+			SimpleCritter taggee = (SimpleCritter) (directlyInFront.getContent());
+			if (!(val < 0 || val > 99))
+				taggee.setMemory(val, 6);
+		}
+
+		if (tagger.getEnergy() == 0)
+			kill(tagger);
+	}
+
+	@Override
+	public void critterServe(SimpleCritter donator, int index)
+	{
+		Hex location = critterMap.get(donator);
+		int c = location.getColumnIndex();
+		int r = location.getRowIndex();
+
+		if (index < 0)
+			index = 0;
+		else if(index > donator.getEnergy() + donator.size())
+			index = donator.getEnergy() + donator.size();
+
+		donator.updateEnergy(-1 * (donator.size() + index), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+
+		//if the critter did not have enough energy to complete this action, kills the critter
+		if (donator.getEnergy() < 0)
+		{
+			kill(donator);
+			return;
+		}
+
+		int newc = c + donator.changeInPosition(true, donator.getOrientation())[0];
+		int newr = r + donator.changeInPosition(true, donator.getOrientation())[1];
+		if (!isValidHex(newc, newr))
+		{
+			if (donator.getEnergy() == 0)
+				kill(donator);
+			return;
+		}
+
+		Hex directlyInFront = grid[newc][newr];
+		if (directlyInFront.isEmpty())
+		{
+			Food f = new Food(index);
+			directlyInFront.addContent(f);
+		}
+		if (donator.getEnergy() == 0)
+			kill(donator);
+	}
+
+	@Override
+	public void critterSoakEnergy(SimpleCritter sc)
+	{
+		sc.updateEnergy(CONSTANTS.get("SOLAR_FLUX").intValue(), CONSTANTS.get("ENERGY_PER_SIZE").intValue());
+	}
+
+	/** Kills a critter and removes it from any lists or mappings of critters. Rest in peace, buddy. */
+	private void kill(SimpleCritter sc)
+	{
+		Hex location = critterMap.get(sc);
+		location.removeContent();
+		critterMap.remove(sc);
+		critterList.remove(sc);
+
+		Food remnant = new Food(CONSTANTS.get("FOOD_PER_SIZE").intValue() * sc.size());
+		location.addContent(remnant);
+	}
+
+	@Override
+	public StringBuilder printGrid()
+	{	
+		StringBuilder result = new StringBuilder();
+		for(int i = 0; i < 2 * rows - columns; i++)
+		{
+			StringBuilder sb = new StringBuilder();
+			if(i % 2 != 0)
+				sb.append("  ");
+			for(int c = i % 2, r = (int) Math.ceil(i / 2.0); c < columns && r < rows; c += 2, r++)
+			{
+				if(isValidHex(c, r))
+					sb.append("" + grid[c][r].toString() + "   ");
+			}
+			result.insert(0, sb.toString() + "\n");
+		}
+		result.insert(0, "World name: " + worldname + "\n");
+		return result;
+	}
+	
+	@Override
+	public int analyzeHex(int c, int r)
+	{
+		if(!isValidHex(c, r))
+			return Integer.MIN_VALUE;
+		return grid[c][r].hexAppearance();
+	}
+	
+	@Override
+	public SimpleCritter analyzeCritter(int c, int r)
+	{
+		if(!isValidHex(c, r) || !(grid[c][r].getContent() instanceof SimpleCritter))
+			return null;
+		return (SimpleCritter) (grid[c][r].getContent());
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/simulation/WorldObject.java b/src/main/java/simulation/WorldObject.java
new file mode 100644
index 0000000..4b03632
--- /dev/null
+++ b/src/main/java/simulation/WorldObject.java
@@ -0,0 +1,16 @@
+package simulation;
+
+public interface WorldObject
+{
+	/** Returns the ASCII art representation of this object. */
+	public String toString();
+	
+	/** 
+	 * Returns an integer value based on this world object. This value depends on the type of this object:
+	 * 		   <ul><li>If this object is a critter, the value will be a positive integer equal to the critter's
+	 * 				   appearance, as determined by {@code SimpleCritter.getAppearance()}.</li>
+	 * 		   <li>If this object is a rock, the value will be -1.</li>
+	 * 		   <li>If the hex contains food, the value will be {@code -1 * ([food calories] + 1)}.</li.</ul>
+	 */
+	public int getAppearance();
+}
\ No newline at end of file
diff --git a/src/main/resources/constants.txt b/src/main/resources/constants.txt
new file mode 100644
index 0000000..52649f0
--- /dev/null
+++ b/src/main/resources/constants.txt
@@ -0,0 +1,19 @@
+BASE_DAMAGE 100 {The multiplier for all damage done by attacking}
+DAMAGE_INC 0.2 {Controls how quickly increased offensive or defensive ability affects damage}
+ENERGY_PER_SIZE 500 {How much energy a critter can have per point of size}
+FOOD_PER_SIZE 200 {How much food is created per point of size when a critter dies}
+MAX_SMELL_DISTANCE 10 {Maximum distance at which food can be sensed}
+ROCK_VALUE -1 {The value reported when a rock is sensed}
+COLUMNS 50 {Default number of columns in the world map}
+ROWS 68 {Default number of rows in the world map}
+MAX_RULES_PER_TURN 999 {The maximum number of rules that can be run per critter turn}
+SOLAR_FLUX 1 {Energy gained from sun by doing nothing}
+MOVE_COST 3 {Energy cost of moving (per unit size)}
+ATTACK_COST 5 {Energy cost of attacking (per unit size)}
+GROW_COST 1 {Energy cost of growing (per size and complexity)}
+BUD_COST 9 {Energy cost of budding (per unit complexity)}
+MATE_COST 5 {Energy cost of successful mating (per unit complexity)}
+RULE_COST 2 {Complexity cost of having a rule}
+ABILITY_COST 25 {Complexity cost of having an ability point}
+INITIAL_ENERGY 250 {Energy of a newly birthed critter}
+MIN_MEMORY 8 {Minimum number of memory entries in a critter}
\ No newline at end of file
diff --git a/src/main/resources/world.txt b/src/main/resources/world.txt
new file mode 100644
index 0000000..91bdd68
--- /dev/null
+++ b/src/main/resources/world.txt
@@ -0,0 +1,14 @@
+name Small world
+size 10 15
+rock 2 2
+rock 3 6
+rock 9 10
+
+// Some food
+food 4 4 500
+food 1 3 1000
+
+// example-critter.txt should be in the working directory
+critter example-critter.txt 2 5 3
+critter example-critter.txt 4 3 1
+critter example-critter.txt 4 4 2
diff --git a/src/test/java/asttests/RemoveTest.java b/src/test/java/asttests/RemoveTest.java
deleted file mode 100644
index 86ace0d..0000000
--- a/src/test/java/asttests/RemoveTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package asttests;
-
-import static org.junit.Assert.*;
-
-import java.util.LinkedList;
-import org.junit.Test;
-
-import ast.*;
-import ast.BinaryCondition.Operator;
-import ast.BinaryExpr.MathOp;
-import ast.Relation.RelOp;
-import ast.UnaryExpr.ExprType;
-
-/**
- * 
- * RemoveTest tests the remove function for the different Node types.
- *
- */
-public class RemoveTest
-{	
-	@Test
-	public void testUpdate1()
-	{
-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
-		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
-		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
-		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
-		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
-		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
-		Command c = new Command(ll, u6);
-		
-		int previousSize = c.size();
-		u2.acceptMutation(new MutationRemove(true));
-		assertTrue(previousSize > c.size());
-		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
-	}
-	
-	@Test
-	public void testUpdate2()
-	{
-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		ll.add(u);
-		Command c = new Command(ll, u2);
-		
-		int previousSize = c.size();
-		u2.acceptMutation(new MutationRemove(true));
-		assertTrue(previousSize > c.size());
-		assertTrue(c.toString().equals(u.toString()));
-	}
-	
-	@Test
-	public void testUpdate3()
-	{
-		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
-		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		ll.add(u);
-		Command c = new Command(ll, u2);
-		
-		int previousSize = c.size();
-		u.acceptMutation(new MutationRemove(true));
-		assertTrue(previousSize > c.size());
-		assertTrue(c.toString().equals(u2.toString()));
-	}
-	@Test
-	public void testChildlessUnaryExpr()
-	{
-		UnaryExpr ue = new UnaryExpr(3);
-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
-		String before = be.toString();
-		ue.acceptMutation(new MutationRemove(true));
-		assertTrue(before.equals(be.toString()));
-	}
-	
-	@Test
-	public void testUnaryExpr()
-	{
-		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
-		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
-		
-		int previousSize = be.size();
-		String before = be.toString();
-		ue.acceptMutation(new MutationRemove(true));
-		assertTrue(previousSize > be.size());
-		assertTrue("3 + 2".equals(be.toString()));
-	}
-	
-	@Test
-	public void testCondition()
-	{
-		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
-		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
-		UnaryExpr e1 = new UnaryExpr(2);
-		UnaryExpr e2 = new UnaryExpr(12);
-		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
-		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
-		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
-		Condition con = new BinaryCondition(r1, Operator.AND, r2);
-		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		LinkedList<Update> ll = new LinkedList<Update>();
-		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
-		ll.add(u2);
-		ll.add(u3);
-		ll.add(u4);
-		Command c = new Command(ll, u);
-		Rule rule = new Rule(con, c);
-		
-		con.acceptMutation(new MutationRemove(true));
-		Rule predictedMutatedRule = new Rule(r1, c);
-		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
-	}
-}
\ No newline at end of file
diff --git a/src/test/java/interpretertests/EvalSensingTest.java b/src/test/java/interpretertests/EvalSensingTest.java
new file mode 100644
index 0000000..ac1c857
--- /dev/null
+++ b/src/test/java/interpretertests/EvalSensingTest.java
@@ -0,0 +1,120 @@
+package interpretertests;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+
+import ast.*;
+import ast.BinaryCondition.Operator;
+import ast.BinaryExpr.MathOp;
+import ast.Relation.RelOp;
+import ast.UnaryExpr.ExprType;
+import console.Console;
+import interpret.Interpreter;
+import interpret.InterpreterImpl;
+import simulation.Critter;
+import simulation.World;
+
+import org.junit.Test;
+
+public class EvalSensingTest
+{
+	int[] arr = {3, 5};
+	Interpreter i;
+	
+	@Before
+	public void setUp()
+	{
+		i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+	}
+	
+	@Test
+	public void testEvalBinaryCondition()
+	{
+		UnaryExpr e1 = new UnaryExpr(2);
+		UnaryExpr e2 = new UnaryExpr(12);
+		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+		
+		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
+		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
+		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
+		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
+		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
+		
+		assertTrue(new BinaryCondition(r1, Operator.AND, r2).acceptEvaluation(i));
+		assertTrue(new BinaryCondition(r1, Operator.OR, r2).acceptEvaluation(i));
+		assertTrue(new BinaryCondition(r1, Operator.OR, r3).acceptEvaluation(i));
+		assertFalse(new BinaryCondition(r1, Operator.AND, r3).acceptEvaluation(i));
+		assertFalse(new BinaryCondition(r3, Operator.AND, r4).acceptEvaluation(i));
+		assertFalse(new BinaryCondition(r5, Operator.OR, r3).acceptEvaluation(i));
+	}
+
+	@Test
+	public void testEvalRelation()
+	{
+		int[] arr = {3, 5};
+		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+		UnaryExpr e1 = new UnaryExpr(2);
+		UnaryExpr e2 = new UnaryExpr(12);
+		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+		
+		Relation r1 = new Relation(e5, RelOp.GREATER, e6); //should be true
+		Relation r2 = new Relation(e5, RelOp.NOTEQUAL, e6); //should be true
+		Relation r3 = new Relation(e1, RelOp.EQUAL, e2); //should be false
+		Relation r4 = new Relation(e1, RelOp.LESSOREQ, e2); //should be true
+		Relation r5 = new Relation(e1, RelOp.GREATEROREQ, e2); //should be false
+		assertTrue(r1.acceptEvaluation(i));
+		assertTrue(r2.acceptEvaluation(i));
+		assertFalse(r3.acceptEvaluation(i));
+		assertTrue(r4.acceptEvaluation(i));
+		assertFalse(r5.acceptEvaluation(i));
+	}
+
+	@Test
+	public void testEvalBinaryExpr()
+	{
+		int[] arr = {3, 5};
+		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+		UnaryExpr e1 = new UnaryExpr(2);
+		UnaryExpr e2 = new UnaryExpr(12);
+		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2); //should be 24
+		UnaryExpr e4 = new UnaryExpr(e3, ExprType.NEGATION); //should be -24
+		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67)); //should be be 73
+		
+		BinaryExpr e6 = new BinaryExpr(e5, MathOp.DIVIDE, e4); //should be -3
+		assertEquals(e3.acceptEvaluation(i), 24);
+		assertEquals(e4.acceptEvaluation(i), -24);
+		assertEquals(e5.acceptEvaluation(i), 73);
+		assertEquals(e6.acceptEvaluation(i), -3);
+	}
+
+	@Test
+	public void testEvalUnaryExpr()
+	{
+		int[] arr = {3, 5};
+		Interpreter i = new InterpreterImpl(new Critter(null, arr, "TESTCRITTER"), new World());
+		
+		UnaryExpr e1 = new UnaryExpr(123123);
+		UnaryExpr e2 = new UnaryExpr(253);
+		
+		assertEquals(123123, e1.acceptEvaluation(i));
+		assertEquals(253, e2.acceptEvaluation(i));
+	}
+	
+	@Test
+	/** If the critter in this world senses the world boundary, it will backup. */
+	public void testSenseWorldEdge()
+	{
+		Console c = new Console();
+		c.loadWorld("src/test/resources/simulationTests/SensingWorld.txt");
+		c.worldInfo();
+		c.advanceTime(1);
+		c.worldInfo();
+	}
+}
\ No newline at end of file
diff --git a/src/test/java/mutationtests/TestMutateDuplicate.java b/src/test/java/mutationtests/TestMutateDuplicate.java
index 3bc10ca..5d75a27 100644
--- a/src/test/java/mutationtests/TestMutateDuplicate.java
+++ b/src/test/java/mutationtests/TestMutateDuplicate.java
@@ -13,13 +13,11 @@ import ast.MutationReplace;
 import ast.Program;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 
 /**
- * 
  * This test class essentially tests the Duplicate Mutation by applying the Duplicate Mutation to random nodes 
  * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
- *
  */
 public class TestMutateDuplicate {
 
@@ -27,7 +25,7 @@ public class TestMutateDuplicate {
 
 	@Before
 	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
 		Reader r = new BufferedReader(new InputStreamReader(in));
 		Parser p = ParserFactory.getParser();
 		prog = p.parse(r);
diff --git a/src/test/java/mutationtests/TestMutateInsert.java b/src/test/java/mutationtests/TestMutateInsert.java
index 7e07e96..e1a07bd 100644
--- a/src/test/java/mutationtests/TestMutateInsert.java
+++ b/src/test/java/mutationtests/TestMutateInsert.java
@@ -19,7 +19,7 @@ import ast.Sensor;
 import ast.UnaryExpr;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 
 /**
  * 
@@ -32,7 +32,7 @@ public class TestMutateInsert {
 	Program prog;
 	@Before
 	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
         Reader r = new BufferedReader(new InputStreamReader(in));
         Parser p = ParserFactory.getParser();
         prog = p.parse(r);
diff --git a/src/test/java/mutationtests/TestMutateRemove.java b/src/test/java/mutationtests/TestMutateRemove.java
index 6128c76..f20e9c7 100644
--- a/src/test/java/mutationtests/TestMutateRemove.java
+++ b/src/test/java/mutationtests/TestMutateRemove.java
@@ -1,48 +1,164 @@
 package mutationtests;
 
+import static org.junit.Assert.assertTrue;
+
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.util.LinkedList;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import ast.BinaryCondition;
+import ast.BinaryExpr;
+import ast.Command;
+import ast.Condition;
 import ast.MutationRemove;
 import ast.Program;
+import ast.Relation;
 import ast.Rule;
+import ast.UnaryExpr;
 import ast.Update;
+import ast.BinaryCondition.Operator;
+import ast.BinaryExpr.MathOp;
+import ast.Relation.RelOp;
+import ast.UnaryExpr.ExprType;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 
 /**
- * 
- * This test class essentially tests the Remove Mutation by applying the Random Mutation to random nodes 
- * in the program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
- *
+ * This test class essentially tests the Remove Mutation by applying the mutation to random nodes in the
+ * program. If the mutation cannot be handled then an error statement is printed and the test ends gracefully.
  */
-public class TestMutateRemove {
+public class TestMutateRemove
+{
 	Program prog;
 
 	@Before
-	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+	public void setup()
+	{
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
 		Reader r = new BufferedReader(new InputStreamReader(in));
 		Parser p = ParserFactory.getParser();
 		prog = p.parse(r);
 	}
 	
 	@Test
-	public void testMutate() {
+	public void testRandom()
+	{
 		int n = 0;
 		for (int i = 0; i < prog.size(); i++)
+		{
 			n = (int) (Math.random() * (prog.size()));
-			try {
+			try 
+			{
 				System.out.println(prog.mutate(n, new MutationRemove(true)).toString());
-			} catch (NullPointerException e) {
+			}
+			catch (NullPointerException e)
+			{
 				 System.out.println("Incompatible node type");
 			}
+		}
+	}
+	
+	@Test
+	public void testUpdate1()
+	{
+		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+		Update u2 = new Update(new UnaryExpr(2), new UnaryExpr(2));
+		Update u3 = new Update(new UnaryExpr(3), new UnaryExpr(3));
+		Update u4 = new Update(new UnaryExpr(4), new UnaryExpr(4));
+		Update u5 = new Update(new UnaryExpr(5), new UnaryExpr(5));
+		Update u6 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+		LinkedList<Update> ll = new LinkedList<Update>();
+		ll.add(u); ll.add(u2); ll.add(u3); ll.add(u4); ll.add(u5);
+		Command c = new Command(ll, u6);
+		
+		int previousSize = c.size();
+		u2.acceptMutation(new MutationRemove(true));
+		assertTrue(previousSize > c.size());
+		assertTrue(c.toString().equals(u.toString() + "\n" + u3.toString() + "\n" + u4.toString() + "\n" + u5.toString() + "\n" + u6.toString()));
+	}
+	
+	@Test
+	public void testUpdate2()
+	{
+		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+		LinkedList<Update> ll = new LinkedList<Update>();
+		ll.add(u);
+		Command c = new Command(ll, u2);
+		
+		int previousSize = c.size();
+		u2.acceptMutation(new MutationRemove(true));
+		assertTrue(previousSize > c.size());
+		assertTrue(c.toString().equals(u.toString()));
+	}
+	
+	@Test
+	public void testUpdate3()
+	{
+		Update u = new Update(new UnaryExpr(1), new UnaryExpr(1));
+		Update u2 = new Update(new UnaryExpr(6), new UnaryExpr(6));
+		LinkedList<Update> ll = new LinkedList<Update>();
+		ll.add(u);
+		Command c = new Command(ll, u2);
+		
+		int previousSize = c.size();
+		u.acceptMutation(new MutationRemove(true));
+		assertTrue(previousSize > c.size());
+		assertTrue(c.toString().equals(u2.toString()));
+	}
+	@Test
+	public void testChildlessUnaryExpr()
+	{
+		UnaryExpr ue = new UnaryExpr(3);
+		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+		String before = be.toString();
+		ue.acceptMutation(new MutationRemove(true));
+		assertTrue(before.equals(be.toString()));
+	}
+	
+	@Test
+	public void testUnaryExpr()
+	{
+		UnaryExpr ue = new UnaryExpr(new UnaryExpr(3), ExprType.MEMORYVAL);
+		BinaryExpr be = new BinaryExpr(ue, MathOp.ADD, new UnaryExpr(2));
+		
+		int previousSize = be.size();
+		String before = be.toString();
+		ue.acceptMutation(new MutationRemove(true));
+		assertTrue(previousSize > be.size());
+		assertTrue("3 + 2".equals(be.toString()));
+	}
+	
+	@Test
+	public void testCondition()
+	{
+		UnaryExpr e = new UnaryExpr(new UnaryExpr(7), ExprType.MEMORYVAL);
+		BinaryExpr e5 = new BinaryExpr(new UnaryExpr(6), MathOp.ADD, new UnaryExpr(67));
+		UnaryExpr e1 = new UnaryExpr(2);
+		UnaryExpr e2 = new UnaryExpr(12);
+		BinaryExpr e3 = new BinaryExpr(e1, MathOp.MULTIPLY, e2);
+		Relation r1 = new Relation(e, RelOp.NOTEQUAL, new UnaryExpr(17));
+		Relation r2 = new Relation(e3, RelOp.GREATER, e5);
+		Condition con = new BinaryCondition(r1, Operator.AND, r2);
+		Update u = new Update(new UnaryExpr(7), new UnaryExpr(17));
+		LinkedList<Update> ll = new LinkedList<Update>();
+		Update u2 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+		Update u3 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+		Update u4 = new Update(new UnaryExpr(7), new UnaryExpr(17));
+		ll.add(u2);
+		ll.add(u3);
+		ll.add(u4);
+		Command c = new Command(ll, u);
+		Rule rule = new Rule(con, c);
+		
+		con.acceptMutation(new MutationRemove(true));
+		Rule predictedMutatedRule = new Rule(r1, c);
+		assertTrue(predictedMutatedRule.toString().equals(rule.toString()));
 	}
 }
diff --git a/src/test/java/mutationtests/TestMutateReplace.java b/src/test/java/mutationtests/TestMutateReplace.java
index 22513a6..5f70bb3 100644
--- a/src/test/java/mutationtests/TestMutateReplace.java
+++ b/src/test/java/mutationtests/TestMutateReplace.java
@@ -13,7 +13,7 @@ import ast.MutationTransform;
 import ast.Program;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 
 /**
  * 
@@ -27,7 +27,7 @@ public class TestMutateReplace {
 
 	@Before
 	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
 		Reader r = new BufferedReader(new InputStreamReader(in));
 		Parser p = ParserFactory.getParser();
 		prog = p.parse(r);
diff --git a/src/test/java/mutationtests/TestMutateSwap.java b/src/test/java/mutationtests/TestMutateSwap.java
index 3e4206a..d5b046b 100644
--- a/src/test/java/mutationtests/TestMutateSwap.java
+++ b/src/test/java/mutationtests/TestMutateSwap.java
@@ -17,7 +17,7 @@ import ast.MutationInsert;
 import ast.BinaryExpr.*;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 import ast.MutationSwap;
 import ast.Program;
 import ast.UnaryExpr;
@@ -34,7 +34,7 @@ public class TestMutateSwap {
 	Program prog;
 	@Before
 	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
         Reader r = new BufferedReader(new InputStreamReader(in));
         Parser p = ParserFactory.getParser();
         prog = p.parse(r);
diff --git a/src/test/java/mutationtests/TestMutateTransform.java b/src/test/java/mutationtests/TestMutateTransform.java
index ee87cca..4011203 100644
--- a/src/test/java/mutationtests/TestMutateTransform.java
+++ b/src/test/java/mutationtests/TestMutateTransform.java
@@ -23,7 +23,7 @@ import ast.UnaryExpr;
 import ast.Update;
 import parse.Parser;
 import parse.ParserFactory;
-import parsertests.ParserTest;
+import parsertests.ASTParserTest;
 
 /**
  * 
@@ -37,7 +37,7 @@ public class TestMutateTransform {
 
 	@Before
 	public void setup() {
-		InputStream in = ParserTest.class.getResourceAsStream("example-rules.txt");
+		InputStream in = ASTParserTest.class.getResourceAsStream("example-rules.txt");
 		Reader r = new BufferedReader(new InputStreamReader(in));
 		Parser p = ParserFactory.getParser();
 		prog = p.parse(r);
diff --git a/src/test/java/parsertests/ParserTest.java b/src/test/java/parsertests/ASTParserTest.java
similarity index 92%
rename from src/test/java/parsertests/ParserTest.java
rename to src/test/java/parsertests/ASTParserTest.java
index 4d3711c..2789d73 100644
--- a/src/test/java/parsertests/ParserTest.java
+++ b/src/test/java/parsertests/ASTParserTest.java
@@ -15,19 +15,19 @@ import parse.ParserFactory;
 import parse.Tokenizer;
 
 /** This class contains tests for the Critter parser. */
-public class ParserTest
+public class ASTParserTest
 {
     /** Checks that a valid critter program is not {@code null} when parsed. 
      * Different test cases were run using this same method by changing the filename for the input stream
      * This methodology was implemented because the program terminates elsewhere in the program, so the 
      * remainder of the tests cannot be performed. A key of the filename and the type of error it tests is included
      * in the overview.
-     * */
+     */
 	
     @Test
     public void testProgramIsNotNull()
     {
-        InputStream in = ParserTest.class.getResourceAsStream("draw_critter.txt");
+        InputStream in = ASTParserTest.class.getResourceAsStream("draw_critter.txt");
         Reader r = new BufferedReader(new InputStreamReader(in));
         Parser p = ParserFactory.getParser();
         Program prog = p.parse(r);
diff --git a/src/test/java/parsertests/FileParserTest.java b/src/test/java/parsertests/FileParserTest.java
new file mode 100644
index 0000000..52571a2
--- /dev/null
+++ b/src/test/java/parsertests/FileParserTest.java
@@ -0,0 +1,149 @@
+package parsertests;
+
+import static org.junit.Assert.*;
+import java.io.*;
+import org.junit.Test;
+
+import ast.Program;
+import parse.Parser;
+import parse.ParserFactory;
+import simulation.Critter;
+import simulation.FileParser;
+import simulation.SimpleCritter;
+
+public class FileParserTest
+{
+
+	@Test
+	public void testParseAttributes1()
+	{
+		try
+		{
+			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/example-critter.txt")));
+			
+			assertEquals(test.length, 7);
+			assertTrue(test[0].equals("example"));
+			assertTrue(test[1].equals("9"));
+			assertTrue(test[2].equals("2"));
+			assertTrue(test[3].equals("3"));
+			assertTrue(test[4].equals("1"));
+			assertTrue(test[5].equals("500"));
+			assertTrue(test[6].equals("17"));
+		}
+		catch (FileNotFoundException e)
+		{
+			fail();
+		}
+	}
+	
+	@Test
+	public void testParseAttributes2()
+	{
+		try
+		{
+			String[] test = FileParser.parseAttributes(new BufferedReader(new FileReader("examples/failure-example-critter1.txt")));
+			
+			assertEquals(test.length, 7);
+			assertTrue(test[0].equals(""));
+			assertTrue(test[1].equals(""));
+			assertTrue(test[2].equals(""));
+			assertTrue(test[3].equals(""));
+			assertTrue(test[4].equals(""));
+			assertTrue(test[5].equals(""));
+			assertTrue(test[6].equals(""));
+		}
+		catch (FileNotFoundException e)
+		{
+			fail();
+		}
+	}
+	
+	@Test
+	public void testConsoleLoad() //TODO remove when done testing
+	{
+		try
+		{
+			BufferedReader br = new BufferedReader(new FileReader("examples/example-critter.txt"));
+			String[] parsed = FileParser.parseAttributes(br);
+			String name = parsed[0].equals("") ? "Untitled" : parsed[0];
+			int[] critAttr = makeCritterAttributes(parsed);
+			
+			Parser p = ParserFactory.getParser();
+			Program prog = p.parse(br);
+			
+			SimpleCritter sc = new Critter(prog, critAttr, name, -1);
+		}
+		catch (FileNotFoundException e)
+		{
+			System.err.println("Critter file not found.");
+			return;
+		}
+	}
+	
+	/**
+	 * Prepares an int array to be used as critter memory, based on a string array.<br>
+	 * Precondition: the parameter {@code strs} MUST have been generated by the method {@code FileParser.parseAttributes(filename)}.
+	 * @param strs an array of strings created by the method {@code FileParser.parseAttributes(filename)}
+	 * @return an int array, ready to be used as critter memory
+	 */
+	private int[] makeCritterAttributes(String[] strs)
+	{
+		int[] critterAttributes;
+		
+		int memsize = parseIntFromString(strs[1]);
+		if(memsize < 8)
+			memsize = 8;
+		critterAttributes = new int[memsize];
+		critterAttributes[0] = memsize;
+		
+		int defense = parseIntFromString(strs[2]);
+		if(defense < 0)
+			defense = 3;
+		critterAttributes[1] = defense;
+		
+		int offense = parseIntFromString(strs[3]);
+		if(offense < 0)
+		offense = 3;
+		critterAttributes[2] = offense;
+		
+		int size = parseIntFromString(strs[4]);
+		if(size < 0)
+			size = 1;
+		critterAttributes[3] = size;
+		
+		int energy = parseIntFromString(strs[5]);
+		if(energy < 0)
+			energy = 500;
+		critterAttributes[4] = energy;
+		
+		int pass = 0;
+		critterAttributes[5] = pass;
+		
+		int tag = 0;
+		critterAttributes[6] = tag;
+		
+		int posture = parseIntFromString(strs[6]);
+		if(posture < 0 || posture > 99)
+			posture = 0;
+		critterAttributes[7] = posture;
+		
+		return critterAttributes;
+	}
+	
+	/**
+	 * Parses an integer value from a given string, or returns -1 if no integer was found.
+	 * @param s the string to parse
+	 * @return the int parsed from the string, or -1 if no integer was found
+	 */
+	private int parseIntFromString(String s)
+	{
+		try
+		{
+			return Integer.parseInt(s);
+		}
+		catch (NumberFormatException n)
+		{
+			return -1;
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/test/java/simulationTests/AttackTests.java b/src/test/java/simulationTests/AttackTests.java
new file mode 100644
index 0000000..2859cb7
--- /dev/null
+++ b/src/test/java/simulationTests/AttackTests.java
@@ -0,0 +1,28 @@
+package simulationTests;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class AttackTests {
+
+	Console console1 = null;
+	
+	@Before
+	 public void setup() {
+		 console1 = new Console();
+		 console1.loadWorld("src/test/resources/simulationTests/AttackWorld.txt");
+	 }
+	
+	/**
+	 * testBasicAttack tests attack by having a massive critter attack a tiny critter. The smaller critter
+	 * should die.
+	 */
+	@Test
+	public void testBasicAttack() {
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+	}
+}
diff --git a/src/test/java/simulationTests/BudTest.java b/src/test/java/simulationTests/BudTest.java
new file mode 100644
index 0000000..e24891d
--- /dev/null
+++ b/src/test/java/simulationTests/BudTest.java
@@ -0,0 +1,67 @@
+package simulationTests;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class BudTest {
+
+	Console console1 = null;
+	Console console2 = null;
+	Console console3 = null;
+
+	@Before
+	public void setup() {
+		console1 = new Console();
+		console1.loadWorld("src/test/resources/simulationTests/BudWorld.txt");
+		console2 = new Console();
+		console2.loadWorld("src/test/resources/simulationTests/BudWorldRock.txt");
+		console3 = new Console();
+		console3.loadWorld("src/test/resources/simulationTests/BudWorld3.txt");
+	}
+
+	/**
+	 * testBasicBud checks to see if a critter can bud under normal circumstances.
+	 */
+	@Test
+	public void testBasicBud() {
+		System.out.println("testBasicBud");
+		int initialNumCritters = console1.crittersAlive();
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+		assertEquals(initialNumCritters + 1, console1.crittersAlive());
+	}
+
+	/**
+	 * testBudWithRock checks to see that a critter does not bud when there is a
+	 * rock behind it.
+	 */
+	@Test
+	public void testBudWithRock() {
+		System.out.println("testBudWithRock");
+		int initialNumCritters = console2.crittersAlive();
+		console2.worldInfo();
+		console2.advanceTime(1);
+		console2.worldInfo();
+		assertEquals(initialNumCritters, console2.crittersAlive());
+	}
+
+	/**
+	 * testBudNoEnergy checks to see if a critter will die when it tries to bud with no energy.
+	 * It also tests to see if critter death properly adds a food object onto the site of death.
+	 */
+	@Test
+	public void testBudNoEnergy() {
+		System.out.println("testBudNoEnergy");
+		int initialNumCritters = console3.crittersAlive();
+		console3.worldInfo();
+		console3.advanceTime(1);
+		console3.worldInfo();
+		assertEquals(initialNumCritters - 1, console3.crittersAlive());
+	}
+
+}
diff --git a/src/test/java/simulationTests/MateTest.java b/src/test/java/simulationTests/MateTest.java
new file mode 100644
index 0000000..7c6efad
--- /dev/null
+++ b/src/test/java/simulationTests/MateTest.java
@@ -0,0 +1,83 @@
+package simulationTests;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class MateTest {
+	Console console1 = null;
+	Console console2 = null;
+	Console console3 = null;
+	Console console4 = null;
+	
+	@Before
+	public void setUp()
+	{
+		console1 = new Console();
+		console1.loadWorld("src/test/resources/simulationTests/MateWorld.txt");
+		console2 = new Console();
+		console2.loadWorld("src/test/resources/simulationTests/MateWorldRock.txt");
+		console3 = new Console();
+		console3.loadWorld("src/test/resources/simulationTests/MateWorldLittleEnergy.txt");
+		console4 = new Console();
+		console4.loadWorld("src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt");
+	}
+	
+	/**
+	 * simpleTest tests to see if two critters who want to mate can mate and create an offspring.
+	 */
+	
+	
+	@Test
+	public void simpleTest() {
+		System.out.println("simpleTest");
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+	}
+	
+	
+	/**
+	 * mateWithRock tests to see what happens when a couple of critters tries to mate but with a rock behind one of
+	 * them. The mating works if the baby is put behind the critter that is not in front of the rock, and the baby dies
+	 * if it is placed on the rock. 
+	 */
+	
+	@Test
+	public void mateWithRock() {
+		System.out.println("mateWithRock");
+		console2.worldInfo();
+		console2.advanceTime(1);
+		console2.worldInfo();
+	}
+	
+	/**
+	 * mateLittleEnergy checks to see what happens to the parents when they try to mate when they
+	 * do not have enough energy. The parents then die. 
+	 */
+	@Test
+	public void mateLittleEnergy() {
+		System.out.println("mateLittleEnergy");
+		console3.worldInfo();
+		console3.advanceTime(1);
+		console3.worldInfo();
+	}
+	
+	
+	
+	/**
+	 * mateDifferentTimeStep checks to see what happens when two parents want to mate, but they
+	 * want to mate on different time steps. While one of the parents wants to mate, the other one waits
+	 * and vice versa. As a result, the parents should not be able to mate. During this test, wait is also
+	 * tested in this test.
+	 */
+	@Test
+	public void mateDifferentTimeStep() {
+		System.out.println("mateDifferentTimeStep");
+		console4.worldInfo();
+		console4.advanceTime(17);
+		console4.worldInfo();
+	}
+	
+}
diff --git a/src/test/java/simulationTests/MovingTest.java b/src/test/java/simulationTests/MovingTest.java
new file mode 100644
index 0000000..18ff962
--- /dev/null
+++ b/src/test/java/simulationTests/MovingTest.java
@@ -0,0 +1,74 @@
+package simulationTests;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class MovingTest
+{
+	Console console1 = null;
+	Console console2 = null;
+	Console console3 = null;
+	Console console4 = null;
+	
+	@Before
+	public void setUp()
+	{
+		console1 = new Console();
+		console1.loadWorld("src/test/resources/simulationTests/MovingWorld.txt");
+		console2 = new Console();
+		console2.loadWorld("src/test/resources/simulationTests/MovingWorldFileRock.txt");
+		console3 = new Console();
+		console3.loadWorld("src/test/resources/simulationTests/MovingWorldThree.txt");
+		console4 = new Console();
+		console4.loadWorld("src/test/resources/simulationTests/MovingWorldFour.txt");
+		
+	}
+	/**
+	 * testNormalMove tests to see if moving forward normally works.
+	 */
+	@Test
+	public void testNormalMove()
+	{
+		System.out.println("testNormalMove");
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+	}
+	
+	/**
+	 * testMoveWithRock tests to see that critter won't move when there is a rock in front of it.
+	 */
+	@Test
+	public void testMoveWithRock() {
+		System.out.println("testMoveWithRock");
+		console2.worldInfo();
+		console2.advanceTime(1);
+		console2.worldInfo();
+	}
+	
+	/**
+	 * testMovingWithNoEnergy tests to see that a critter without enough energy to move dies.
+	 */
+	@Test
+	public void testMovingWithNoEnergy() {
+		System.out.println("testMovingWithNoEnergy");
+		console3.worldInfo();
+		console3.advanceTime(1);
+		console3.worldInfo();
+	}
+
+	/**
+	 * testMoveInvalidLocation checks to see if a critter does not move to an invalid location
+	 */
+	@Test
+	public void testMovingInvalidLocation() {
+		System.out.println("testMovingInvalidLocation");
+		console4.worldInfo();
+		console4.advanceTime(1);
+		console4.worldInfo();
+	}
+}
diff --git a/src/test/java/simulationTests/SpiralCritterTest.java b/src/test/java/simulationTests/SpiralCritterTest.java
new file mode 100644
index 0000000..18af1b3
--- /dev/null
+++ b/src/test/java/simulationTests/SpiralCritterTest.java
@@ -0,0 +1,29 @@
+package simulationTests;
+
+import org.junit.Test;
+
+import console.Console;
+
+public class SpiralCritterTest
+{
+
+	@Test
+	/** 
+	 * There isn't really any world functionality that allows us to perform automated testing for the spiral critter in any
+	 * practical way, so we just used this simple test and analyzed the successive printouts of the world grid after each
+	 * successive turn.
+	 */
+	public void test()
+	{
+		Console c = new Console();
+		c.loadWorld("src/test/resources/simulationTests/SpiralCritterWorld.txt");
+		c.worldInfo();
+		
+		for(int i = 0; i < 60; i++)
+		{
+			c.advanceTime(1);
+			c.worldInfo();
+		}
+	}
+
+}
diff --git a/src/test/java/simulationTests/TurnAndNearbyTests.java b/src/test/java/simulationTests/TurnAndNearbyTests.java
new file mode 100644
index 0000000..a1aa66a
--- /dev/null
+++ b/src/test/java/simulationTests/TurnAndNearbyTests.java
@@ -0,0 +1,48 @@
+package simulationTests;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import console.Console;
+
+public class TurnAndNearbyTests {
+
+	Console console1 = null;
+	Console console2 = null;
+	Console console3 = null;
+	Console console4 = null;
+
+	@Before
+	public void setUp() {
+		console1 = new Console();
+		console1.loadWorld("src/test/resources/simulationTests/TurnWorldTwo.txt");
+		console2 = new Console();
+		console2.loadWorld("src/test/resources/simulationTests/TurnNearbyWorld.txt");
+
+	}
+
+	/**
+	 * simpleTurn checks to see if a critter can turn right and left properly
+	 */
+	@Test
+	public void simpleTurn() {
+		System.out.println("simpleTurn");
+		console1.worldInfo();
+		console1.advanceTime(1);
+		console1.worldInfo();
+	}
+
+	/**
+	 * turnIfFood tests to see if a critter can turn if there is food right next to it. Nearby was
+	 * also tested by placing the food at different points around the critter and having the critter turn if
+	 * it can sense it. As a result, this test covers both functionalities. 
+	 */
+	
+	@Test
+	public void turnIfFood() {
+		System.out.println("turnIfFood");
+		console2.worldInfo();
+		console2.advanceTime(1);
+		console2.worldInfo();
+	}
+}
diff --git a/src/test/resources/simulationTests/AttackCritter1.txt b/src/test/resources/simulationTests/AttackCritter1.txt
new file mode 100644
index 0000000..efa20bd
--- /dev/null
+++ b/src/test/resources/simulationTests/AttackCritter1.txt
@@ -0,0 +1,8 @@
+species: Attack Critter 2
+memsize: 11
+defense: 2
+offense: 3000
+size: 50
+energy: 50000
+posture: 17
+3 = 3 --> attack;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/AttackCritter2.txt b/src/test/resources/simulationTests/AttackCritter2.txt
new file mode 100644
index 0000000..5b14f81
--- /dev/null
+++ b/src/test/resources/simulationTests/AttackCritter2.txt
@@ -0,0 +1,8 @@
+species: Attack Critter 2
+memsize: 11
+defense: 1
+offense: 3
+size: 1
+energy: 5
+posture: 17
+3 = 3 --> wait;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/AttackWorld.txt b/src/test/resources/simulationTests/AttackWorld.txt
new file mode 100644
index 0000000..d1151bb
--- /dev/null
+++ b/src/test/resources/simulationTests/AttackWorld.txt
@@ -0,0 +1,5 @@
+name Attack World 
+size 5 10
+
+critter src/test/resources/simulationTests/AttackCritter1.txt 3 4 0
+critter src/test/resources/simulationTests/AttackCritter2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudCritter.txt b/src/test/resources/simulationTests/BudCritter.txt
new file mode 100644
index 0000000..18fcd09
--- /dev/null
+++ b/src/test/resources/simulationTests/BudCritter.txt
@@ -0,0 +1,8 @@
+species: example
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 5000000
+posture: 17
+3 = 3 --> bud;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudCritterNoEnergy.txt b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
new file mode 100644
index 0000000..f289ce6
--- /dev/null
+++ b/src/test/resources/simulationTests/BudCritterNoEnergy.txt
@@ -0,0 +1,8 @@
+species: example
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 200
+posture: 17
+3 = 3 --> bud;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorld.txt b/src/test/resources/simulationTests/BudWorld.txt
new file mode 100644
index 0000000..f606bf2
--- /dev/null
+++ b/src/test/resources/simulationTests/BudWorld.txt
@@ -0,0 +1,4 @@
+name Bud World 1
+size 5 10
+
+critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorld3.txt b/src/test/resources/simulationTests/BudWorld3.txt
new file mode 100644
index 0000000..aea4f1b
--- /dev/null
+++ b/src/test/resources/simulationTests/BudWorld3.txt
@@ -0,0 +1,4 @@
+name Bud World 3
+size 5 10
+
+critter src/test/resources/simulationTests/BudCritterNoEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/BudWorldRock.txt b/src/test/resources/simulationTests/BudWorldRock.txt
new file mode 100644
index 0000000..e3bed1c
--- /dev/null
+++ b/src/test/resources/simulationTests/BudWorldRock.txt
@@ -0,0 +1,4 @@
+name Bud World 2
+size 5 10
+rock 3 4
+critter src/test/resources/simulationTests/BudCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorld.txt b/src/test/resources/simulationTests/MateWorld.txt
new file mode 100644
index 0000000..62ea1a2
--- /dev/null
+++ b/src/test/resources/simulationTests/MateWorld.txt
@@ -0,0 +1,5 @@
+name Mate World 
+size 5 10
+
+critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
+critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
new file mode 100644
index 0000000..127dfcd
--- /dev/null
+++ b/src/test/resources/simulationTests/MateWorldDifferentTimeSteps.txt
@@ -0,0 +1,5 @@
+name Mate World Different Time Steps
+size 5 10
+
+critter src/test/resources/simulationTests/MatingParent5.txt 3 4 0
+critter src/test/resources/simulationTests/MatingParent6.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldLittleEnergy.txt b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
new file mode 100644
index 0000000..7fe7a11
--- /dev/null
+++ b/src/test/resources/simulationTests/MateWorldLittleEnergy.txt
@@ -0,0 +1,5 @@
+name Mate World Little Energy
+size 5 10
+
+critter src/test/resources/simulationTests/MatingParent3.txt 3 4 0
+critter src/test/resources/simulationTests/MatingParent4.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MateWorldRock.txt b/src/test/resources/simulationTests/MateWorldRock.txt
new file mode 100644
index 0000000..5c3b717
--- /dev/null
+++ b/src/test/resources/simulationTests/MateWorldRock.txt
@@ -0,0 +1,5 @@
+name Mate World Rock
+size 5 10
+rock 3 6
+critter src/test/resources/simulationTests/MatingParent1.txt 3 4 0
+critter src/test/resources/simulationTests/MatingParent2.txt 3 5 3
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent1.txt b/src/test/resources/simulationTests/MatingParent1.txt
new file mode 100644
index 0000000..f64bca0
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent1.txt
@@ -0,0 +1,8 @@
+species: Parent 1
+memsize: 11
+defense: 2
+offense: 3
+size: 5
+energy: 50000
+posture: 17
+3 = 3 --> mate;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent2.txt b/src/test/resources/simulationTests/MatingParent2.txt
new file mode 100644
index 0000000..15b068a
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent2.txt
@@ -0,0 +1,8 @@
+species: Parent 2
+memsize: 11
+defense: 2
+offense: 3
+size: 5
+energy: 50000
+posture: 17
+3 = 3 --> mate;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent3.txt b/src/test/resources/simulationTests/MatingParent3.txt
new file mode 100644
index 0000000..1944f06
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent3.txt
@@ -0,0 +1,8 @@
+species: Parent 3
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 50000
+posture: 17
+3 = 3 --> mate;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent4.txt b/src/test/resources/simulationTests/MatingParent4.txt
new file mode 100644
index 0000000..e740384
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent4.txt
@@ -0,0 +1,8 @@
+species: Parent 4
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 50000
+posture: 17
+3 = 3 --> mate;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent5.txt b/src/test/resources/simulationTests/MatingParent5.txt
new file mode 100644
index 0000000..6f0890a
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent5.txt
@@ -0,0 +1,9 @@
+species: Parent 5
+memsize: 11
+defense: 2
+offense: 3
+size: 5
+energy: 50000
+posture: 17
+mem[8] = 0 --> mem[8] := 1 wait;
+mem[8] = 1 --> mem[8] := 0 mate;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MatingParent6.txt b/src/test/resources/simulationTests/MatingParent6.txt
new file mode 100644
index 0000000..b112422
--- /dev/null
+++ b/src/test/resources/simulationTests/MatingParent6.txt
@@ -0,0 +1,9 @@
+species: Parent 6
+memsize: 11
+defense: 2
+offense: 3
+size: 5
+energy: 50000
+posture: 17
+mem[8] = 0 --> mem[8] := 1 mate;
+mem[8] = 1 --> mem[8] := 0 wait;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingCritter.txt b/src/test/resources/simulationTests/MovingCritter.txt
new file mode 100644
index 0000000..3bb2486
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingCritter.txt
@@ -0,0 +1,8 @@
+species: example
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 500
+posture: 17
+3 = 3 --> forward;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
new file mode 100644
index 0000000..1dc3af5
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingCritterLittleEnergy.txt
@@ -0,0 +1,8 @@
+species: example
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 2
+posture: 17
+3 = 3 --> forward;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorld.txt b/src/test/resources/simulationTests/MovingWorld.txt
new file mode 100644
index 0000000..6f1baea
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingWorld.txt
@@ -0,0 +1,4 @@
+name Moving World
+size 5 10
+
+critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorldFileRock.txt b/src/test/resources/simulationTests/MovingWorldFileRock.txt
new file mode 100644
index 0000000..845f953
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingWorldFileRock.txt
@@ -0,0 +1,4 @@
+name Moving World2
+size 5 10
+rock 3 6
+critter src/test/resources/simulationTests/MovingCritter.txt 3 5 0
diff --git a/src/test/resources/simulationTests/MovingWorldFour.txt b/src/test/resources/simulationTests/MovingWorldFour.txt
new file mode 100644
index 0000000..c9a3ea8
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingWorldFour.txt
@@ -0,0 +1,4 @@
+name Moving World 4
+size 5 10
+
+critter src/test/resources/simulationTests/MovingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/MovingWorldThree.txt b/src/test/resources/simulationTests/MovingWorldThree.txt
new file mode 100644
index 0000000..322aa54
--- /dev/null
+++ b/src/test/resources/simulationTests/MovingWorldThree.txt
@@ -0,0 +1,4 @@
+name Moving World 3
+size 5 10
+
+critter src/test/resources/simulationTests/MovingCritterLittleEnergy.txt 3 5 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SensingCritter.txt b/src/test/resources/simulationTests/SensingCritter.txt
new file mode 100644
index 0000000..dcb097b
--- /dev/null
+++ b/src/test/resources/simulationTests/SensingCritter.txt
@@ -0,0 +1,9 @@
+species: Sensing Critter
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 500
+posture: 17
+
+ahead[1] = -1 --> backward;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SensingWorld.txt b/src/test/resources/simulationTests/SensingWorld.txt
new file mode 100644
index 0000000..5abacf0
--- /dev/null
+++ b/src/test/resources/simulationTests/SensingWorld.txt
@@ -0,0 +1,4 @@
+name Sensing World 1
+size 5 10
+
+critter SensingCritter.txt 4 9 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/SpiralCritterWorld.txt b/src/test/resources/simulationTests/SpiralCritterWorld.txt
new file mode 100644
index 0000000..7102f96
--- /dev/null
+++ b/src/test/resources/simulationTests/SpiralCritterWorld.txt
@@ -0,0 +1,3 @@
+name Spiral World
+size 11 13
+critter src/test/resources/simulationTests/spiral_critter.txt 5 6 0
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/TurnNearbyWorld.txt b/src/test/resources/simulationTests/TurnNearbyWorld.txt
new file mode 100644
index 0000000..64bb6c2
--- /dev/null
+++ b/src/test/resources/simulationTests/TurnNearbyWorld.txt
@@ -0,0 +1,4 @@
+name Turn World 1
+size 5 10
+food 3 3 500
+critter src/test/resources/simulationTests/Turner1.txt 3 4 0
diff --git a/src/test/resources/simulationTests/TurnWorldTwo.txt b/src/test/resources/simulationTests/TurnWorldTwo.txt
new file mode 100644
index 0000000..d53c1bb
--- /dev/null
+++ b/src/test/resources/simulationTests/TurnWorldTwo.txt
@@ -0,0 +1,3 @@
+name Turn World 1
+size 5 10
+critter src/test/resources/simulationTests/Turner2.txt 3 4 0
diff --git a/src/test/resources/simulationTests/Turner1.txt b/src/test/resources/simulationTests/Turner1.txt
new file mode 100644
index 0000000..1647100
--- /dev/null
+++ b/src/test/resources/simulationTests/Turner1.txt
@@ -0,0 +1,8 @@
+species: Turner 1
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 50000
+posture: 17
+nearby[3] < -1 --> right;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/Turner2.txt b/src/test/resources/simulationTests/Turner2.txt
new file mode 100644
index 0000000..56f98be
--- /dev/null
+++ b/src/test/resources/simulationTests/Turner2.txt
@@ -0,0 +1,8 @@
+species: Turner 1
+memsize: 11
+defense: 2
+offense: 3
+size: 1
+energy: 50000
+posture: 17
+3 = 3  --> left;
\ No newline at end of file
diff --git a/src/test/resources/simulationTests/spiral_critter.txt b/src/test/resources/simulationTests/spiral_critter.txt
new file mode 100644
index 0000000..8da44ad
--- /dev/null
+++ b/src/test/resources/simulationTests/spiral_critter.txt
@@ -0,0 +1,21 @@
+species: Spiral
+memsize: 12
+defense: 2
+offense: 3
+size: 1
+energy: 500
+posture: 17
+
+//ensures that the critter has enough energy, and will eat food in its way
+ENERGY <= SIZE * 3 --> wait;
+ahead[1] < -1 --> eat;
+
+mem[9] = 0 --> mem[8] := mem[8] + 1 mem[9] := 1 forward;
+
+mem[9] = 1 and mem[10] = 0 --> mem[10] := mem[10] + 1 right;
+mem[10] = 1 and mem[11] < mem[8] - 1 --> mem[11] := mem[11] + 1 forward;
+mem[10] = 1 and mem[11] = mem[8] - 1 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+
+mem[11] < mem[8] --> mem[11] := mem[11] + 1 forward;
+mem[11] = mem[8] and mem[10] < 6 --> mem[10] := mem[10] + 1 mem[11] := 0 right;
+mem[10] = 6 and mem[9] = 1 --> mem[9] := 0 mem[10] := 0 mem[11] := 0;
\ No newline at end of file
diff --git a/world.txt b/world.txt
new file mode 100644
index 0000000..91bdd68
--- /dev/null
+++ b/world.txt
@@ -0,0 +1,14 @@
+name Small world
+size 10 15
+rock 2 2
+rock 3 6
+rock 9 10
+
+// Some food
+food 4 4 500
+food 1 3 1000
+
+// example-critter.txt should be in the working directory
+critter example-critter.txt 2 5 3
+critter example-critter.txt 4 3 1
+critter example-critter.txt 4 4 2
