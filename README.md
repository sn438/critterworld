# Assignment 4

Included in this README is information on using Git and Gradle, which are a part of the final project. Please add your regular README information under the README section. Note that Github uses markdown (.md extension) to format its READMEs. Find more information on markdown here: https://guides.github.com/features/mastering-markdown/

---
## README
\\\\TODO- Fill me out!

---

First Time Setup
================
The final project will require Gradle and Git. Downloads can be found here:
* Gradle: https://gradle.org/install/
* Git: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

To get started, you will want to clone your git repository, which we have already set up for you. To do this, look for the green "Clone or download" button on the right. Once you click on this, a url should pop up. Copy this url, and then pull up your terminal and navigate to whatever folder you would like to download your repository to. Then, run the following command:

```
git clone <your url here>
```

You should see your project automatically get downloaded. Navigate into your new local repository using `cd` and, if you haven't done so already, run the following two commands to set up your profile:

```
git config --global user.name "netIDHere"
git config --global user.email netId@cornell.edu
```

This will set your github username and email for all future git projects so that it knows who to attribute your changes to. For more in depth setup instructions, see the documentation: https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup

We have already provided a .gitignore file that ignores files generated by gradle. This is a common convention to keep repositories free of files generated by tools like Gradle or your favorite IDE.

Now that you have downloaded and set up your git repository, it is time to import that project as a Gradle project in Eclipse.
Right click in the project explorer, then click Import. Select Gradle -> Existing Gradle Project.

---

# Distributed Version Control: Git

Distributed Version Control is a system that allows users to track and distribute different versions of their code. Git is a commonly used example of a version control system. The motivation is this: You’re happily coding along for A4 and things are working great. Suddenly, you realize that within the last few changes you made, you accidentally introduced a bug. However, you don’t know how many undoes to make in order to have a working assignment again! This is where version control comes in. It lets you take *control* over the different *versions* of your project by keeping a history of all the changes you’ve made. This means you can revert back to previous versions should you make a mistake. In addition, you can push your code to places called repositories that other people can see and get your code from. This makes it very easy to *distribute* your code and collaborate with others. We will be working through Github, a company that hosts projects that use Git version control.

### Overview

How does Git get code from your computer to your collaborators? Your code is actually tracked in multiple places at once. We call each of these places a *repository*. For a single project with no dependencies, you will have two repositories:

* The local repository- This is the folder on your computer where you keep your code. When you begin using git, you have to initialize a folder (or directory- they mean the same thing) in order to have git track its files. This creates a .git file in the folder that tells git about your code’s history and what remote repository it is connected to.
There is a kind of staging area in your local repository, which we will discuss with git add.
* The remote repository- In order to distribute code, GitHub hosts public repositories that are free to use. Much like the local repositories, these remote repositories hold a copy of your code and code history. However, unlike your local repository, you can access remote repositories online through Github’s website.

In order to make progress on your code using distributed version control, you must explicitly save a version using Git’s commands. To get changes from your local repository to your corresponding remote repository hosted by GitHub, you must go through 3 steps/commands:
* `git add` <File1> <File2> <etc>- This command adds your changed files to the staging area mentioned earlier. At the staging area, no official changes have been made: you are only preparing for a full commit at this point. There are many useful options, such as -A, which adds all changed files. More options and detail can be found here: https://git-scm.com/docs/git-add
* `git commit`- This command takes all the changes in your staging area, and commits them to the git history. This is a permanent change to your version history, but this should not scare you as all versions are tracked through version control. However, this does not tell your remote repository that you have made changes on your local computer. The next command will take care of that. In Git, every version is often called a commit, and each commit gets a unique ID that can be used to revert back to that specific version. All git commits are required to have a descriptive message, so the -m <message> flag is quite convenient. See more here: https://git-scm.com/docs/git-commit
* `git push`- This command pushes all your changes to your remote repository, essentially syncing up your remote repository with the changes you made from your local computer. Read more here: https://git-scm.com/docs/git-push

When working with multiple people, there is still only one remote repository. However, each person will have a different local repository. To share your code, you will have to add, commit, and push your changes to the remote repository for the project. In order to get changes that other collaborators have made, you must use two other commands:
* `git fetch`- This fetches the changes from the remote repository, but does not do anything with them. https://git-scm.com/docs/git-fetch
* `git merge`- This takes any changes that were fetched, and attempts to merge those with your version of the code. Say your partner pushed their changes, you would typically fetch those changes, and then merge them in with your code. This may cause merge conflicts, which must be resolved by hand and the final result must be committed.
Because of how often you'll want to merge all the new changes you fetch, there is a command `git pull` that runs both fetch and merge.

Another important command is `git checkout`, which is how you navigate to previous commits. As mentioned above, each commit has a SHA-1 checksum as an identifier. These can be found by browsing through the output of `git log` or by looking through github at your previous commits. From there, you can run `git checkout <commit SHA-1 here>` to revert back to that commit.


### Getting Started With Git

Git installation instructions can be found here: https://git-scm.com/book/id/v2/Getting-Started-Installing-Git
This website also contains official documentation for all git commands, and is very good reference material.
We recommend using Git from terminal. We described the bare minimum functionality, so if you're interesetd in improving your workflow further, here is a list of useful git commands:
* `git branch`: https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging This one is especially useful and relevant for this project. It allows multiple people to work on different versions of the code without directly affecting the others.
* `git rebase`: https://git-scm.com/book/en/v2/Git-Branching-Rebasing A good tool that goes along with git branch.
* `git remote`: https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes
* `git bisect`: https://git-scm.com/docs/git-bisect Kind of a cool option- it lets you do a binary search in your commit history for a bug.
* `git submodule`: https://git-scm.com/docs/git-submodule Good for if you work on a project that references another git project.

---
# Gradle

Gradle is a build system that helps with managing dependencies and automating common tasks. In your final project, you will have to use a few extra libraries which we will provide and have you use through Gradle. You can specify these libraries in the Gradle build file, and Gradle automatically handles the rest.

We have provided you with a build file to be used for A4-A7.
You should not need to make any changes to this file, unless you want to use other libraries as part of your project.
The rest of this section explains the motivation behind why we are using Gradle, how it can be helpful to you, and the basics of adding additional libraries to your project.

### What is a .jar file?

JAR stands for Java ARchine.
It is essentially a way to group lots of files together, similar to a .zip file.
When you write a Java program, you write .java files.
Then the Java compiler creates .class files from your .java files.
You can combine these .class files, along with other resources such as images or text files, into a single .jar file.

Some .jar files are executable.
When creating the .jar, you indicate which class is the main class.
This class's `static void main` method is then executed when you either double-click on the .jar or run it from the command line using:
```
java -jar <name-of-jar-file> <command-line-arguments>
```

Other .jar files are simply collections of Java classes.
They may have classes or methods that you want to use in your own projects.
For example, the Gson .jar file is a distribution of classes that are used to manipulate JSON strings.
You tell Eclipse where to find this .jar, then you can use it's classes in your project.

You can create your own .jar files in Eclipse by right clicking your project and selecting Export.


### Managing .jar files with a build system.

Manually installing .jar files for every project you create is cumbersome.
Therefore it is helpful to use a "build system" to help manage your files.
We use a build system called "Gradle" in this course.

Gradle should already be installed with Eclipse.
To create a Gradle project, go to `File -> New -> Project...`, then select `Gradle -> Gradle Project`.

Click through the menu and enter a project name to create the project.
You will notice your project has several differnet files listed in Eclipse's Package Explorer.
First look at the `build.gradle` file.
This file controls all of your project's dependencies.
There are some default settings in the dependencies section.
If you expand the Project and External Dependencies dropdown in the Package Explorer, you will see the .jar files listed along with these dependencies.

Let's make a small change.
To add the Gson library to your list of .jar files, add the following line to the dependencies section:
```
compile group: 'com.google.code.gson', name: 'gson', version: '2.4'
```
Then right click your package in Eclipse and select `Gradle -> Refresh Gradle Project`.
You will now see the new .jar file added in the Project Explorer.
Now you can import the classes from this .jar file and use them throughout your project.

